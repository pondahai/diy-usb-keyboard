
Arduino-serialusbkeyboard.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000004  00800100  00000e9c  00000f30  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000e9c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000019e  00800104  00800104  00000f34  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00000f34  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000f48  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002e0  00000000  00000000  00000f88  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000049b8  00000000  00000000  00001268  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001621  00000000  00000000  00005c20  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002ccf  00000000  00000000  00007241  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000007b8  00000000  00000000  00009f10  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001aed  00000000  00000000  0000a6c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002ef4  00000000  00000000  0000c1b5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000388  00000000  00000000  0000f0a9  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	99 c0       	rjmp	.+306    	; 0x134 <__ctors_end>
   2:	00 00       	nop
   4:	b2 c0       	rjmp	.+356    	; 0x16a <__bad_interrupt>
   6:	00 00       	nop
   8:	b0 c0       	rjmp	.+352    	; 0x16a <__bad_interrupt>
   a:	00 00       	nop
   c:	ae c0       	rjmp	.+348    	; 0x16a <__bad_interrupt>
   e:	00 00       	nop
  10:	ac c0       	rjmp	.+344    	; 0x16a <__bad_interrupt>
  12:	00 00       	nop
  14:	aa c0       	rjmp	.+340    	; 0x16a <__bad_interrupt>
  16:	00 00       	nop
  18:	a8 c0       	rjmp	.+336    	; 0x16a <__bad_interrupt>
  1a:	00 00       	nop
  1c:	a6 c0       	rjmp	.+332    	; 0x16a <__bad_interrupt>
  1e:	00 00       	nop
  20:	a4 c0       	rjmp	.+328    	; 0x16a <__bad_interrupt>
  22:	00 00       	nop
  24:	a2 c0       	rjmp	.+324    	; 0x16a <__bad_interrupt>
  26:	00 00       	nop
  28:	a0 c0       	rjmp	.+320    	; 0x16a <__bad_interrupt>
  2a:	00 00       	nop
  2c:	e9 c4       	rjmp	.+2514   	; 0xa00 <__vector_11>
  2e:	00 00       	nop
  30:	8e c5       	rjmp	.+2844   	; 0xb4e <__vector_12>
  32:	00 00       	nop
  34:	9a c0       	rjmp	.+308    	; 0x16a <__bad_interrupt>
  36:	00 00       	nop
  38:	98 c0       	rjmp	.+304    	; 0x16a <__bad_interrupt>
  3a:	00 00       	nop
  3c:	96 c0       	rjmp	.+300    	; 0x16a <__bad_interrupt>
  3e:	00 00       	nop
  40:	94 c0       	rjmp	.+296    	; 0x16a <__bad_interrupt>
  42:	00 00       	nop
  44:	92 c0       	rjmp	.+292    	; 0x16a <__bad_interrupt>
  46:	00 00       	nop
  48:	90 c0       	rjmp	.+288    	; 0x16a <__bad_interrupt>
  4a:	00 00       	nop
  4c:	8e c0       	rjmp	.+284    	; 0x16a <__bad_interrupt>
  4e:	00 00       	nop
  50:	8c c0       	rjmp	.+280    	; 0x16a <__bad_interrupt>
  52:	00 00       	nop
  54:	8a c0       	rjmp	.+276    	; 0x16a <__bad_interrupt>
  56:	00 00       	nop
  58:	88 c0       	rjmp	.+272    	; 0x16a <__bad_interrupt>
  5a:	00 00       	nop
  5c:	b9 c2       	rjmp	.+1394   	; 0x5d0 <__vector_23>
  5e:	00 00       	nop
  60:	84 c0       	rjmp	.+264    	; 0x16a <__bad_interrupt>
  62:	00 00       	nop
  64:	82 c0       	rjmp	.+260    	; 0x16a <__bad_interrupt>
  66:	00 00       	nop
  68:	80 c0       	rjmp	.+256    	; 0x16a <__bad_interrupt>
  6a:	00 00       	nop
  6c:	7e c0       	rjmp	.+252    	; 0x16a <__bad_interrupt>
  6e:	00 00       	nop
  70:	7c c0       	rjmp	.+248    	; 0x16a <__bad_interrupt>
  72:	00 00       	nop

00000074 <ProductString>:
  74:	26 03 4c 00 55 00 46 00 41 00 20 00 4b 00 65 00     &.L.U.F.A. .K.e.
  84:	79 00 62 00 6f 00 61 00 72 00 64 00 20 00 44 00     y.b.o.a.r.d. .D.
  94:	65 00 6d 00 6f 00 00 00                             e.m.o...

0000009c <ManufacturerString>:
  9c:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
  ac:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

000000b6 <LanguageString>:
  b6:	04 03 09 04                                         ....

000000ba <ConfigurationDescriptor>:
  ba:	09 02 29 00 01 01 00 c0 32 09 04 00 00 02 03 01     ..).....2.......
  ca:	01 00 09 21 11 01 00 01 22 3f 00 07 05 81 03 08     ...!...."?......
  da:	00 0a 07 05 02 03 08 00 0a                          .........

000000e3 <DeviceDescriptor>:
  e3:	12 01 10 01 00 00 00 08 eb 03 42 20 01 00 01 02     ..........B ....
  f3:	00 01                                               ..

000000f5 <KeyboardReport>:
  f5:	05 01 09 06 a1 01 75 01 95 08 05 07 19 e0 29 e7     ......u.......).
 105:	15 00 25 01 81 02 95 01 75 08 81 03 95 05 75 01     ..%.....u.....u.
 115:	05 08 19 01 29 05 91 02 95 01 75 03 91 03 95 06     ....).....u.....
 125:	75 08 15 00 25 65 05 07 19 00 29 65 81 00 c0        u...%e....)e...

00000134 <__ctors_end>:
 134:	11 24       	eor	r1, r1
 136:	1f be       	out	0x3f, r1	; 63
 138:	cf ef       	ldi	r28, 0xFF	; 255
 13a:	d2 e0       	ldi	r29, 0x02	; 2
 13c:	de bf       	out	0x3e, r29	; 62
 13e:	cd bf       	out	0x3d, r28	; 61

00000140 <__do_copy_data>:
 140:	11 e0       	ldi	r17, 0x01	; 1
 142:	a0 e0       	ldi	r26, 0x00	; 0
 144:	b1 e0       	ldi	r27, 0x01	; 1
 146:	ec e9       	ldi	r30, 0x9C	; 156
 148:	fe e0       	ldi	r31, 0x0E	; 14
 14a:	02 c0       	rjmp	.+4      	; 0x150 <__do_copy_data+0x10>
 14c:	05 90       	lpm	r0, Z+
 14e:	0d 92       	st	X+, r0
 150:	a4 30       	cpi	r26, 0x04	; 4
 152:	b1 07       	cpc	r27, r17
 154:	d9 f7       	brne	.-10     	; 0x14c <__do_copy_data+0xc>

00000156 <__do_clear_bss>:
 156:	22 e0       	ldi	r18, 0x02	; 2
 158:	a4 e0       	ldi	r26, 0x04	; 4
 15a:	b1 e0       	ldi	r27, 0x01	; 1
 15c:	01 c0       	rjmp	.+2      	; 0x160 <.do_clear_bss_start>

0000015e <.do_clear_bss_loop>:
 15e:	1d 92       	st	X+, r1

00000160 <.do_clear_bss_start>:
 160:	a2 3a       	cpi	r26, 0xA2	; 162
 162:	b2 07       	cpc	r27, r18
 164:	e1 f7       	brne	.-8      	; 0x15e <.do_clear_bss_loop>
 166:	fa d1       	rcall	.+1012   	; 0x55c <main>
 168:	97 c6       	rjmp	.+3374   	; 0xe98 <_exit>

0000016a <__bad_interrupt>:
 16a:	4a cf       	rjmp	.-364    	; 0x0 <__vectors>

0000016c <LEDs_SetAllLEDs>:
				PORTD |= LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD | LEDS_ALL_LEDS) & ~LEDMask);
 16c:	9b b1       	in	r25, 0x0b	; 11
 16e:	90 63       	ori	r25, 0x30	; 48
 170:	80 95       	com	r24
 172:	98 23       	and	r25, r24
 174:	9b b9       	out	0x0b, r25	; 11
			}
 176:	08 95       	ret

00000178 <RingBuffer_Remove.constprop.3>:
		 *
		 *  \return Next data element stored in the buffer
		 */
		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
		{
			RingBuff_Data_t Data = *Buffer->Out;
 178:	e0 91 93 02 	lds	r30, 0x0293	; 0x800293 <USARTtoUSB_Buffer+0x82>
 17c:	f0 91 94 02 	lds	r31, 0x0294	; 0x800294 <USARTtoUSB_Buffer+0x83>
 180:	81 91       	ld	r24, Z+
			
			if (++Buffer->Out == &Buffer->Buffer[BUFFER_SIZE])
 182:	92 e0       	ldi	r25, 0x02	; 2
 184:	e1 39       	cpi	r30, 0x91	; 145
 186:	f9 07       	cpc	r31, r25
 188:	69 f0       	breq	.+26     	; 0x1a4 <RingBuffer_Remove.constprop.3+0x2c>
 18a:	f0 93 94 02 	sts	0x0294, r31	; 0x800294 <USARTtoUSB_Buffer+0x83>
 18e:	e0 93 93 02 	sts	0x0293, r30	; 0x800293 <USARTtoUSB_Buffer+0x82>
			  Buffer->Out = Buffer->Buffer;

			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 192:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 194:	f8 94       	cli
			{
				Buffer->Count--;
 196:	90 91 95 02 	lds	r25, 0x0295	; 0x800295 <USARTtoUSB_Buffer+0x84>
 19a:	91 50       	subi	r25, 0x01	; 1
 19c:	90 93 95 02 	sts	0x0295, r25	; 0x800295 <USARTtoUSB_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 1a0:	2f bf       	out	0x3f, r18	; 63
			}
			
			return Data;
		}
 1a2:	08 95       	ret
		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
		{
			RingBuff_Data_t Data = *Buffer->Out;
			
			if (++Buffer->Out == &Buffer->Buffer[BUFFER_SIZE])
			  Buffer->Out = Buffer->Buffer;
 1a4:	21 e1       	ldi	r18, 0x11	; 17
 1a6:	32 e0       	ldi	r19, 0x02	; 2
 1a8:	30 93 94 02 	sts	0x0294, r19	; 0x800294 <USARTtoUSB_Buffer+0x83>
 1ac:	20 93 93 02 	sts	0x0293, r18	; 0x800293 <USARTtoUSB_Buffer+0x82>
 1b0:	f0 cf       	rjmp	.-32     	; 0x192 <RingBuffer_Remove.constprop.3+0x1a>

000001b2 <SetupHardware>:
	}
}

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
 1b2:	cf 93       	push	r28
 1b4:	df 93       	push	r29
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
 1b6:	84 b7       	in	r24, 0x34	; 52
 1b8:	87 7f       	andi	r24, 0xF7	; 247
 1ba:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
 1bc:	0f b6       	in	r0, 0x3f	; 63
 1be:	f8 94       	cli
 1c0:	a8 95       	wdr
 1c2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__EEPROM_REGION_LENGTH__+0x7f0060>
 1c6:	88 61       	ori	r24, 0x18	; 24
 1c8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__EEPROM_REGION_LENGTH__+0x7f0060>
 1cc:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__EEPROM_REGION_LENGTH__+0x7f0060>
 1d0:	0f be       	out	0x3f, r0	; 63
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
 1d2:	87 e6       	ldi	r24, 0x67	; 103
 1d4:	90 e0       	ldi	r25, 0x00	; 0
 1d6:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__EEPROM_REGION_LENGTH__+0x7f00cd>
 1da:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__EEPROM_REGION_LENGTH__+0x7f00cc>

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
 1de:	86 e0       	ldi	r24, 0x06	; 6
 1e0:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__EEPROM_REGION_LENGTH__+0x7f00ca>
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
 1e4:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__EEPROM_REGION_LENGTH__+0x7f00c8>
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
 1e8:	c9 ec       	ldi	r28, 0xC9	; 201
 1ea:	d0 e0       	ldi	r29, 0x00	; 0
 1ec:	88 e1       	ldi	r24, 0x18	; 24
 1ee:	88 83       	st	Y, r24
				
				DDRD  |= (1 << 3);
 1f0:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
 1f2:	5a 9a       	sbi	0x0b, 2	; 11

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |= LEDS_ALL_LEDS;
 1f4:	8a b1       	in	r24, 0x0a	; 10
 1f6:	80 63       	ori	r24, 0x30	; 48
 1f8:	8a b9       	out	0x0a, r24	; 10
				PORTD |= LEDS_ALL_LEDS;
 1fa:	8b b1       	in	r24, 0x0b	; 11
 1fc:	80 63       	ori	r24, 0x30	; 48
 1fe:	8b b9       	out	0x0b, r24	; 11
	// clock_prescale_set(clock_div_1);

	/* Hardware Initialization */
	Serial_Init(9600, false);
	LEDs_Init();
	USB_Init();
 200:	f4 d3       	rcall	.+2024   	; 0x9ea <USB_Init>

	/* Start the flush timer so that overflows occur rapidly to push received bytes to the USB interface */
	// TCCR0B = (1 << CS02);
	
	/* Pull target /RESET line high */
	AVR_RESET_LINE_PORT |= AVR_RESET_LINE_MASK;
 202:	5f 9a       	sbi	0x0b, 7	; 11
	AVR_RESET_LINE_DDR  |= AVR_RESET_LINE_MASK;
 204:	57 9a       	sbi	0x0a, 7	; 10



    /* Must turn off USART before reconfiguring it, otherwise incorrect operation may occur */
    UCSR1B = 0;
 206:	18 82       	st	Y, r1

	UCSR1B = ((1 << RXCIE1) | (0 << TXEN1) | (1 << RXEN1));
 208:	80 e9       	ldi	r24, 0x90	; 144
 20a:	88 83       	st	Y, r24

}
 20c:	df 91       	pop	r29
 20e:	cf 91       	pop	r28
 210:	08 95       	ret

00000212 <EVENT_USB_Device_Connect>:
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Device_Connect(void)
{
	/* Indicate USB enumerating */
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
 212:	80 e1       	ldi	r24, 0x10	; 16
 214:	ab df       	rcall	.-170    	; 0x16c <LEDs_SetAllLEDs>

	/* Default to report protocol on connect */
	UsingReportProtocol = true;
 216:	81 e0       	ldi	r24, 0x01	; 1
 218:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <UsingReportProtocol>
}
 21c:	08 95       	ret

0000021e <EVENT_USB_Device_Disconnect>:
 *  the status LEDs.
 */
void EVENT_USB_Device_Disconnect(void)
{
	/* Indicate USB not ready */
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
 21e:	80 e2       	ldi	r24, 0x20	; 32
 220:	a5 cf       	rjmp	.-182    	; 0x16c <LEDs_SetAllLEDs>

00000222 <EVENT_USB_Device_ConfigurationChanged>:
}

/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
 222:	cf 93       	push	r28
			                                                    const uint8_t Type,
			                                                    const uint8_t Direction,
			                                                    const uint16_t Size,
			                                                    const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
 224:	42 e0       	ldi	r20, 0x02	; 2
 226:	61 ec       	ldi	r22, 0xC1	; 193
 228:	81 e0       	ldi	r24, 0x01	; 1
 22a:	4c d2       	rcall	.+1176   	; 0x6c4 <Endpoint_ConfigureEndpoint_Prv>
 22c:	c8 2f       	mov	r28, r24
 22e:	42 e0       	ldi	r20, 0x02	; 2
 230:	60 ec       	ldi	r22, 0xC0	; 192
 232:	82 e0       	ldi	r24, 0x02	; 2
 234:	47 d2       	rcall	.+1166   	; 0x6c4 <Endpoint_ConfigureEndpoint_Prv>
			 *  at the start of each USB frame when enumerated in device mode.
			 */
			static inline void USB_Device_EnableSOFEvents(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableSOFEvents(void)
			{
				USB_INT_Enable(USB_INT_SOFI);
 236:	90 91 e2 00 	lds	r25, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 23a:	94 60       	ori	r25, 0x04	; 4
 23c:	90 93 e2 00 	sts	0x00E2, r25	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>

	/* Turn on Start-of-Frame events for tracking HID report period exiry */
	USB_Device_EnableSOFEvents();

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
 240:	88 23       	and	r24, r24
 242:	19 f0       	breq	.+6      	; 0x24a <EVENT_USB_Device_ConfigurationChanged+0x28>
 244:	80 e1       	ldi	r24, 0x10	; 16
 246:	c1 11       	cpse	r28, r1
 248:	01 c0       	rjmp	.+2      	; 0x24c <EVENT_USB_Device_ConfigurationChanged+0x2a>
}
 24a:	80 e2       	ldi	r24, 0x20	; 32

	/* Turn on Start-of-Frame events for tracking HID report period exiry */
	USB_Device_EnableSOFEvents();

	/* Indicate endpoint configuration success or failure */
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
 24c:	cf 91       	pop	r28
 24e:	8e cf       	rjmp	.-228    	; 0x16c <LEDs_SetAllLEDs>

00000250 <EVENT_USB_Device_StartOfFrame>:

/** Event handler for the USB device Start Of Frame event. */
void EVENT_USB_Device_StartOfFrame(void)
{
	/* One millisecond has elapsed, decrement the idle time remaining counter if it has not already elapsed */
	if (IdleMSRemaining)
 250:	80 91 04 02 	lds	r24, 0x0204	; 0x800204 <IdleMSRemaining>
 254:	90 91 05 02 	lds	r25, 0x0205	; 0x800205 <IdleMSRemaining+0x1>
 258:	00 97       	sbiw	r24, 0x00	; 0
 25a:	29 f0       	breq	.+10     	; 0x266 <EVENT_USB_Device_StartOfFrame+0x16>
	  IdleMSRemaining--;
 25c:	01 97       	sbiw	r24, 0x01	; 1
 25e:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <IdleMSRemaining+0x1>
 262:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <IdleMSRemaining>
}
 266:	08 95       	ret

00000268 <CreateKeyboardReport>:
/** Fills the given HID report data structure with the next HID report to send to the host.
 *
 *  \param[out] ReportData  Pointer to a HID report data structure to be filled
 */
void CreateKeyboardReport(USB_KeyboardReport_Data_t* const ReportData)
{
 268:	cf 93       	push	r28
 26a:	df 93       	push	r29
 26c:	fc 01       	movw	r30, r24
	// uint8_t JoyStatus_LCL     = Joystick_GetStatus();
	// uint8_t ButtonStatus_LCL  = Buttons_GetStatus();

    /* Clear the report contents */
    memset(ReportData, 0, sizeof(USB_KeyboardReport_Data_t));
 26e:	88 e0       	ldi	r24, 0x08	; 8
 270:	df 01       	movw	r26, r30
 272:	1d 92       	st	X+, r1
 274:	8a 95       	dec	r24
 276:	e9 f7       	brne	.-6      	; 0x272 <CreateKeyboardReport+0xa>


                /* Make sent key uppercase by indicating that the left shift key is pressed */
                ReportData->Modifier = 0;
 278:	10 82       	st	Z, r1
                if(scancode_buffer[0xe0] == 0x55)
 27a:	80 91 e4 01 	lds	r24, 0x01E4	; 0x8001e4 <__data_end+0xe0>
 27e:	85 35       	cpi	r24, 0x55	; 85
 280:	11 f4       	brne	.+4      	; 0x286 <CreateKeyboardReport+0x1e>
                    ReportData->Modifier |= KEYBOARD_MODIFER_LEFTCTRL;
 282:	81 e0       	ldi	r24, 0x01	; 1
 284:	80 83       	st	Z, r24
                if(scancode_buffer[0xe1] == 0x55)
 286:	80 91 e5 01 	lds	r24, 0x01E5	; 0x8001e5 <__data_end+0xe1>
 28a:	85 35       	cpi	r24, 0x55	; 85
 28c:	19 f4       	brne	.+6      	; 0x294 <CreateKeyboardReport+0x2c>
                    ReportData->Modifier |= KEYBOARD_MODIFER_LEFTSHIFT;
 28e:	80 81       	ld	r24, Z
 290:	82 60       	ori	r24, 0x02	; 2
 292:	80 83       	st	Z, r24
                if(scancode_buffer[0xe2] == 0x55)
 294:	80 91 e6 01 	lds	r24, 0x01E6	; 0x8001e6 <__data_end+0xe2>
 298:	85 35       	cpi	r24, 0x55	; 85
 29a:	19 f4       	brne	.+6      	; 0x2a2 <CreateKeyboardReport+0x3a>
                    ReportData->Modifier |= KEYBOARD_MODIFER_LEFTALT;
 29c:	80 81       	ld	r24, Z
 29e:	84 60       	ori	r24, 0x04	; 4
 2a0:	80 83       	st	Z, r24
                if(scancode_buffer[0xe3] == 0x55)
 2a2:	80 91 e7 01 	lds	r24, 0x01E7	; 0x8001e7 <__data_end+0xe3>
 2a6:	85 35       	cpi	r24, 0x55	; 85
 2a8:	19 f4       	brne	.+6      	; 0x2b0 <CreateKeyboardReport+0x48>
                    ReportData->Modifier |= KEYBOARD_MODIFER_LEFTGUI;
 2aa:	80 81       	ld	r24, Z
 2ac:	88 60       	ori	r24, 0x08	; 8
 2ae:	80 83       	st	Z, r24
                if(scancode_buffer[0xe4] == 0x55)
 2b0:	80 91 e8 01 	lds	r24, 0x01E8	; 0x8001e8 <__data_end+0xe4>
 2b4:	85 35       	cpi	r24, 0x55	; 85
 2b6:	19 f4       	brne	.+6      	; 0x2be <CreateKeyboardReport+0x56>
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTCTRL;
 2b8:	80 81       	ld	r24, Z
 2ba:	80 61       	ori	r24, 0x10	; 16
 2bc:	80 83       	st	Z, r24
                if(scancode_buffer[0xe5] == 0x55)
 2be:	80 91 e9 01 	lds	r24, 0x01E9	; 0x8001e9 <__data_end+0xe5>
 2c2:	85 35       	cpi	r24, 0x55	; 85
 2c4:	19 f4       	brne	.+6      	; 0x2cc <CreateKeyboardReport+0x64>
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTSHIFT;
 2c6:	80 81       	ld	r24, Z
 2c8:	80 62       	ori	r24, 0x20	; 32
 2ca:	80 83       	st	Z, r24
                if(scancode_buffer[0xe6] == 0x55)
 2cc:	80 91 ea 01 	lds	r24, 0x01EA	; 0x8001ea <__data_end+0xe6>
 2d0:	85 35       	cpi	r24, 0x55	; 85
 2d2:	19 f4       	brne	.+6      	; 0x2da <CreateKeyboardReport+0x72>
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTALT;
 2d4:	80 81       	ld	r24, Z
 2d6:	80 64       	ori	r24, 0x40	; 64
 2d8:	80 83       	st	Z, r24
                if(scancode_buffer[0xe7] == 0x55)
 2da:	80 91 eb 01 	lds	r24, 0x01EB	; 0x8001eb <__data_end+0xe7>
 2de:	85 35       	cpi	r24, 0x55	; 85
 2e0:	19 f4       	brne	.+6      	; 0x2e8 <CreateKeyboardReport+0x80>
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTGUI;
 2e2:	80 81       	ld	r24, Z
 2e4:	80 68       	ori	r24, 0x80	; 128
 2e6:	80 83       	st	Z, r24
 2e8:	a4 e0       	ldi	r26, 0x04	; 4
 2ea:	b1 e0       	ldi	r27, 0x01	; 1
/** Fills the given HID report data structure with the next HID report to send to the host.
 *
 *  \param[out] ReportData  Pointer to a HID report data structure to be filled
 */
void CreateKeyboardReport(USB_KeyboardReport_Data_t* const ReportData)
{
 2ec:	80 e0       	ldi	r24, 0x00	; 0
 2ee:	90 e0       	ldi	r25, 0x00	; 0
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTALT;
                if(scancode_buffer[0xe7] == 0x55)
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTGUI;

                for(uint8_t UsedKeyCodes = 0, i=0; UsedKeyCodes < 6 && i < 128; i++) {
                    if(scancode_buffer[i] == 0x55)
 2f0:	2d 91       	ld	r18, X+
 2f2:	25 35       	cpi	r18, 0x55	; 85
 2f4:	29 f4       	brne	.+10     	; 0x300 <__stack+0x1>
                        ReportData->KeyCode[UsedKeyCodes++] = i;
 2f6:	ef 01       	movw	r28, r30
 2f8:	c9 0f       	add	r28, r25
 2fa:	d1 1d       	adc	r29, r1
 2fc:	8a 83       	std	Y+2, r24	; 0x02
 2fe:	9f 5f       	subi	r25, 0xFF	; 255
                if(scancode_buffer[0xe6] == 0x55)
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTALT;
                if(scancode_buffer[0xe7] == 0x55)
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTGUI;

                for(uint8_t UsedKeyCodes = 0, i=0; UsedKeyCodes < 6 && i < 128; i++) {
 300:	8f 5f       	subi	r24, 0xFF	; 255
 302:	96 30       	cpi	r25, 0x06	; 6
 304:	19 f4       	brne	.+6      	; 0x30c <__stack+0xd>
                    if(scancode_buffer[i] == 0x55)
                        ReportData->KeyCode[UsedKeyCodes++] = i;
    }

}
 306:	df 91       	pop	r29
 308:	cf 91       	pop	r28
 30a:	08 95       	ret
                if(scancode_buffer[0xe6] == 0x55)
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTALT;
                if(scancode_buffer[0xe7] == 0x55)
                    ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTGUI;

                for(uint8_t UsedKeyCodes = 0, i=0; UsedKeyCodes < 6 && i < 128; i++) {
 30c:	80 38       	cpi	r24, 0x80	; 128
 30e:	81 f7       	brne	.-32     	; 0x2f0 <CreateKeyboardReport+0x88>
 310:	fa cf       	rjmp	.-12     	; 0x306 <__stack+0x7>

00000312 <ProcessLEDReport>:
 */
void ProcessLEDReport(const uint8_t LEDReport)
{
	uint8_t LEDMask = LEDS_LED2;

	if (LEDReport & KEYBOARD_LED_NUMLOCK)
 312:	80 ff       	sbrs	r24, 0
 314:	02 c0       	rjmp	.+4      	; 0x31a <ProcessLEDReport+0x8>
	  LEDMask |= LEDS_LED1;
 316:	80 e3       	ldi	r24, 0x30	; 48

	if (LEDReport & KEYBOARD_LED_SCROLLLOCK)
	  LEDMask |= LEDS_LED4;

	/* Set the status LEDs to the current Keyboard LED status */
	LEDs_SetAllLEDs(LEDMask);
 318:	29 cf       	rjmp	.-430    	; 0x16c <LEDs_SetAllLEDs>
 *
 *  \param[in] LEDReport  LED status report from the host
 */
void ProcessLEDReport(const uint8_t LEDReport)
{
	uint8_t LEDMask = LEDS_LED2;
 31a:	80 e1       	ldi	r24, 0x10	; 16
 31c:	fd cf       	rjmp	.-6      	; 0x318 <ProcessLEDReport+0x6>

0000031e <EVENT_USB_Device_UnhandledControlRequest>:
	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
}

/** Event handler for the library USB Unhandled Control Request event. */
void EVENT_USB_Device_UnhandledControlRequest(void)
{
 31e:	1f 93       	push	r17
 320:	cf 93       	push	r28
 322:	df 93       	push	r29
 324:	cd b7       	in	r28, 0x3d	; 61
 326:	de b7       	in	r29, 0x3e	; 62
 328:	28 97       	sbiw	r28, 0x08	; 8
 32a:	0f b6       	in	r0, 0x3f	; 63
 32c:	f8 94       	cli
 32e:	de bf       	out	0x3e, r29	; 62
 330:	0f be       	out	0x3f, r0	; 63
 332:	cd bf       	out	0x3d, r28	; 61
	// CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);


	/* Handle HID Class specific requests */
	switch (USB_ControlRequest.bRequest)
 334:	80 91 9b 02 	lds	r24, 0x029B	; 0x80029b <USB_ControlRequest+0x1>
 338:	83 30       	cpi	r24, 0x03	; 3
 33a:	09 f4       	brne	.+2      	; 0x33e <EVENT_USB_Device_UnhandledControlRequest+0x20>
 33c:	4b c0       	rjmp	.+150    	; 0x3d4 <EVENT_USB_Device_UnhandledControlRequest+0xb6>
 33e:	78 f4       	brcc	.+30     	; 0x35e <EVENT_USB_Device_UnhandledControlRequest+0x40>
 340:	81 30       	cpi	r24, 0x01	; 1
 342:	69 f1       	breq	.+90     	; 0x39e <EVENT_USB_Device_UnhandledControlRequest+0x80>
 344:	82 30       	cpi	r24, 0x02	; 2
 346:	09 f4       	brne	.+2      	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
 348:	8b c0       	rjmp	.+278    	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
				Endpoint_ClearStatusStage();
			}

			break;
	}
}
 34a:	28 96       	adiw	r28, 0x08	; 8
 34c:	0f b6       	in	r0, 0x3f	; 63
 34e:	f8 94       	cli
 350:	de bf       	out	0x3e, r29	; 62
 352:	0f be       	out	0x3f, r0	; 63
 354:	cd bf       	out	0x3d, r28	; 61
 356:	df 91       	pop	r29
 358:	cf 91       	pop	r28
 35a:	1f 91       	pop	r17
 35c:	08 95       	ret
{
	// CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);


	/* Handle HID Class specific requests */
	switch (USB_ControlRequest.bRequest)
 35e:	8a 30       	cpi	r24, 0x0A	; 10
 360:	09 f4       	brne	.+2      	; 0x364 <EVENT_USB_Device_UnhandledControlRequest+0x46>
 362:	63 c0       	rjmp	.+198    	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 364:	8b 30       	cpi	r24, 0x0B	; 11
 366:	09 f4       	brne	.+2      	; 0x36a <EVENT_USB_Device_UnhandledControlRequest+0x4c>
 368:	4a c0       	rjmp	.+148    	; 0x3fe <EVENT_USB_Device_UnhandledControlRequest+0xe0>
 36a:	89 30       	cpi	r24, 0x09	; 9
 36c:	71 f7       	brne	.-36     	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
				Endpoint_ClearOUT();
			}

			break;
		case REQ_SetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
 36e:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 372:	81 32       	cpi	r24, 0x21	; 33
 374:	51 f7       	brne	.-44     	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 376:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 37a:	87 7f       	andi	r24, 0xF7	; 247
 37c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 380:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			{
				Endpoint_ClearSETUP();

				/* Wait until the LED report has been sent by the host */
				while (!(Endpoint_IsOUTReceived()))
 384:	82 ff       	sbrs	r24, 2
 386:	22 c0       	rjmp	.+68     	; 0x3cc <EVENT_USB_Device_UnhandledControlRequest+0xae>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 388:	10 91 f1 00 	lds	r17, 0x00F1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 38c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 390:	8b 77       	andi	r24, 0x7B	; 123
 392:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

				/* Read in the LED report from the host */
				uint8_t LEDStatus = Endpoint_Read_Byte();

				Endpoint_ClearOUT();
				Endpoint_ClearStatusStage();
 396:	bd d1       	rcall	.+890    	; 0x712 <Endpoint_ClearStatusStage>

				/* Process the incoming LED report */
				ProcessLEDReport(LEDStatus);
 398:	81 2f       	mov	r24, r17
 39a:	bb df       	rcall	.-138    	; 0x312 <ProcessLEDReport>
 39c:	d6 cf       	rjmp	.-84     	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>

	/* Handle HID Class specific requests */
	switch (USB_ControlRequest.bRequest)
	{
		case REQ_GetReport:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
 39e:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 3a2:	81 3a       	cpi	r24, 0xA1	; 161
 3a4:	91 f6       	brne	.-92     	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
			{
				USB_KeyboardReport_Data_t KeyboardReportData;

				/* Create the next keyboard report for transmission to the host */
				CreateKeyboardReport(&KeyboardReportData);
 3a6:	ce 01       	movw	r24, r28
 3a8:	01 96       	adiw	r24, 0x01	; 1
 3aa:	5e df       	rcall	.-324    	; 0x268 <CreateKeyboardReport>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 3ac:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 3b0:	87 7f       	andi	r24, 0xF7	; 247
 3b2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

				Endpoint_ClearSETUP();

				/* Write the report data to the control endpoint */
				Endpoint_Write_Control_Stream_LE(&KeyboardReportData, sizeof(KeyboardReportData));
 3b6:	68 e0       	ldi	r22, 0x08	; 8
 3b8:	70 e0       	ldi	r23, 0x00	; 0
 3ba:	ce 01       	movw	r24, r28
 3bc:	01 96       	adiw	r24, 0x01	; 1
 3be:	2c d2       	rcall	.+1112   	; 0x818 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 3c0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 3c4:	8b 77       	andi	r24, 0x7B	; 123
 3c6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 3ca:	bf cf       	rjmp	.-130    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
				Endpoint_ClearSETUP();

				/* Wait until the LED report has been sent by the host */
				while (!(Endpoint_IsOUTReceived()))
				{
					if (USB_DeviceState == DEVICE_STATE_Unattached)
 3cc:	8e b3       	in	r24, 0x1e	; 30
 3ce:	81 11       	cpse	r24, r1
 3d0:	d7 cf       	rjmp	.-82     	; 0x380 <EVENT_USB_Device_UnhandledControlRequest+0x62>
 3d2:	bb cf       	rjmp	.-138    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
				ProcessLEDReport(LEDStatus);
			}

			break;
		case REQ_GetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
 3d4:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 3d8:	81 3a       	cpi	r24, 0xA1	; 161
 3da:	09 f0       	breq	.+2      	; 0x3de <EVENT_USB_Device_UnhandledControlRequest+0xc0>
 3dc:	b6 cf       	rjmp	.-148    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 3de:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 3e2:	87 7f       	andi	r24, 0xF7	; 247
 3e4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			{
				Endpoint_ClearSETUP();

				/* Write the current protocol flag to the host */
				Endpoint_Write_Byte(UsingReportProtocol);
 3e8:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <UsingReportProtocol>
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 3ec:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 3f0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 3f4:	8e 77       	andi	r24, 0x7E	; 126
 3f6:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

				/* Write the current idle duration to the host, must be divided by 4 before sent to host */
				Endpoint_Write_Byte(IdleCount >> 2);

				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
 3fa:	8b d1       	rcall	.+790    	; 0x712 <Endpoint_ClearStatusStage>
 3fc:	a6 cf       	rjmp	.-180    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
				Endpoint_ClearStatusStage();
			}

			break;
		case REQ_SetProtocol:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
 3fe:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 402:	81 32       	cpi	r24, 0x21	; 33
 404:	09 f0       	breq	.+2      	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
 406:	a1 cf       	rjmp	.-190    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 408:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 40c:	87 7f       	andi	r24, 0xF7	; 247
 40e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
 412:	7f d1       	rcall	.+766    	; 0x712 <Endpoint_ClearStatusStage>

				/* Set or clear the flag depending on what the host indicates that the current Protocol should be */
				UsingReportProtocol = (USB_ControlRequest.wValue != 0);
 414:	81 e0       	ldi	r24, 0x01	; 1
 416:	20 91 9c 02 	lds	r18, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 41a:	30 91 9d 02 	lds	r19, 0x029D	; 0x80029d <USB_ControlRequest+0x3>
 41e:	23 2b       	or	r18, r19
 420:	09 f4       	brne	.+2      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
 422:	80 e0       	ldi	r24, 0x00	; 0
 424:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <UsingReportProtocol>
 428:	90 cf       	rjmp	.-224    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
			}

			break;
		case REQ_SetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
 42a:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 42e:	81 32       	cpi	r24, 0x21	; 33
 430:	09 f0       	breq	.+2      	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
 432:	8b cf       	rjmp	.-234    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
 434:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 438:	87 7f       	andi	r24, 0xF7	; 247
 43a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
 43e:	69 d1       	rcall	.+722    	; 0x712 <Endpoint_ClearStatusStage>

				/* Get idle period in MSB, IdleCount must be multiplied by 4 to get number of milliseconds */
				IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
 440:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 444:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <USB_ControlRequest+0x3>
 448:	36 e0       	ldi	r19, 0x06	; 6
 44a:	96 95       	lsr	r25
 44c:	87 95       	ror	r24
 44e:	3a 95       	dec	r19
 450:	e1 f7       	brne	.-8      	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
 452:	8c 7f       	andi	r24, 0xFC	; 252
 454:	93 70       	andi	r25, 0x03	; 3
 456:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <IdleCount+0x1>
 45a:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <IdleCount>
 45e:	75 cf       	rjmp	.-278    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
			}

			break;
		case REQ_GetIdle:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
 460:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 464:	81 3a       	cpi	r24, 0xA1	; 161
 466:	09 f0       	breq	.+2      	; 0x46a <__LOCK_REGION_LENGTH__+0x6a>
 468:	70 cf       	rjmp	.-288    	; 0x34a <EVENT_USB_Device_UnhandledControlRequest+0x2c>
 46a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 46e:	87 7f       	andi	r24, 0xF7	; 247
 470:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			{
				Endpoint_ClearSETUP();

				/* Write the current idle duration to the host, must be divided by 4 before sent to host */
				Endpoint_Write_Byte(IdleCount >> 2);
 474:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <IdleCount>
 478:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <IdleCount+0x1>
 47c:	96 95       	lsr	r25
 47e:	87 95       	ror	r24
 480:	96 95       	lsr	r25
 482:	87 95       	ror	r24
 484:	b3 cf       	rjmp	.-154    	; 0x3ec <EVENT_USB_Device_UnhandledControlRequest+0xce>

00000486 <SendNextReport>:
	LEDs_SetAllLEDs(LEDMask);
}

/** Sends the next HID report to the host, via the keyboard data endpoint. */
void SendNextReport(void)
{
 486:	cf 93       	push	r28
 488:	df 93       	push	r29
 48a:	cd b7       	in	r28, 0x3d	; 61
 48c:	de b7       	in	r29, 0x3e	; 62
 48e:	28 97       	sbiw	r28, 0x08	; 8
 490:	0f b6       	in	r0, 0x3f	; 63
 492:	f8 94       	cli
 494:	de bf       	out	0x3e, r29	; 62
 496:	0f be       	out	0x3f, r0	; 63
 498:	cd bf       	out	0x3d, r28	; 61
	static USB_KeyboardReport_Data_t PrevKeyboardReportData;
	USB_KeyboardReport_Data_t        KeyboardReportData;
	bool                             SendReport = true;

	/* Create the next keyboard report for transmission to the host */
	CreateKeyboardReport(&KeyboardReportData);
 49a:	ce 01       	movw	r24, r28
 49c:	01 96       	adiw	r24, 0x01	; 1
 49e:	e4 de       	rcall	.-568    	; 0x268 <CreateKeyboardReport>

	/* Check to see if the report data has changed - if so a report MUST be sent */
	SendReport = (memcmp(&PrevKeyboardReportData, &KeyboardReportData, sizeof(USB_KeyboardReport_Data_t)) != 0);
 4a0:	48 e0       	ldi	r20, 0x08	; 8
 4a2:	50 e0       	ldi	r21, 0x00	; 0
 4a4:	be 01       	movw	r22, r28
 4a6:	6f 5f       	subi	r22, 0xFF	; 255
 4a8:	7f 4f       	sbci	r23, 0xFF	; 255
 4aa:	86 e0       	ldi	r24, 0x06	; 6
 4ac:	92 e0       	ldi	r25, 0x02	; 2
 4ae:	e7 d4       	rcall	.+2510   	; 0xe7e <memcmp>
 4b0:	21 e0       	ldi	r18, 0x01	; 1
 4b2:	89 2b       	or	r24, r25
 4b4:	09 f4       	brne	.+2      	; 0x4b8 <SendNextReport+0x32>
 4b6:	20 e0       	ldi	r18, 0x00	; 0

	/* Check if the idle period is set and has elapsed */
	if ((IdleCount != HID_IDLE_CHANGESONLY) && (!(IdleMSRemaining)))
 4b8:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <IdleCount>
 4bc:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <IdleCount+0x1>
 4c0:	00 97       	sbiw	r24, 0x00	; 0
 4c2:	59 f0       	breq	.+22     	; 0x4da <SendNextReport+0x54>
 4c4:	40 91 04 02 	lds	r20, 0x0204	; 0x800204 <IdleMSRemaining>
 4c8:	50 91 05 02 	lds	r21, 0x0205	; 0x800205 <IdleMSRemaining+0x1>
 4cc:	45 2b       	or	r20, r21
 4ce:	29 f4       	brne	.+10     	; 0x4da <SendNextReport+0x54>
	{
		/* Reset the idle time remaining counter */
		IdleMSRemaining = IdleCount;
 4d0:	90 93 05 02 	sts	0x0205, r25	; 0x800205 <IdleMSRemaining+0x1>
 4d4:	80 93 04 02 	sts	0x0204, r24	; 0x800204 <IdleMSRemaining>

		/* Idle period is set and has elapsed, must send a report to the host */
		SendReport = true;
 4d8:	21 e0       	ldi	r18, 0x01	; 1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 4da:	81 e0       	ldi	r24, 0x01	; 1
 4dc:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
 4e0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

	/* Select the Keyboard Report Endpoint */
	Endpoint_SelectEndpoint(KEYBOARD_IN_EPNUM);

	/* Check if Keyboard Endpoint Ready for Read/Write and if we should send a new report */
	if (Endpoint_IsReadWriteAllowed() && SendReport)
 4e4:	85 ff       	sbrs	r24, 5
 4e6:	17 c0       	rjmp	.+46     	; 0x516 <SendNextReport+0x90>
 4e8:	22 23       	and	r18, r18
 4ea:	a9 f0       	breq	.+42     	; 0x516 <SendNextReport+0x90>
	{
		/* Save the current report data for later comparison to check for changes */
		PrevKeyboardReportData = KeyboardReportData;
 4ec:	88 e0       	ldi	r24, 0x08	; 8
 4ee:	fe 01       	movw	r30, r28
 4f0:	31 96       	adiw	r30, 0x01	; 1
 4f2:	a6 e0       	ldi	r26, 0x06	; 6
 4f4:	b2 e0       	ldi	r27, 0x02	; 2
 4f6:	01 90       	ld	r0, Z+
 4f8:	0d 92       	st	X+, r0
 4fa:	8a 95       	dec	r24
 4fc:	e1 f7       	brne	.-8      	; 0x4f6 <SendNextReport+0x70>

		/* Write Keyboard Report Data */
		Endpoint_Write_Stream_LE(&KeyboardReportData, sizeof(KeyboardReportData), NO_STREAM_CALLBACK);
 4fe:	50 e0       	ldi	r21, 0x00	; 0
 500:	40 e0       	ldi	r20, 0x00	; 0
 502:	68 e0       	ldi	r22, 0x08	; 8
 504:	70 e0       	ldi	r23, 0x00	; 0
 506:	ce 01       	movw	r24, r28
 508:	01 96       	adiw	r24, 0x01	; 1
 50a:	4c d1       	rcall	.+664    	; 0x7a4 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 50c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 510:	8e 77       	andi	r24, 0x7E	; 126
 512:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

		/* Finalize the stream transfer to send the last packet */
		Endpoint_ClearIN();
	}
}
 516:	28 96       	adiw	r28, 0x08	; 8
 518:	0f b6       	in	r0, 0x3f	; 63
 51a:	f8 94       	cli
 51c:	de bf       	out	0x3e, r29	; 62
 51e:	0f be       	out	0x3f, r0	; 63
 520:	cd bf       	out	0x3d, r28	; 61
 522:	df 91       	pop	r29
 524:	cf 91       	pop	r28
 526:	08 95       	ret

00000528 <ReceiveNextReport>:
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 528:	82 e0       	ldi	r24, 0x02	; 2
 52a:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 52e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
{
	/* Select the Keyboard LED Report Endpoint */
	Endpoint_SelectEndpoint(KEYBOARD_OUT_EPNUM);

	/* Check if Keyboard LED Endpoint contains a packet */
	if (Endpoint_IsOUTReceived())
 532:	82 ff       	sbrs	r24, 2
 534:	0c c0       	rjmp	.+24     	; 0x54e <ReceiveNextReport+0x26>
			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depending on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
 536:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	{
		/* Check to see if the packet contains data */
		if (Endpoint_IsReadWriteAllowed())
 53a:	85 ff       	sbrs	r24, 5
 53c:	03 c0       	rjmp	.+6      	; 0x544 <ReceiveNextReport+0x1c>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 53e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
		{
			/* Read in the LED report from the host */
			uint8_t LEDReport = Endpoint_Read_Byte();

			/* Process the read LED report from the host */
			ProcessLEDReport(LEDReport);
 542:	e7 de       	rcall	.-562    	; 0x312 <ProcessLEDReport>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 544:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 548:	8b 77       	andi	r24, 0x7B	; 123
 54a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
		}

		/* Handshake the OUT Endpoint - clear endpoint and ready for next report */
		Endpoint_ClearOUT();
	}
}
 54e:	08 95       	ret

00000550 <HID_Task>:

/** Function to manage HID report generation and transmission to the host, when in report mode. */
void HID_Task(void)
{
	/* Device must be connected and configured for the task to run */
	if (USB_DeviceState != DEVICE_STATE_Configured)
 550:	8e b3       	in	r24, 0x1e	; 30
 552:	84 30       	cpi	r24, 0x04	; 4
 554:	11 f4       	brne	.+4      	; 0x55a <HID_Task+0xa>
	  return;

	/* Send the next keypress report to the host */
	SendNextReport();
 556:	97 df       	rcall	.-210    	; 0x486 <SendNextReport>

	/* Process the LED report sent from the host */
	ReceiveNextReport();
 558:	e7 cf       	rjmp	.-50     	; 0x528 <ReceiveNextReport>
 55a:	08 95       	ret

0000055c <main>:
}
 55c:	2a de       	rcall	.-940    	; 0x1b2 <SetupHardware>
		 *
		 *  \param[out] Buffer  Pointer to a ring buffer structure to initialize
		 */
		static inline void RingBuffer_InitBuffer(RingBuff_t* const Buffer)
		{
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 55e:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 560:	f8 94       	cli
			{
				Buffer->In  = Buffer->Buffer;
 562:	81 e1       	ldi	r24, 0x11	; 17
 564:	92 e0       	ldi	r25, 0x02	; 2
 566:	90 93 92 02 	sts	0x0292, r25	; 0x800292 <USARTtoUSB_Buffer+0x81>
 56a:	80 93 91 02 	sts	0x0291, r24	; 0x800291 <USARTtoUSB_Buffer+0x80>
				Buffer->Out = Buffer->Buffer;
 56e:	90 93 94 02 	sts	0x0294, r25	; 0x800294 <USARTtoUSB_Buffer+0x83>
 572:	80 93 93 02 	sts	0x0293, r24	; 0x800293 <USARTtoUSB_Buffer+0x82>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 576:	2f bf       	out	0x3f, r18	; 63
	SetupHardware();
	
	// RingBuffer_InitBuffer(&USBtoUSART_Buffer);
	RingBuffer_InitBuffer(&USARTtoUSB_Buffer);

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
 578:	80 e2       	ldi	r24, 0x20	; 32
 57a:	f8 dd       	rcall	.-1040   	; 0x16c <LEDs_SetAllLEDs>
	sei();
 57c:	78 94       	sei
		 */
		static inline RingBuff_Count_t RingBuffer_GetCount(RingBuff_t* const Buffer)
		{
			RingBuff_Count_t Count;
			
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 57e:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 580:	f8 94       	cli
			{
				Count = Buffer->Count;
 582:	c0 91 95 02 	lds	r28, 0x0295	; 0x800295 <USARTtoUSB_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 586:	8f bf       	out	0x3f, r24	; 63
    RingBuff_Count_t BufferCount = RingBuffer_GetCount(&USARTtoUSB_Buffer);
    
    // if ((TIFR0 & (1 << TOV0)) || (BufferCount > BUFFER_NEARLY_FULL))
    // {
    //         TIFR0 |= (1 << TOV0);
    if (BufferCount > BUFFER_NEARLY_FULL) {
 588:	c1 36       	cpi	r28, 0x61	; 97
 58a:	10 f0       	brcs	.+4      	; 0x590 <main+0x34>
        while(BufferCount--)
 58c:	c1 50       	subi	r28, 0x01	; 1
 58e:	28 f4       	brcc	.+10     	; 0x59a <main+0x3e>
            header = RingBuffer_Remove(&USARTtoUSB_Buffer);
    }
        while(BufferCount > 2) {
 590:	c3 30       	cpi	r28, 0x03	; 3
                }
            }
        }   
    // }

		HID_Task();
 592:	38 f4       	brcc	.+14     	; 0x5a2 <main+0x46>
		USB_USBTask();
 594:	dd df       	rcall	.-70     	; 0x550 <HID_Task>
 596:	5c d4       	rcall	.+2232   	; 0xe50 <USB_USBTask>

	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	sei();

	for (;;)
	{
 598:	f2 cf       	rjmp	.-28     	; 0x57e <main+0x22>
    // if ((TIFR0 & (1 << TOV0)) || (BufferCount > BUFFER_NEARLY_FULL))
    // {
    //         TIFR0 |= (1 << TOV0);
    if (BufferCount > BUFFER_NEARLY_FULL) {
        while(BufferCount--)
            header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 59a:	ee dd       	rcall	.-1060   	; 0x178 <RingBuffer_Remove.constprop.3>
 59c:	80 93 10 02 	sts	0x0210, r24	; 0x800210 <header>
 5a0:	f5 cf       	rjmp	.-22     	; 0x58c <main+0x30>
    }
        while(BufferCount > 2) {
            if (BufferCount--) {
 5a2:	df ef       	ldi	r29, 0xFF	; 255
 5a4:	dc 0f       	add	r29, r28
                header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 5a6:	e8 dd       	rcall	.-1072   	; 0x178 <RingBuffer_Remove.constprop.3>
 5a8:	80 93 10 02 	sts	0x0210, r24	; 0x800210 <header>
                if(header == 0x00) {
 5ac:	81 11       	cpse	r24, r1
                    if (BufferCount--) {
                        scancode = RingBuffer_Remove(&USARTtoUSB_Buffer);
 5ae:	0e c0       	rjmp	.+28     	; 0x5cc <main+0x70>
 5b0:	e3 dd       	rcall	.-1082   	; 0x178 <RingBuffer_Remove.constprop.3>
 5b2:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <scancode>
                    }
                    if (BufferCount--) {
 5b6:	c3 50       	subi	r28, 0x03	; 3
                        press_release = RingBuffer_Remove(&USARTtoUSB_Buffer);
 5b8:	df dd       	rcall	.-1090   	; 0x178 <RingBuffer_Remove.constprop.3>
 5ba:	80 93 0e 02 	sts	0x020E, r24	; 0x80020e <press_release>
 5be:	e0 91 0f 02 	lds	r30, 0x020F	; 0x80020f <scancode>
                    }
                    scancode_buffer[scancode] = press_release;
 5c2:	f0 e0       	ldi	r31, 0x00	; 0
 5c4:	ec 5f       	subi	r30, 0xFC	; 252
 5c6:	fe 4f       	sbci	r31, 0xFE	; 254
 5c8:	80 83       	st	Z, r24
 5ca:	e2 cf       	rjmp	.-60     	; 0x590 <main+0x34>
 5cc:	cd 2f       	mov	r28, r29
    if (BufferCount > BUFFER_NEARLY_FULL) {
        while(BufferCount--)
            header = RingBuffer_Remove(&USARTtoUSB_Buffer);
    }
        while(BufferCount > 2) {
            if (BufferCount--) {
 5ce:	e0 cf       	rjmp	.-64     	; 0x590 <main+0x34>

000005d0 <__vector_23>:
 5d0:	1f 92       	push	r1

/** ISR to manage the reception of data from the serial port, placing received bytes into a circular buffer
 *  for later transmission to the host.
 */
ISR(USART1_RX_vect, ISR_BLOCK)
{
 5d2:	0f 92       	push	r0
 5d4:	0f b6       	in	r0, 0x3f	; 63
 5d6:	0f 92       	push	r0
 5d8:	11 24       	eor	r1, r1
 5da:	2f 93       	push	r18
 5dc:	8f 93       	push	r24
 5de:	9f 93       	push	r25
 5e0:	ef 93       	push	r30
 5e2:	ff 93       	push	r31
	uint8_t ReceivedByte = UDR1;
 5e4:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__EEPROM_REGION_LENGTH__+0x7f00ce>

	if (USB_DeviceState == DEVICE_STATE_Configured)
 5e8:	9e b3       	in	r25, 0x1e	; 30
 5ea:	94 30       	cpi	r25, 0x04	; 4
 5ec:	d9 f4       	brne	.+54     	; 0x624 <__vector_23+0x54>
		 *  \param[in]     Data    Data element to insert into the buffer
		 */
		static inline void RingBuffer_Insert(RingBuff_t* const Buffer,
		                                     const RingBuff_Data_t Data)
		{
			*Buffer->In = Data;
 5ee:	e0 91 91 02 	lds	r30, 0x0291	; 0x800291 <USARTtoUSB_Buffer+0x80>
 5f2:	f0 91 92 02 	lds	r31, 0x0292	; 0x800292 <USARTtoUSB_Buffer+0x81>
 5f6:	80 83       	st	Z, r24
			
			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
 5f8:	e0 91 91 02 	lds	r30, 0x0291	; 0x800291 <USARTtoUSB_Buffer+0x80>
 5fc:	f0 91 92 02 	lds	r31, 0x0292	; 0x800292 <USARTtoUSB_Buffer+0x81>
 600:	cf 01       	movw	r24, r30
 602:	01 96       	adiw	r24, 0x01	; 1
 604:	22 e0       	ldi	r18, 0x02	; 2
 606:	81 39       	cpi	r24, 0x91	; 145
 608:	92 07       	cpc	r25, r18
 60a:	b1 f0       	breq	.+44     	; 0x638 <__vector_23+0x68>
 60c:	90 93 92 02 	sts	0x0292, r25	; 0x800292 <USARTtoUSB_Buffer+0x81>
 610:	80 93 91 02 	sts	0x0291, r24	; 0x800291 <USARTtoUSB_Buffer+0x80>
			  Buffer->In = Buffer->Buffer;

			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 614:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 616:	f8 94       	cli
			{
				Buffer->Count++;
 618:	80 91 95 02 	lds	r24, 0x0295	; 0x800295 <USARTtoUSB_Buffer+0x84>
 61c:	8f 5f       	subi	r24, 0xFF	; 255
 61e:	80 93 95 02 	sts	0x0295, r24	; 0x800295 <USARTtoUSB_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 622:	9f bf       	out	0x3f, r25	; 63
	  RingBuffer_Insert(&USARTtoUSB_Buffer, ReceivedByte);
}
 624:	ff 91       	pop	r31
 626:	ef 91       	pop	r30
 628:	9f 91       	pop	r25
 62a:	8f 91       	pop	r24
 62c:	2f 91       	pop	r18
 62e:	0f 90       	pop	r0
 630:	0f be       	out	0x3f, r0	; 63
 632:	0f 90       	pop	r0
 634:	1f 90       	pop	r1
 636:	18 95       	reti
		                                     const RingBuff_Data_t Data)
		{
			*Buffer->In = Data;
			
			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
			  Buffer->In = Buffer->Buffer;
 638:	81 e1       	ldi	r24, 0x11	; 17
 63a:	92 e0       	ldi	r25, 0x02	; 2
 63c:	92 83       	std	Z+2, r25	; 0x02
 63e:	81 83       	std	Z+1, r24	; 0x01
 640:	e9 cf       	rjmp	.-46     	; 0x614 <__vector_23+0x44>

00000642 <CALLBACK_USB_GetDescriptor>:
 642:	29 2f       	mov	r18, r25
 644:	33 27       	eor	r19, r19
 646:	23 30       	cpi	r18, 0x03	; 3
 648:	31 05       	cpc	r19, r1
 64a:	21 f1       	breq	.+72     	; 0x694 <CALLBACK_USB_GetDescriptor+0x52>
 64c:	58 f4       	brcc	.+22     	; 0x664 <CALLBACK_USB_GetDescriptor+0x22>
 64e:	21 30       	cpi	r18, 0x01	; 1
 650:	31 05       	cpc	r19, r1
 652:	99 f0       	breq	.+38     	; 0x67a <CALLBACK_USB_GetDescriptor+0x38>
 654:	22 30       	cpi	r18, 0x02	; 2
 656:	31 05       	cpc	r19, r1
 658:	c1 f0       	breq	.+48     	; 0x68a <CALLBACK_USB_GetDescriptor+0x48>
 65a:	90 e0       	ldi	r25, 0x00	; 0
 65c:	80 e0       	ldi	r24, 0x00	; 0
 65e:	30 e0       	ldi	r19, 0x00	; 0
 660:	20 e0       	ldi	r18, 0x00	; 0
 662:	0f c0       	rjmp	.+30     	; 0x682 <CALLBACK_USB_GetDescriptor+0x40>
 664:	21 32       	cpi	r18, 0x21	; 33
 666:	31 05       	cpc	r19, r1
 668:	41 f1       	breq	.+80     	; 0x6ba <CALLBACK_USB_GetDescriptor+0x78>
 66a:	22 32       	cpi	r18, 0x22	; 34
 66c:	31 05       	cpc	r19, r1
 66e:	a9 f7       	brne	.-22     	; 0x65a <CALLBACK_USB_GetDescriptor+0x18>
 670:	8f e3       	ldi	r24, 0x3F	; 63
 672:	90 e0       	ldi	r25, 0x00	; 0
 674:	25 ef       	ldi	r18, 0xF5	; 245
 676:	30 e0       	ldi	r19, 0x00	; 0
 678:	04 c0       	rjmp	.+8      	; 0x682 <CALLBACK_USB_GetDescriptor+0x40>
 67a:	82 e1       	ldi	r24, 0x12	; 18
 67c:	90 e0       	ldi	r25, 0x00	; 0
 67e:	23 ee       	ldi	r18, 0xE3	; 227
 680:	30 e0       	ldi	r19, 0x00	; 0
 682:	fa 01       	movw	r30, r20
 684:	31 83       	std	Z+1, r19	; 0x01
 686:	20 83       	st	Z, r18
 688:	08 95       	ret
 68a:	89 e2       	ldi	r24, 0x29	; 41
 68c:	90 e0       	ldi	r25, 0x00	; 0
 68e:	2a eb       	ldi	r18, 0xBA	; 186
 690:	30 e0       	ldi	r19, 0x00	; 0
 692:	f7 cf       	rjmp	.-18     	; 0x682 <CALLBACK_USB_GetDescriptor+0x40>
 694:	99 27       	eor	r25, r25
 696:	81 30       	cpi	r24, 0x01	; 1
 698:	91 05       	cpc	r25, r1
 69a:	61 f0       	breq	.+24     	; 0x6b4 <CALLBACK_USB_GetDescriptor+0x72>
 69c:	28 f0       	brcs	.+10     	; 0x6a8 <CALLBACK_USB_GetDescriptor+0x66>
 69e:	02 97       	sbiw	r24, 0x02	; 2
 6a0:	e1 f6       	brne	.-72     	; 0x65a <CALLBACK_USB_GetDescriptor+0x18>
 6a2:	e4 e7       	ldi	r30, 0x74	; 116
 6a4:	f0 e0       	ldi	r31, 0x00	; 0
 6a6:	02 c0       	rjmp	.+4      	; 0x6ac <CALLBACK_USB_GetDescriptor+0x6a>
 6a8:	e6 eb       	ldi	r30, 0xB6	; 182
 6aa:	f0 e0       	ldi	r31, 0x00	; 0
 6ac:	84 91       	lpm	r24, Z
 6ae:	90 e0       	ldi	r25, 0x00	; 0
 6b0:	9f 01       	movw	r18, r30
 6b2:	e7 cf       	rjmp	.-50     	; 0x682 <CALLBACK_USB_GetDescriptor+0x40>
 6b4:	ec e9       	ldi	r30, 0x9C	; 156
 6b6:	f0 e0       	ldi	r31, 0x00	; 0
 6b8:	f9 cf       	rjmp	.-14     	; 0x6ac <CALLBACK_USB_GetDescriptor+0x6a>
 6ba:	89 e0       	ldi	r24, 0x09	; 9
 6bc:	90 e0       	ldi	r25, 0x00	; 0
 6be:	2c ec       	ldi	r18, 0xCC	; 204
 6c0:	30 e0       	ldi	r19, 0x00	; 0
 6c2:	df cf       	rjmp	.-66     	; 0x682 <CALLBACK_USB_GetDescriptor+0x40>

000006c4 <Endpoint_ConfigureEndpoint_Prv>:
 6c4:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 6c8:	eb ee       	ldi	r30, 0xEB	; 235
 6ca:	f0 e0       	ldi	r31, 0x00	; 0
 6cc:	80 81       	ld	r24, Z
 6ce:	81 60       	ori	r24, 0x01	; 1
 6d0:	80 83       	st	Z, r24
 6d2:	ed ee       	ldi	r30, 0xED	; 237
 6d4:	f0 e0       	ldi	r31, 0x00	; 0
 6d6:	10 82       	st	Z, r1
 6d8:	60 93 ec 00 	sts	0x00EC, r22	; 0x8000ec <__EEPROM_REGION_LENGTH__+0x7f00ec>
 6dc:	40 83       	st	Z, r20
 6de:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__EEPROM_REGION_LENGTH__+0x7f00ee>
 6e2:	88 1f       	adc	r24, r24
 6e4:	88 27       	eor	r24, r24
 6e6:	88 1f       	adc	r24, r24
 6e8:	08 95       	ret

000006ea <Endpoint_ClearEndpoints>:
 6ea:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__EEPROM_REGION_LENGTH__+0x7f00f4>
 6ee:	80 e0       	ldi	r24, 0x00	; 0
 6f0:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 6f4:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__EEPROM_REGION_LENGTH__+0x7f00f0>
 6f8:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 6fc:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__EEPROM_REGION_LENGTH__+0x7f00ed>
 700:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 704:	9e 7f       	andi	r25, 0xFE	; 254
 706:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 70a:	8f 5f       	subi	r24, 0xFF	; 255
 70c:	85 30       	cpi	r24, 0x05	; 5
 70e:	81 f7       	brne	.-32     	; 0x6f0 <Endpoint_ClearEndpoints+0x6>
 710:	08 95       	ret

00000712 <Endpoint_ClearStatusStage>:
 712:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 716:	87 ff       	sbrs	r24, 7
 718:	11 c0       	rjmp	.+34     	; 0x73c <Endpoint_ClearStatusStage+0x2a>
 71a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 71e:	82 ff       	sbrs	r24, 2
 720:	06 c0       	rjmp	.+12     	; 0x72e <Endpoint_ClearStatusStage+0x1c>
 722:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 726:	8b 77       	andi	r24, 0x7B	; 123
 728:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 72c:	03 c0       	rjmp	.+6      	; 0x734 <Endpoint_ClearStatusStage+0x22>
 72e:	8e b3       	in	r24, 0x1e	; 30
 730:	81 11       	cpse	r24, r1
 732:	f3 cf       	rjmp	.-26     	; 0x71a <Endpoint_ClearStatusStage+0x8>
 734:	08 95       	ret
 736:	8e b3       	in	r24, 0x1e	; 30
 738:	88 23       	and	r24, r24
 73a:	e1 f3       	breq	.-8      	; 0x734 <Endpoint_ClearStatusStage+0x22>
 73c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 740:	80 ff       	sbrs	r24, 0
 742:	f9 cf       	rjmp	.-14     	; 0x736 <Endpoint_ClearStatusStage+0x24>
 744:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 748:	8e 77       	andi	r24, 0x7E	; 126
 74a:	ee cf       	rjmp	.-36     	; 0x728 <Endpoint_ClearStatusStage+0x16>

0000074c <Endpoint_WaitUntilReady>:
 74c:	85 e6       	ldi	r24, 0x65	; 101
 74e:	90 91 ec 00 	lds	r25, 0x00EC	; 0x8000ec <__EEPROM_REGION_LENGTH__+0x7f00ec>
 752:	90 ff       	sbrs	r25, 0
 754:	06 c0       	rjmp	.+12     	; 0x762 <Endpoint_WaitUntilReady+0x16>
 756:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 75a:	90 ff       	sbrs	r25, 0
 75c:	06 c0       	rjmp	.+12     	; 0x76a <Endpoint_WaitUntilReady+0x1e>
 75e:	80 e0       	ldi	r24, 0x00	; 0
 760:	08 95       	ret
 762:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 766:	92 fd       	sbrc	r25, 2
 768:	fa cf       	rjmp	.-12     	; 0x75e <Endpoint_WaitUntilReady+0x12>
 76a:	9e b3       	in	r25, 0x1e	; 30
 76c:	99 23       	and	r25, r25
 76e:	a1 f0       	breq	.+40     	; 0x798 <Endpoint_WaitUntilReady+0x4c>
 770:	9e b3       	in	r25, 0x1e	; 30
 772:	95 30       	cpi	r25, 0x05	; 5
 774:	99 f0       	breq	.+38     	; 0x79c <Endpoint_WaitUntilReady+0x50>
 776:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 77a:	95 fd       	sbrc	r25, 5
 77c:	11 c0       	rjmp	.+34     	; 0x7a0 <Endpoint_WaitUntilReady+0x54>
 77e:	90 91 e1 00 	lds	r25, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 782:	92 ff       	sbrs	r25, 2
 784:	e4 cf       	rjmp	.-56     	; 0x74e <Endpoint_WaitUntilReady+0x2>
 786:	90 91 e1 00 	lds	r25, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 78a:	9b 7f       	andi	r25, 0xFB	; 251
 78c:	90 93 e1 00 	sts	0x00E1, r25	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 790:	81 50       	subi	r24, 0x01	; 1
 792:	e9 f6       	brne	.-70     	; 0x74e <Endpoint_WaitUntilReady+0x2>
 794:	84 e0       	ldi	r24, 0x04	; 4
 796:	08 95       	ret
 798:	82 e0       	ldi	r24, 0x02	; 2
 79a:	08 95       	ret
 79c:	83 e0       	ldi	r24, 0x03	; 3
 79e:	08 95       	ret
 7a0:	81 e0       	ldi	r24, 0x01	; 1
 7a2:	08 95       	ret

000007a4 <Endpoint_Write_Stream_LE>:
 7a4:	cf 92       	push	r12
 7a6:	df 92       	push	r13
 7a8:	ef 92       	push	r14
 7aa:	ff 92       	push	r15
 7ac:	0f 93       	push	r16
 7ae:	1f 93       	push	r17
 7b0:	cf 93       	push	r28
 7b2:	7c 01       	movw	r14, r24
 7b4:	8b 01       	movw	r16, r22
 7b6:	6a 01       	movw	r12, r20
 7b8:	c9 df       	rcall	.-110    	; 0x74c <Endpoint_WaitUntilReady>
 7ba:	c8 2f       	mov	r28, r24
 7bc:	88 23       	and	r24, r24
 7be:	c1 f0       	breq	.+48     	; 0x7f0 <Endpoint_Write_Stream_LE+0x4c>
 7c0:	8c 2f       	mov	r24, r28
 7c2:	cf 91       	pop	r28
 7c4:	1f 91       	pop	r17
 7c6:	0f 91       	pop	r16
 7c8:	ff 90       	pop	r15
 7ca:	ef 90       	pop	r14
 7cc:	df 90       	pop	r13
 7ce:	cf 90       	pop	r12
 7d0:	08 95       	ret
 7d2:	f6 01       	movw	r30, r12
 7d4:	09 95       	icall
 7d6:	81 30       	cpi	r24, 0x01	; 1
 7d8:	d1 f4       	brne	.+52     	; 0x80e <Endpoint_Write_Stream_LE+0x6a>
 7da:	c5 e0       	ldi	r28, 0x05	; 5
 7dc:	f1 cf       	rjmp	.-30     	; 0x7c0 <Endpoint_Write_Stream_LE+0x1c>
 7de:	f7 01       	movw	r30, r14
 7e0:	80 81       	ld	r24, Z
 7e2:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 7e6:	01 50       	subi	r16, 0x01	; 1
 7e8:	11 09       	sbc	r17, r1
 7ea:	c7 01       	movw	r24, r14
 7ec:	01 96       	adiw	r24, 0x01	; 1
 7ee:	7c 01       	movw	r14, r24
 7f0:	01 15       	cp	r16, r1
 7f2:	11 05       	cpc	r17, r1
 7f4:	29 f3       	breq	.-54     	; 0x7c0 <Endpoint_Write_Stream_LE+0x1c>
 7f6:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 7fa:	85 fd       	sbrc	r24, 5
 7fc:	f0 cf       	rjmp	.-32     	; 0x7de <Endpoint_Write_Stream_LE+0x3a>
 7fe:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 802:	8e 77       	andi	r24, 0x7E	; 126
 804:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 808:	c1 14       	cp	r12, r1
 80a:	d1 04       	cpc	r13, r1
 80c:	11 f7       	brne	.-60     	; 0x7d2 <Endpoint_Write_Stream_LE+0x2e>
 80e:	9e df       	rcall	.-196    	; 0x74c <Endpoint_WaitUntilReady>
 810:	88 23       	and	r24, r24
 812:	71 f3       	breq	.-36     	; 0x7f0 <Endpoint_Write_Stream_LE+0x4c>
 814:	c8 2f       	mov	r28, r24
 816:	d4 cf       	rjmp	.-88     	; 0x7c0 <Endpoint_Write_Stream_LE+0x1c>

00000818 <Endpoint_Write_Control_Stream_LE>:
 818:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <USB_ControlRequest+0x6>
 81c:	30 91 a1 02 	lds	r19, 0x02A1	; 0x8002a1 <USB_ControlRequest+0x7>
 820:	26 17       	cp	r18, r22
 822:	37 07       	cpc	r19, r23
 824:	a0 f0       	brcs	.+40     	; 0x84e <Endpoint_Write_Control_Stream_LE+0x36>
 826:	61 15       	cp	r22, r1
 828:	71 05       	cpc	r23, r1
 82a:	29 f4       	brne	.+10     	; 0x836 <Endpoint_Write_Control_Stream_LE+0x1e>
 82c:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 830:	2e 77       	andi	r18, 0x7E	; 126
 832:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 836:	30 e0       	ldi	r19, 0x00	; 0
 838:	61 15       	cp	r22, r1
 83a:	71 05       	cpc	r23, r1
 83c:	51 f4       	brne	.+20     	; 0x852 <Endpoint_Write_Control_Stream_LE+0x3a>
 83e:	31 11       	cpse	r19, r1
 840:	08 c0       	rjmp	.+16     	; 0x852 <Endpoint_Write_Control_Stream_LE+0x3a>
 842:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 846:	82 ff       	sbrs	r24, 2
 848:	30 c0       	rjmp	.+96     	; 0x8aa <Endpoint_Write_Control_Stream_LE+0x92>
 84a:	80 e0       	ldi	r24, 0x00	; 0
 84c:	08 95       	ret
 84e:	b9 01       	movw	r22, r18
 850:	f2 cf       	rjmp	.-28     	; 0x836 <Endpoint_Write_Control_Stream_LE+0x1e>
 852:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 856:	23 fd       	sbrc	r18, 3
 858:	30 c0       	rjmp	.+96     	; 0x8ba <Endpoint_Write_Control_Stream_LE+0xa2>
 85a:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 85e:	22 fd       	sbrc	r18, 2
 860:	f0 cf       	rjmp	.-32     	; 0x842 <Endpoint_Write_Control_Stream_LE+0x2a>
 862:	2e b3       	in	r18, 0x1e	; 30
 864:	22 23       	and	r18, r18
 866:	59 f1       	breq	.+86     	; 0x8be <Endpoint_Write_Control_Stream_LE+0xa6>
 868:	2e b3       	in	r18, 0x1e	; 30
 86a:	25 30       	cpi	r18, 0x05	; 5
 86c:	21 f1       	breq	.+72     	; 0x8b6 <Endpoint_Write_Control_Stream_LE+0x9e>
 86e:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 872:	20 ff       	sbrs	r18, 0
 874:	e1 cf       	rjmp	.-62     	; 0x838 <Endpoint_Write_Control_Stream_LE+0x20>
 876:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
 87a:	fc 01       	movw	r30, r24
 87c:	cf 01       	movw	r24, r30
 87e:	61 15       	cp	r22, r1
 880:	71 05       	cpc	r23, r1
 882:	11 f0       	breq	.+4      	; 0x888 <Endpoint_Write_Control_Stream_LE+0x70>
 884:	28 30       	cpi	r18, 0x08	; 8
 886:	50 f0       	brcs	.+20     	; 0x89c <Endpoint_Write_Control_Stream_LE+0x84>
 888:	31 e0       	ldi	r19, 0x01	; 1
 88a:	28 30       	cpi	r18, 0x08	; 8
 88c:	09 f0       	breq	.+2      	; 0x890 <Endpoint_Write_Control_Stream_LE+0x78>
 88e:	30 e0       	ldi	r19, 0x00	; 0
 890:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 894:	2e 77       	andi	r18, 0x7E	; 126
 896:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 89a:	ce cf       	rjmp	.-100    	; 0x838 <Endpoint_Write_Control_Stream_LE+0x20>
 89c:	81 91       	ld	r24, Z+
 89e:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 8a2:	61 50       	subi	r22, 0x01	; 1
 8a4:	71 09       	sbc	r23, r1
 8a6:	2f 5f       	subi	r18, 0xFF	; 255
 8a8:	e9 cf       	rjmp	.-46     	; 0x87c <Endpoint_Write_Control_Stream_LE+0x64>
 8aa:	8e b3       	in	r24, 0x1e	; 30
 8ac:	88 23       	and	r24, r24
 8ae:	39 f0       	breq	.+14     	; 0x8be <Endpoint_Write_Control_Stream_LE+0xa6>
 8b0:	8e b3       	in	r24, 0x1e	; 30
 8b2:	85 30       	cpi	r24, 0x05	; 5
 8b4:	31 f6       	brne	.-116    	; 0x842 <Endpoint_Write_Control_Stream_LE+0x2a>
 8b6:	83 e0       	ldi	r24, 0x03	; 3
 8b8:	08 95       	ret
 8ba:	81 e0       	ldi	r24, 0x01	; 1
 8bc:	08 95       	ret
 8be:	82 e0       	ldi	r24, 0x02	; 2
 8c0:	08 95       	ret

000008c2 <Endpoint_Write_Control_PStream_LE>:
 8c2:	20 91 a0 02 	lds	r18, 0x02A0	; 0x8002a0 <USB_ControlRequest+0x6>
 8c6:	30 91 a1 02 	lds	r19, 0x02A1	; 0x8002a1 <USB_ControlRequest+0x7>
 8ca:	26 17       	cp	r18, r22
 8cc:	37 07       	cpc	r19, r23
 8ce:	a0 f0       	brcs	.+40     	; 0x8f8 <Endpoint_Write_Control_PStream_LE+0x36>
 8d0:	61 15       	cp	r22, r1
 8d2:	71 05       	cpc	r23, r1
 8d4:	29 f4       	brne	.+10     	; 0x8e0 <Endpoint_Write_Control_PStream_LE+0x1e>
 8d6:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 8da:	2e 77       	andi	r18, 0x7E	; 126
 8dc:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 8e0:	30 e0       	ldi	r19, 0x00	; 0
 8e2:	61 15       	cp	r22, r1
 8e4:	71 05       	cpc	r23, r1
 8e6:	51 f4       	brne	.+20     	; 0x8fc <Endpoint_Write_Control_PStream_LE+0x3a>
 8e8:	31 11       	cpse	r19, r1
 8ea:	08 c0       	rjmp	.+16     	; 0x8fc <Endpoint_Write_Control_PStream_LE+0x3a>
 8ec:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 8f0:	82 ff       	sbrs	r24, 2
 8f2:	31 c0       	rjmp	.+98     	; 0x956 <Endpoint_Write_Control_PStream_LE+0x94>
 8f4:	80 e0       	ldi	r24, 0x00	; 0
 8f6:	08 95       	ret
 8f8:	b9 01       	movw	r22, r18
 8fa:	f2 cf       	rjmp	.-28     	; 0x8e0 <Endpoint_Write_Control_PStream_LE+0x1e>
 8fc:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 900:	23 fd       	sbrc	r18, 3
 902:	31 c0       	rjmp	.+98     	; 0x966 <Endpoint_Write_Control_PStream_LE+0xa4>
 904:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 908:	22 fd       	sbrc	r18, 2
 90a:	f0 cf       	rjmp	.-32     	; 0x8ec <Endpoint_Write_Control_PStream_LE+0x2a>
 90c:	2e b3       	in	r18, 0x1e	; 30
 90e:	22 23       	and	r18, r18
 910:	61 f1       	breq	.+88     	; 0x96a <Endpoint_Write_Control_PStream_LE+0xa8>
 912:	2e b3       	in	r18, 0x1e	; 30
 914:	25 30       	cpi	r18, 0x05	; 5
 916:	29 f1       	breq	.+74     	; 0x962 <Endpoint_Write_Control_PStream_LE+0xa0>
 918:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 91c:	20 ff       	sbrs	r18, 0
 91e:	e1 cf       	rjmp	.-62     	; 0x8e2 <Endpoint_Write_Control_PStream_LE+0x20>
 920:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
 924:	fc 01       	movw	r30, r24
 926:	cf 01       	movw	r24, r30
 928:	61 15       	cp	r22, r1
 92a:	71 05       	cpc	r23, r1
 92c:	11 f0       	breq	.+4      	; 0x932 <Endpoint_Write_Control_PStream_LE+0x70>
 92e:	28 30       	cpi	r18, 0x08	; 8
 930:	50 f0       	brcs	.+20     	; 0x946 <Endpoint_Write_Control_PStream_LE+0x84>
 932:	31 e0       	ldi	r19, 0x01	; 1
 934:	28 30       	cpi	r18, 0x08	; 8
 936:	09 f0       	breq	.+2      	; 0x93a <Endpoint_Write_Control_PStream_LE+0x78>
 938:	30 e0       	ldi	r19, 0x00	; 0
 93a:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 93e:	2e 77       	andi	r18, 0x7E	; 126
 940:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 944:	ce cf       	rjmp	.-100    	; 0x8e2 <Endpoint_Write_Control_PStream_LE+0x20>
 946:	84 91       	lpm	r24, Z
 948:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 94c:	61 50       	subi	r22, 0x01	; 1
 94e:	71 09       	sbc	r23, r1
 950:	2f 5f       	subi	r18, 0xFF	; 255
 952:	31 96       	adiw	r30, 0x01	; 1
 954:	e8 cf       	rjmp	.-48     	; 0x926 <Endpoint_Write_Control_PStream_LE+0x64>
 956:	8e b3       	in	r24, 0x1e	; 30
 958:	88 23       	and	r24, r24
 95a:	39 f0       	breq	.+14     	; 0x96a <Endpoint_Write_Control_PStream_LE+0xa8>
 95c:	8e b3       	in	r24, 0x1e	; 30
 95e:	85 30       	cpi	r24, 0x05	; 5
 960:	29 f6       	brne	.-118    	; 0x8ec <Endpoint_Write_Control_PStream_LE+0x2a>
 962:	83 e0       	ldi	r24, 0x03	; 3
 964:	08 95       	ret
 966:	81 e0       	ldi	r24, 0x01	; 1
 968:	08 95       	ret
 96a:	82 e0       	ldi	r24, 0x02	; 2
 96c:	08 95       	ret

0000096e <USB_ResetInterface>:
 96e:	42 d0       	rcall	.+132    	; 0x9f4 <USB_INT_DisableAllInterrupts>
 970:	44 d0       	rcall	.+136    	; 0x9fa <USB_INT_ClearAllInterrupts>
 972:	1e ba       	out	0x1e, r1	; 30
 974:	10 92 98 02 	sts	0x0298, r1	; 0x800298 <USB_ConfigurationNumber>
 978:	10 92 97 02 	sts	0x0297, r1	; 0x800297 <USB_RemoteWakeupEnabled>
 97c:	10 92 96 02 	sts	0x0296, r1	; 0x800296 <USB_CurrentlySelfPowered>
 980:	84 e0       	ldi	r24, 0x04	; 4
 982:	89 bd       	out	0x29, r24	; 41
 984:	89 b5       	in	r24, 0x29	; 41
 986:	82 60       	ori	r24, 0x02	; 2
 988:	89 bd       	out	0x29, r24	; 41
 98a:	09 b4       	in	r0, 0x29	; 41
 98c:	00 fe       	sbrs	r0, 0
 98e:	fd cf       	rjmp	.-6      	; 0x98a <USB_ResetInterface+0x1c>
 990:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 994:	98 2f       	mov	r25, r24
 996:	9f 77       	andi	r25, 0x7F	; 127
 998:	90 93 d8 00 	sts	0x00D8, r25	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 99c:	80 68       	ori	r24, 0x80	; 128
 99e:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 9a2:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__EEPROM_REGION_LENGTH__+0x7f0063>
 9a6:	8e 7f       	andi	r24, 0xFE	; 254
 9a8:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__EEPROM_REGION_LENGTH__+0x7f0063>
 9ac:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 9b0:	8f 7d       	andi	r24, 0xDF	; 223
 9b2:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 9b6:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__EEPROM_REGION_LENGTH__+0x7f00e0>
 9ba:	8e 7f       	andi	r24, 0xFE	; 254
 9bc:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <__EEPROM_REGION_LENGTH__+0x7f00e0>
 9c0:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 9c4:	8e 7f       	andi	r24, 0xFE	; 254
 9c6:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 9ca:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 9ce:	81 60       	ori	r24, 0x01	; 1
 9d0:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 9d4:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 9d8:	87 7f       	andi	r24, 0xF7	; 247
 9da:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 9de:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 9e2:	88 60       	ori	r24, 0x08	; 8
 9e4:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 9e8:	08 95       	ret

000009ea <USB_Init>:
 9ea:	c1 df       	rcall	.-126    	; 0x96e <USB_ResetInterface>
 9ec:	81 e0       	ldi	r24, 0x01	; 1
 9ee:	80 93 99 02 	sts	0x0299, r24	; 0x800299 <USB_IsInitialized>
 9f2:	08 95       	ret

000009f4 <USB_INT_DisableAllInterrupts>:
 9f4:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 9f8:	08 95       	ret

000009fa <USB_INT_ClearAllInterrupts>:
 9fa:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 9fe:	08 95       	ret

00000a00 <__vector_11>:
 a00:	1f 92       	push	r1
 a02:	0f 92       	push	r0
 a04:	0f b6       	in	r0, 0x3f	; 63
 a06:	0f 92       	push	r0
 a08:	11 24       	eor	r1, r1
 a0a:	2f 93       	push	r18
 a0c:	3f 93       	push	r19
 a0e:	4f 93       	push	r20
 a10:	5f 93       	push	r21
 a12:	6f 93       	push	r22
 a14:	7f 93       	push	r23
 a16:	8f 93       	push	r24
 a18:	9f 93       	push	r25
 a1a:	af 93       	push	r26
 a1c:	bf 93       	push	r27
 a1e:	ef 93       	push	r30
 a20:	ff 93       	push	r31
 a22:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 a26:	80 ff       	sbrs	r24, 0
 a28:	1b c0       	rjmp	.+54     	; 0xa60 <__vector_11+0x60>
 a2a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a2e:	80 ff       	sbrs	r24, 0
 a30:	17 c0       	rjmp	.+46     	; 0xa60 <__vector_11+0x60>
 a32:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 a36:	8e 7f       	andi	r24, 0xFE	; 254
 a38:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 a3c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a40:	8e 7f       	andi	r24, 0xFE	; 254
 a42:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a46:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a4a:	80 61       	ori	r24, 0x10	; 16
 a4c:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a50:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 a54:	80 62       	ori	r24, 0x20	; 32
 a56:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 a5a:	19 bc       	out	0x29, r1	; 41
 a5c:	1e ba       	out	0x1e, r1	; 30
 a5e:	df db       	rcall	.-2114   	; 0x21e <EVENT_USB_Device_Disconnect>
 a60:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 a64:	84 ff       	sbrs	r24, 4
 a66:	27 c0       	rjmp	.+78     	; 0xab6 <__vector_11+0xb6>
 a68:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a6c:	84 ff       	sbrs	r24, 4
 a6e:	23 c0       	rjmp	.+70     	; 0xab6 <__vector_11+0xb6>
 a70:	84 e0       	ldi	r24, 0x04	; 4
 a72:	89 bd       	out	0x29, r24	; 41
 a74:	89 b5       	in	r24, 0x29	; 41
 a76:	82 60       	ori	r24, 0x02	; 2
 a78:	89 bd       	out	0x29, r24	; 41
 a7a:	09 b4       	in	r0, 0x29	; 41
 a7c:	00 fe       	sbrs	r0, 0
 a7e:	fd cf       	rjmp	.-6      	; 0xa7a <__vector_11+0x7a>
 a80:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 a84:	8f 7d       	andi	r24, 0xDF	; 223
 a86:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 a8a:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 a8e:	8f 7e       	andi	r24, 0xEF	; 239
 a90:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 a94:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a98:	8f 7e       	andi	r24, 0xEF	; 239
 a9a:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 a9e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 aa2:	81 60       	ori	r24, 0x01	; 1
 aa4:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 aa8:	80 91 98 02 	lds	r24, 0x0298	; 0x800298 <USB_ConfigurationNumber>
 aac:	81 11       	cpse	r24, r1
 aae:	4d c0       	rjmp	.+154    	; 0xb4a <__vector_11+0x14a>
 ab0:	81 e0       	ldi	r24, 0x01	; 1
 ab2:	8e bb       	out	0x1e, r24	; 30
 ab4:	ae db       	rcall	.-2212   	; 0x212 <EVENT_USB_Device_Connect>
 ab6:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 aba:	83 ff       	sbrs	r24, 3
 abc:	27 c0       	rjmp	.+78     	; 0xb0c <__vector_11+0x10c>
 abe:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 ac2:	83 ff       	sbrs	r24, 3
 ac4:	23 c0       	rjmp	.+70     	; 0xb0c <__vector_11+0x10c>
 ac6:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 aca:	87 7f       	andi	r24, 0xF7	; 247
 acc:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 ad0:	82 e0       	ldi	r24, 0x02	; 2
 ad2:	8e bb       	out	0x1e, r24	; 30
 ad4:	10 92 98 02 	sts	0x0298, r1	; 0x800298 <USB_ConfigurationNumber>
 ad8:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 adc:	8e 7f       	andi	r24, 0xFE	; 254
 ade:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 ae2:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 ae6:	8e 7f       	andi	r24, 0xFE	; 254
 ae8:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 aec:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 af0:	80 61       	ori	r24, 0x10	; 16
 af2:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 af6:	f9 dd       	rcall	.-1038   	; 0x6ea <Endpoint_ClearEndpoints>
 af8:	42 e0       	ldi	r20, 0x02	; 2
 afa:	60 e0       	ldi	r22, 0x00	; 0
 afc:	80 e0       	ldi	r24, 0x00	; 0
 afe:	e2 dd       	rcall	.-1084   	; 0x6c4 <Endpoint_ConfigureEndpoint_Prv>
 b00:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__EEPROM_REGION_LENGTH__+0x7f00f0>
 b04:	88 60       	ori	r24, 0x08	; 8
 b06:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__EEPROM_REGION_LENGTH__+0x7f00f0>
 b0a:	a1 d1       	rcall	.+834    	; 0xe4e <USB_Event_Stub>
 b0c:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 b10:	82 ff       	sbrs	r24, 2
 b12:	0a c0       	rjmp	.+20     	; 0xb28 <__vector_11+0x128>
 b14:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 b18:	82 ff       	sbrs	r24, 2
 b1a:	06 c0       	rjmp	.+12     	; 0xb28 <__vector_11+0x128>
 b1c:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 b20:	8b 7f       	andi	r24, 0xFB	; 251
 b22:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 b26:	94 db       	rcall	.-2264   	; 0x250 <EVENT_USB_Device_StartOfFrame>
 b28:	ff 91       	pop	r31
 b2a:	ef 91       	pop	r30
 b2c:	bf 91       	pop	r27
 b2e:	af 91       	pop	r26
 b30:	9f 91       	pop	r25
 b32:	8f 91       	pop	r24
 b34:	7f 91       	pop	r23
 b36:	6f 91       	pop	r22
 b38:	5f 91       	pop	r21
 b3a:	4f 91       	pop	r20
 b3c:	3f 91       	pop	r19
 b3e:	2f 91       	pop	r18
 b40:	0f 90       	pop	r0
 b42:	0f be       	out	0x3f, r0	; 63
 b44:	0f 90       	pop	r0
 b46:	1f 90       	pop	r1
 b48:	18 95       	reti
 b4a:	84 e0       	ldi	r24, 0x04	; 4
 b4c:	b2 cf       	rjmp	.-156    	; 0xab2 <__vector_11+0xb2>

00000b4e <__vector_12>:
 b4e:	1f 92       	push	r1
 b50:	0f 92       	push	r0
 b52:	0f b6       	in	r0, 0x3f	; 63
 b54:	0f 92       	push	r0
 b56:	11 24       	eor	r1, r1
 b58:	ff 92       	push	r15
 b5a:	0f 93       	push	r16
 b5c:	1f 93       	push	r17
 b5e:	2f 93       	push	r18
 b60:	3f 93       	push	r19
 b62:	4f 93       	push	r20
 b64:	5f 93       	push	r21
 b66:	6f 93       	push	r22
 b68:	7f 93       	push	r23
 b6a:	8f 93       	push	r24
 b6c:	9f 93       	push	r25
 b6e:	af 93       	push	r26
 b70:	bf 93       	push	r27
 b72:	cf 93       	push	r28
 b74:	df 93       	push	r29
 b76:	ef 93       	push	r30
 b78:	ff 93       	push	r31
 b7a:	c9 ee       	ldi	r28, 0xE9	; 233
 b7c:	d0 e0       	ldi	r29, 0x00	; 0
 b7e:	88 81       	ld	r24, Y
 b80:	87 70       	andi	r24, 0x07	; 7
 b82:	f8 2e       	mov	r15, r24
 b84:	18 82       	st	Y, r1
 b86:	00 ef       	ldi	r16, 0xF0	; 240
 b88:	10 e0       	ldi	r17, 0x00	; 0
 b8a:	f8 01       	movw	r30, r16
 b8c:	80 81       	ld	r24, Z
 b8e:	87 7f       	andi	r24, 0xF7	; 247
 b90:	80 83       	st	Z, r24

#if !defined(__DOXYGEN__)
/* Internal helper functions. */
static __inline__ uint8_t __iSeiRetVal(void)
{
    sei();
 b92:	78 94       	sei
 b94:	1d d0       	rcall	.+58     	; 0xbd0 <USB_Device_ProcessControlRequest>
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    cli();
 b96:	f8 94       	cli
 b98:	18 82       	st	Y, r1
 b9a:	f8 01       	movw	r30, r16
 b9c:	80 81       	ld	r24, Z
 b9e:	88 60       	ori	r24, 0x08	; 8
 ba0:	80 83       	st	Z, r24
 ba2:	f8 82       	st	Y, r15
 ba4:	ff 91       	pop	r31
 ba6:	ef 91       	pop	r30
 ba8:	df 91       	pop	r29
 baa:	cf 91       	pop	r28
 bac:	bf 91       	pop	r27
 bae:	af 91       	pop	r26
 bb0:	9f 91       	pop	r25
 bb2:	8f 91       	pop	r24
 bb4:	7f 91       	pop	r23
 bb6:	6f 91       	pop	r22
 bb8:	5f 91       	pop	r21
 bba:	4f 91       	pop	r20
 bbc:	3f 91       	pop	r19
 bbe:	2f 91       	pop	r18
 bc0:	1f 91       	pop	r17
 bc2:	0f 91       	pop	r16
 bc4:	ff 90       	pop	r15
 bc6:	0f 90       	pop	r0
 bc8:	0f be       	out	0x3f, r0	; 63
 bca:	0f 90       	pop	r0
 bcc:	1f 90       	pop	r1
 bce:	18 95       	reti

00000bd0 <USB_Device_ProcessControlRequest>:
 bd0:	1f 93       	push	r17
 bd2:	cf 93       	push	r28
 bd4:	df 93       	push	r29
 bd6:	cd b7       	in	r28, 0x3d	; 61
 bd8:	de b7       	in	r29, 0x3e	; 62
 bda:	aa 97       	sbiw	r28, 0x2a	; 42
 bdc:	0f b6       	in	r0, 0x3f	; 63
 bde:	f8 94       	cli
 be0:	de bf       	out	0x3e, r29	; 62
 be2:	0f be       	out	0x3f, r0	; 63
 be4:	cd bf       	out	0x3d, r28	; 61
 be6:	ea e9       	ldi	r30, 0x9A	; 154
 be8:	f2 e0       	ldi	r31, 0x02	; 2
 bea:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 bee:	81 93       	st	Z+, r24
 bf0:	22 e0       	ldi	r18, 0x02	; 2
 bf2:	e2 3a       	cpi	r30, 0xA2	; 162
 bf4:	f2 07       	cpc	r31, r18
 bf6:	c9 f7       	brne	.-14     	; 0xbea <USB_Device_ProcessControlRequest+0x1a>
 bf8:	80 91 9a 02 	lds	r24, 0x029A	; 0x80029a <USB_ControlRequest>
 bfc:	90 91 9b 02 	lds	r25, 0x029B	; 0x80029b <USB_ControlRequest+0x1>
 c00:	9a 30       	cpi	r25, 0x0A	; 10
 c02:	08 f0       	brcs	.+2      	; 0xc06 <USB_Device_ProcessControlRequest+0x36>
 c04:	22 c1       	rjmp	.+580    	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 c06:	e9 2f       	mov	r30, r25
 c08:	f0 e0       	ldi	r31, 0x00	; 0
 c0a:	e8 5f       	subi	r30, 0xF8	; 248
 c0c:	f9 4f       	sbci	r31, 0xF9	; 249
 c0e:	31 c1       	rjmp	.+610    	; 0xe72 <__tablejump2__>
 c10:	12 06       	cpc	r1, r18
 c12:	37 06       	cpc	r3, r23
 c14:	25 07       	cpc	r18, r21
 c16:	37 06       	cpc	r3, r23
 c18:	25 07       	cpc	r18, r21
 c1a:	92 06       	cpc	r9, r18
 c1c:	ae 06       	cpc	r10, r30
 c1e:	25 07       	cpc	r18, r21
 c20:	00 07       	cpc	r16, r16
 c22:	0c 07       	cpc	r16, r28
 c24:	80 38       	cpi	r24, 0x80	; 128
 c26:	81 f0       	breq	.+32     	; 0xc48 <USB_Device_ProcessControlRequest+0x78>
 c28:	82 38       	cpi	r24, 0x82	; 130
 c2a:	09 f0       	breq	.+2      	; 0xc2e <USB_Device_ProcessControlRequest+0x5e>
 c2c:	0e c1       	rjmp	.+540    	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 c2e:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <USB_ControlRequest+0x4>
 c32:	87 70       	andi	r24, 0x07	; 7
 c34:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 c38:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 c3c:	85 fb       	bst	r24, 5
 c3e:	88 27       	eor	r24, r24
 c40:	80 f9       	bld	r24, 0
 c42:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 c46:	06 c0       	rjmp	.+12     	; 0xc54 <USB_Device_ProcessControlRequest+0x84>
 c48:	80 91 96 02 	lds	r24, 0x0296	; 0x800296 <USB_CurrentlySelfPowered>
 c4c:	90 91 97 02 	lds	r25, 0x0297	; 0x800297 <USB_RemoteWakeupEnabled>
 c50:	91 11       	cpse	r25, r1
 c52:	82 60       	ori	r24, 0x02	; 2
 c54:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c58:	97 7f       	andi	r25, 0xF7	; 247
 c5a:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c5e:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 c62:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 c66:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c6a:	8e 77       	andi	r24, 0x7E	; 126
 c6c:	2e c0       	rjmp	.+92     	; 0xcca <USB_Device_ProcessControlRequest+0xfa>
 c6e:	28 2f       	mov	r18, r24
 c70:	2d 7f       	andi	r18, 0xFD	; 253
 c72:	09 f0       	breq	.+2      	; 0xc76 <USB_Device_ProcessControlRequest+0xa6>
 c74:	ea c0       	rjmp	.+468    	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 c76:	88 23       	and	r24, r24
 c78:	d1 f0       	breq	.+52     	; 0xcae <USB_Device_ProcessControlRequest+0xde>
 c7a:	82 30       	cpi	r24, 0x02	; 2
 c7c:	51 f1       	breq	.+84     	; 0xcd2 <USB_Device_ProcessControlRequest+0x102>
 c7e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c82:	83 ff       	sbrs	r24, 3
 c84:	0a c0       	rjmp	.+20     	; 0xc9a <USB_Device_ProcessControlRequest+0xca>
 c86:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 c8a:	80 62       	ori	r24, 0x20	; 32
 c8c:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 c90:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c94:	87 7f       	andi	r24, 0xF7	; 247
 c96:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c9a:	aa 96       	adiw	r28, 0x2a	; 42
 c9c:	0f b6       	in	r0, 0x3f	; 63
 c9e:	f8 94       	cli
 ca0:	de bf       	out	0x3e, r29	; 62
 ca2:	0f be       	out	0x3f, r0	; 63
 ca4:	cd bf       	out	0x3d, r28	; 61
 ca6:	df 91       	pop	r29
 ca8:	cf 91       	pop	r28
 caa:	1f 91       	pop	r17
 cac:	08 95       	ret
 cae:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 cb2:	81 30       	cpi	r24, 0x01	; 1
 cb4:	21 f7       	brne	.-56     	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 cb6:	93 30       	cpi	r25, 0x03	; 3
 cb8:	09 f0       	breq	.+2      	; 0xcbc <USB_Device_ProcessControlRequest+0xec>
 cba:	80 e0       	ldi	r24, 0x00	; 0
 cbc:	80 93 97 02 	sts	0x0297, r24	; 0x800297 <USB_RemoteWakeupEnabled>
 cc0:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 cc4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 cc8:	87 7f       	andi	r24, 0xF7	; 247
 cca:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 cce:	21 dd       	rcall	.-1470   	; 0x712 <Endpoint_ClearStatusStage>
 cd0:	d6 cf       	rjmp	.-84     	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 cd2:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 cd6:	81 11       	cpse	r24, r1
 cd8:	f3 cf       	rjmp	.-26     	; 0xcc0 <USB_Device_ProcessControlRequest+0xf0>
 cda:	80 91 9e 02 	lds	r24, 0x029E	; 0x80029e <USB_ControlRequest+0x4>
 cde:	87 70       	andi	r24, 0x07	; 7
 ce0:	71 f2       	breq	.-100    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 ce2:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 ce6:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 cea:	20 ff       	sbrs	r18, 0
 cec:	c8 cf       	rjmp	.-112    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 cee:	93 30       	cpi	r25, 0x03	; 3
 cf0:	31 f4       	brne	.+12     	; 0xcfe <USB_Device_ProcessControlRequest+0x12e>
 cf2:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 cf6:	80 62       	ori	r24, 0x20	; 32
 cf8:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 cfc:	e1 cf       	rjmp	.-62     	; 0xcc0 <USB_Device_ProcessControlRequest+0xf0>
 cfe:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 d02:	90 61       	ori	r25, 0x10	; 16
 d04:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 d08:	21 e0       	ldi	r18, 0x01	; 1
 d0a:	30 e0       	ldi	r19, 0x00	; 0
 d0c:	01 c0       	rjmp	.+2      	; 0xd10 <USB_Device_ProcessControlRequest+0x140>
 d0e:	22 0f       	add	r18, r18
 d10:	8a 95       	dec	r24
 d12:	ea f7       	brpl	.-6      	; 0xd0e <USB_Device_ProcessControlRequest+0x13e>
 d14:	20 93 ea 00 	sts	0x00EA, r18	; 0x8000ea <__EEPROM_REGION_LENGTH__+0x7f00ea>
 d18:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__EEPROM_REGION_LENGTH__+0x7f00ea>
 d1c:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 d20:	88 60       	ori	r24, 0x08	; 8
 d22:	ea cf       	rjmp	.-44     	; 0xcf8 <USB_Device_ProcessControlRequest+0x128>
 d24:	81 11       	cpse	r24, r1
 d26:	91 c0       	rjmp	.+290    	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 d28:	10 91 9c 02 	lds	r17, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 d2c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d30:	87 7f       	andi	r24, 0xF7	; 247
 d32:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d36:	ed dc       	rcall	.-1574   	; 0x712 <Endpoint_ClearStatusStage>
 d38:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d3c:	80 ff       	sbrs	r24, 0
 d3e:	0a c0       	rjmp	.+20     	; 0xd54 <USB_Device_ProcessControlRequest+0x184>
 d40:	81 2f       	mov	r24, r17
 d42:	8f 77       	andi	r24, 0x7F	; 127
 d44:	92 e0       	ldi	r25, 0x02	; 2
 d46:	09 f0       	breq	.+2      	; 0xd4a <USB_Device_ProcessControlRequest+0x17a>
 d48:	93 e0       	ldi	r25, 0x03	; 3
 d4a:	9e bb       	out	0x1e, r25	; 30
 d4c:	80 68       	ori	r24, 0x80	; 128
 d4e:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__EEPROM_REGION_LENGTH__+0x7f00e3>
 d52:	95 cf       	rjmp	.-214    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 d54:	8e b3       	in	r24, 0x1e	; 30
 d56:	81 11       	cpse	r24, r1
 d58:	ef cf       	rjmp	.-34     	; 0xd38 <USB_Device_ProcessControlRequest+0x168>
 d5a:	91 cf       	rjmp	.-222    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 d5c:	80 58       	subi	r24, 0x80	; 128
 d5e:	82 30       	cpi	r24, 0x02	; 2
 d60:	08 f0       	brcs	.+2      	; 0xd64 <USB_Device_ProcessControlRequest+0x194>
 d62:	73 c0       	rjmp	.+230    	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 d64:	80 91 9c 02 	lds	r24, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 d68:	90 91 9d 02 	lds	r25, 0x029D	; 0x80029d <USB_ControlRequest+0x3>
 d6c:	8c 3d       	cpi	r24, 0xDC	; 220
 d6e:	23 e0       	ldi	r18, 0x03	; 3
 d70:	92 07       	cpc	r25, r18
 d72:	99 f5       	brne	.+102    	; 0xdda <USB_Device_ProcessControlRequest+0x20a>
 d74:	83 e0       	ldi	r24, 0x03	; 3
 d76:	8a 83       	std	Y+2, r24	; 0x02
 d78:	8a e2       	ldi	r24, 0x2A	; 42
 d7a:	89 83       	std	Y+1, r24	; 0x01
 d7c:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 d7e:	f8 94       	cli
 d80:	de 01       	movw	r26, r28
 d82:	13 96       	adiw	r26, 0x03	; 3
 d84:	20 e0       	ldi	r18, 0x00	; 0
 d86:	3e e0       	ldi	r19, 0x0E	; 14
 d88:	51 e2       	ldi	r21, 0x21	; 33
 d8a:	e3 2f       	mov	r30, r19
 d8c:	f0 e0       	ldi	r31, 0x00	; 0
 d8e:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
 d92:	e4 91       	lpm	r30, Z
 d94:	20 ff       	sbrs	r18, 0
 d96:	03 c0       	rjmp	.+6      	; 0xd9e <USB_Device_ProcessControlRequest+0x1ce>
 d98:	e2 95       	swap	r30
 d9a:	ef 70       	andi	r30, 0x0F	; 15
 d9c:	3f 5f       	subi	r19, 0xFF	; 255
 d9e:	ef 70       	andi	r30, 0x0F	; 15
 da0:	80 e3       	ldi	r24, 0x30	; 48
 da2:	8e 0f       	add	r24, r30
 da4:	8a 33       	cpi	r24, 0x3A	; 58
 da6:	10 f0       	brcs	.+4      	; 0xdac <USB_Device_ProcessControlRequest+0x1dc>
 da8:	87 e3       	ldi	r24, 0x37	; 55
 daa:	8e 0f       	add	r24, r30
 dac:	90 e0       	ldi	r25, 0x00	; 0
 dae:	8d 93       	st	X+, r24
 db0:	9d 93       	st	X+, r25
 db2:	2f 5f       	subi	r18, 0xFF	; 255
 db4:	24 31       	cpi	r18, 0x14	; 20
 db6:	49 f7       	brne	.-46     	; 0xd8a <USB_Device_ProcessControlRequest+0x1ba>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 db8:	4f bf       	out	0x3f, r20	; 63
 dba:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 dbe:	87 7f       	andi	r24, 0xF7	; 247
 dc0:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 dc4:	6a e2       	ldi	r22, 0x2A	; 42
 dc6:	70 e0       	ldi	r23, 0x00	; 0
 dc8:	ce 01       	movw	r24, r28
 dca:	01 96       	adiw	r24, 0x01	; 1
 dcc:	25 dd       	rcall	.-1462   	; 0x818 <Endpoint_Write_Control_Stream_LE>
 dce:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 dd2:	8b 77       	andi	r24, 0x7B	; 123
 dd4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 dd8:	52 cf       	rjmp	.-348    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 dda:	ae 01       	movw	r20, r28
 ddc:	4f 5f       	subi	r20, 0xFF	; 255
 dde:	5f 4f       	sbci	r21, 0xFF	; 255
 de0:	60 91 9e 02 	lds	r22, 0x029E	; 0x80029e <USB_ControlRequest+0x4>
 de4:	2e dc       	rcall	.-1956   	; 0x642 <CALLBACK_USB_GetDescriptor>
 de6:	bc 01       	movw	r22, r24
 de8:	89 2b       	or	r24, r25
 dea:	09 f4       	brne	.+2      	; 0xdee <USB_Device_ProcessControlRequest+0x21e>
 dec:	48 cf       	rjmp	.-368    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 dee:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 df2:	97 7f       	andi	r25, 0xF7	; 247
 df4:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 df8:	89 81       	ldd	r24, Y+1	; 0x01
 dfa:	9a 81       	ldd	r25, Y+2	; 0x02
 dfc:	62 dd       	rcall	.-1340   	; 0x8c2 <Endpoint_Write_Control_PStream_LE>
 dfe:	e7 cf       	rjmp	.-50     	; 0xdce <USB_Device_ProcessControlRequest+0x1fe>
 e00:	80 38       	cpi	r24, 0x80	; 128
 e02:	19 f5       	brne	.+70     	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 e04:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e08:	87 7f       	andi	r24, 0xF7	; 247
 e0a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e0e:	80 91 98 02 	lds	r24, 0x0298	; 0x800298 <USB_ConfigurationNumber>
 e12:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 e16:	27 cf       	rjmp	.-434    	; 0xc66 <USB_Device_ProcessControlRequest+0x96>
 e18:	81 11       	cpse	r24, r1
 e1a:	17 c0       	rjmp	.+46     	; 0xe4a <USB_Device_ProcessControlRequest+0x27a>
 e1c:	90 91 9c 02 	lds	r25, 0x029C	; 0x80029c <USB_ControlRequest+0x2>
 e20:	92 30       	cpi	r25, 0x02	; 2
 e22:	08 f0       	brcs	.+2      	; 0xe26 <USB_Device_ProcessControlRequest+0x256>
 e24:	2c cf       	rjmp	.-424    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 e26:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e2a:	87 7f       	andi	r24, 0xF7	; 247
 e2c:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e30:	90 93 98 02 	sts	0x0298, r25	; 0x800298 <USB_ConfigurationNumber>
 e34:	6e dc       	rcall	.-1828   	; 0x712 <Endpoint_ClearStatusStage>
 e36:	80 91 98 02 	lds	r24, 0x0298	; 0x800298 <USB_ConfigurationNumber>
 e3a:	81 11       	cpse	r24, r1
 e3c:	04 c0       	rjmp	.+8      	; 0xe46 <USB_Device_ProcessControlRequest+0x276>
 e3e:	83 e0       	ldi	r24, 0x03	; 3
 e40:	8e bb       	out	0x1e, r24	; 30
 e42:	ef d9       	rcall	.-3106   	; 0x222 <EVENT_USB_Device_ConfigurationChanged>
 e44:	1c cf       	rjmp	.-456    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>
 e46:	84 e0       	ldi	r24, 0x04	; 4
 e48:	fb cf       	rjmp	.-10     	; 0xe40 <USB_Device_ProcessControlRequest+0x270>
 e4a:	69 da       	rcall	.-2862   	; 0x31e <EVENT_USB_Device_UnhandledControlRequest>
 e4c:	18 cf       	rjmp	.-464    	; 0xc7e <USB_Device_ProcessControlRequest+0xae>

00000e4e <USB_Event_Stub>:
 e4e:	08 95       	ret

00000e50 <USB_USBTask>:
 e50:	cf 93       	push	r28
 e52:	8e b3       	in	r24, 0x1e	; 30
 e54:	88 23       	and	r24, r24
 e56:	59 f0       	breq	.+22     	; 0xe6e <USB_USBTask+0x1e>
 e58:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 e5c:	c7 70       	andi	r28, 0x07	; 7
 e5e:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 e62:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e66:	83 fd       	sbrc	r24, 3
 e68:	b3 de       	rcall	.-666    	; 0xbd0 <USB_Device_ProcessControlRequest>
 e6a:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 e6e:	cf 91       	pop	r28
 e70:	08 95       	ret

00000e72 <__tablejump2__>:
 e72:	ee 0f       	add	r30, r30
 e74:	ff 1f       	adc	r31, r31
 e76:	05 90       	lpm	r0, Z+
 e78:	f4 91       	lpm	r31, Z
 e7a:	e0 2d       	mov	r30, r0
 e7c:	09 94       	ijmp

00000e7e <memcmp>:
 e7e:	fb 01       	movw	r30, r22
 e80:	dc 01       	movw	r26, r24
 e82:	04 c0       	rjmp	.+8      	; 0xe8c <memcmp+0xe>
 e84:	8d 91       	ld	r24, X+
 e86:	01 90       	ld	r0, Z+
 e88:	80 19       	sub	r24, r0
 e8a:	21 f4       	brne	.+8      	; 0xe94 <memcmp+0x16>
 e8c:	41 50       	subi	r20, 0x01	; 1
 e8e:	50 40       	sbci	r21, 0x00	; 0
 e90:	c8 f7       	brcc	.-14     	; 0xe84 <memcmp+0x6>
 e92:	88 1b       	sub	r24, r24
 e94:	99 0b       	sbc	r25, r25
 e96:	08 95       	ret

00000e98 <_exit>:
 e98:	f8 94       	cli

00000e9a <__stop_program>:
 e9a:	ff cf       	rjmp	.-2      	; 0xe9a <__stop_program>
