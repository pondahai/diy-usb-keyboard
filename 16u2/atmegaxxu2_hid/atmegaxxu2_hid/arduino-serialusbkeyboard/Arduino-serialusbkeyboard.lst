   1               		.file	"Arduino-serialusbkeyboard.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.text.LEDs_SetAllLEDs,"ax",@progbits
  12               	LEDs_SetAllLEDs:
  13               	.LFB79:
  14               		.file 1 "./Board/LEDs.h"
   1:./Board/LEDs.h **** /*
   2:./Board/LEDs.h ****              LUFA Library
   3:./Board/LEDs.h ****      Copyright (C) Dean Camera, 2010.
   4:./Board/LEDs.h ****               
   5:./Board/LEDs.h ****   dean [at] fourwalledcubicle [dot] com
   6:./Board/LEDs.h ****       www.fourwalledcubicle.com
   7:./Board/LEDs.h **** */
   8:./Board/LEDs.h **** 
   9:./Board/LEDs.h **** /*
  10:./Board/LEDs.h ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:./Board/LEDs.h **** 
  12:./Board/LEDs.h ****   Permission to use, copy, modify, distribute, and sell this 
  13:./Board/LEDs.h ****   software and its documentation for any purpose is hereby granted
  14:./Board/LEDs.h ****   without fee, provided that the above copyright notice appear in 
  15:./Board/LEDs.h ****   all copies and that both that the copyright notice and this
  16:./Board/LEDs.h ****   permission notice and warranty disclaimer appear in supporting 
  17:./Board/LEDs.h ****   documentation, and that the name of the author not be used in 
  18:./Board/LEDs.h ****   advertising or publicity pertaining to distribution of the 
  19:./Board/LEDs.h ****   software without specific, written prior permission.
  20:./Board/LEDs.h **** 
  21:./Board/LEDs.h ****   The author disclaim all warranties with regard to this
  22:./Board/LEDs.h ****   software, including all implied warranties of merchantability
  23:./Board/LEDs.h ****   and fitness.  In no event shall the author be liable for any
  24:./Board/LEDs.h ****   special, indirect or consequential damages or any damages
  25:./Board/LEDs.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:./Board/LEDs.h ****   in an action of contract, negligence or other tortious action,
  27:./Board/LEDs.h ****   arising out of or in connection with the use or performance of
  28:./Board/LEDs.h ****   this software.
  29:./Board/LEDs.h **** */
  30:./Board/LEDs.h **** 
  31:./Board/LEDs.h **** /*
  32:./Board/LEDs.h ****    Board LEDs driver for the Benito board, from www.dorkbotpdx.org.
  33:./Board/LEDs.h **** */
  34:./Board/LEDs.h **** 
  35:./Board/LEDs.h **** #ifndef __LEDS_ARDUINOUNO_H__
  36:./Board/LEDs.h **** #define __LEDS_ARDUINOUNO_H__
  37:./Board/LEDs.h **** 
  38:./Board/LEDs.h **** 	/* Includes: */
  39:./Board/LEDs.h **** 		#include <avr/io.h>
  40:./Board/LEDs.h **** 
  41:./Board/LEDs.h **** /* Enable C linkage for C++ Compilers: */
  42:./Board/LEDs.h **** 		#if defined(__cplusplus)
  43:./Board/LEDs.h **** 			extern "C" {
  44:./Board/LEDs.h **** 		#endif
  45:./Board/LEDs.h **** 
  46:./Board/LEDs.h **** 	/* Preprocessor Checks: */
  47:./Board/LEDs.h **** 		#if !defined(INCLUDE_FROM_LEDS_H)
  48:./Board/LEDs.h **** 			#error Do not include this file directly. Include LUFA/Drivers/Board/LEDS.h instead.
  49:./Board/LEDs.h **** 		#endif
  50:./Board/LEDs.h **** 
  51:./Board/LEDs.h **** 	/* Public Interface - May be used in end-application: */
  52:./Board/LEDs.h **** 		/* Macros: */
  53:./Board/LEDs.h **** 			/** LED mask for the first LED on the board. */
  54:./Board/LEDs.h **** 			#define LEDS_LED1        (1 << 5)
  55:./Board/LEDs.h **** 
  56:./Board/LEDs.h **** 			/** LED mask for the second LED on the board. */
  57:./Board/LEDs.h **** 			#define LEDS_LED2        (1 << 4)
  58:./Board/LEDs.h **** 
  59:./Board/LEDs.h **** 			/** LED mask for all the LEDs on the board. */
  60:./Board/LEDs.h **** 			#define LEDS_ALL_LEDS    (LEDS_LED1 | LEDS_LED2)
  61:./Board/LEDs.h **** 
  62:./Board/LEDs.h **** 			/** LED mask for the none of the board LEDs */
  63:./Board/LEDs.h **** 			#define LEDS_NO_LEDS     0
  64:./Board/LEDs.h **** 
  65:./Board/LEDs.h **** 		/* Inline Functions: */
  66:./Board/LEDs.h **** 		#if !defined(__DOXYGEN__)
  67:./Board/LEDs.h **** 			static inline void LEDs_Init(void)
  68:./Board/LEDs.h **** 			{
  69:./Board/LEDs.h **** 				DDRD  |= LEDS_ALL_LEDS;
  70:./Board/LEDs.h **** 				PORTD |= LEDS_ALL_LEDS;
  71:./Board/LEDs.h **** 			}
  72:./Board/LEDs.h **** 			
  73:./Board/LEDs.h **** 			static inline void LEDs_TurnOnLEDs(const uint8_t LEDMask)
  74:./Board/LEDs.h **** 			{
  75:./Board/LEDs.h **** 				PORTD &= ~LEDMask;
  76:./Board/LEDs.h **** 			}
  77:./Board/LEDs.h **** 
  78:./Board/LEDs.h **** 			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
  79:./Board/LEDs.h **** 			{
  80:./Board/LEDs.h **** 				PORTD |= LEDMask;
  81:./Board/LEDs.h **** 			}
  82:./Board/LEDs.h **** 
  83:./Board/LEDs.h **** 			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
  84:./Board/LEDs.h **** 			{
  15               		.loc 1 84 0
  16               		.cfi_startproc
  17               	.LVL0:
  18               	/* prologue: function */
  19               	/* frame size = 0 */
  20               	/* stack size = 0 */
  21               	.L__stack_usage = 0
  85:./Board/LEDs.h **** 				PORTD = ((PORTD | LEDS_ALL_LEDS) & ~LEDMask);
  22               		.loc 1 85 0
  23 0000 9BB1      		in r25,0xb
  24 0002 9063      		ori r25,lo8(48)
  25 0004 8095      		com r24
  26               	.LVL1:
  27 0006 9823      		and r25,r24
  28 0008 9BB9      		out 0xb,r25
  29               	/* epilogue start */
  86:./Board/LEDs.h **** 			}
  30               		.loc 1 86 0
  31 000a 0895      		ret
  32               		.cfi_endproc
  33               	.LFE79:
  35               		.section	.text.RingBuffer_Remove.constprop.3,"ax",@progbits
  37               	RingBuffer_Remove.constprop.3:
  38               	.LFB107:
  39               		.file 2 "Lib/LightweightRingBuff.h"
   1:Lib/LightweightRingBuff.h **** /*
   2:Lib/LightweightRingBuff.h ****              LUFA Library
   3:Lib/LightweightRingBuff.h ****      Copyright (C) Dean Camera, 2010.
   4:Lib/LightweightRingBuff.h ****               
   5:Lib/LightweightRingBuff.h ****   dean [at] fourwalledcubicle [dot] com
   6:Lib/LightweightRingBuff.h ****       www.fourwalledcubicle.com
   7:Lib/LightweightRingBuff.h **** */
   8:Lib/LightweightRingBuff.h **** 
   9:Lib/LightweightRingBuff.h **** /*
  10:Lib/LightweightRingBuff.h ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Lib/LightweightRingBuff.h **** 
  12:Lib/LightweightRingBuff.h ****   Permission to use, copy, modify, distribute, and sell this 
  13:Lib/LightweightRingBuff.h ****   software and its documentation for any purpose is hereby granted
  14:Lib/LightweightRingBuff.h ****   without fee, provided that the above copyright notice appear in 
  15:Lib/LightweightRingBuff.h ****   all copies and that both that the copyright notice and this
  16:Lib/LightweightRingBuff.h ****   permission notice and warranty disclaimer appear in supporting 
  17:Lib/LightweightRingBuff.h ****   documentation, and that the name of the author not be used in 
  18:Lib/LightweightRingBuff.h ****   advertising or publicity pertaining to distribution of the 
  19:Lib/LightweightRingBuff.h ****   software without specific, written prior permission.
  20:Lib/LightweightRingBuff.h **** 
  21:Lib/LightweightRingBuff.h ****   The author disclaim all warranties with regard to this
  22:Lib/LightweightRingBuff.h ****   software, including all implied warranties of merchantability
  23:Lib/LightweightRingBuff.h ****   and fitness.  In no event shall the author be liable for any
  24:Lib/LightweightRingBuff.h ****   special, indirect or consequential damages or any damages
  25:Lib/LightweightRingBuff.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:Lib/LightweightRingBuff.h ****   in an action of contract, negligence or other tortious action,
  27:Lib/LightweightRingBuff.h ****   arising out of or in connection with the use or performance of
  28:Lib/LightweightRingBuff.h ****   this software.
  29:Lib/LightweightRingBuff.h **** */
  30:Lib/LightweightRingBuff.h **** 
  31:Lib/LightweightRingBuff.h **** /** \file
  32:Lib/LightweightRingBuff.h ****  *
  33:Lib/LightweightRingBuff.h ****  *  Ultra lightweight ring buffer, for fast insertion/deletion.
  34:Lib/LightweightRingBuff.h ****  */
  35:Lib/LightweightRingBuff.h ****  
  36:Lib/LightweightRingBuff.h **** #ifndef _ULW_RING_BUFF_H_
  37:Lib/LightweightRingBuff.h **** #define _ULW_RING_BUFF_H_
  38:Lib/LightweightRingBuff.h **** 
  39:Lib/LightweightRingBuff.h **** 	/* Includes: */
  40:Lib/LightweightRingBuff.h **** 		#include <util/atomic.h>
  41:Lib/LightweightRingBuff.h **** 	
  42:Lib/LightweightRingBuff.h **** 		#include <stdint.h>
  43:Lib/LightweightRingBuff.h **** 		#include <stdbool.h>
  44:Lib/LightweightRingBuff.h **** 
  45:Lib/LightweightRingBuff.h **** 	/* Defines: */
  46:Lib/LightweightRingBuff.h **** 		/** Size of each ring buffer, in data elements - must be between 1 and 255. */
  47:Lib/LightweightRingBuff.h **** 		#define BUFFER_SIZE         128
  48:Lib/LightweightRingBuff.h **** 		
  49:Lib/LightweightRingBuff.h **** 		/** Maximum number of data elements to buffer before forcing a flush. 
  50:Lib/LightweightRingBuff.h **** 		 *  Must be less than BUFFER_SIZE
  51:Lib/LightweightRingBuff.h **** 		 */
  52:Lib/LightweightRingBuff.h **** 		#define BUFFER_NEARLY_FULL	96
  53:Lib/LightweightRingBuff.h **** 		
  54:Lib/LightweightRingBuff.h **** 		/** Type of data to store into the buffer. */
  55:Lib/LightweightRingBuff.h **** 		#define RingBuff_Data_t     uint8_t
  56:Lib/LightweightRingBuff.h **** 
  57:Lib/LightweightRingBuff.h **** 		/** Datatype which may be used to store the count of data stored in a buffer, retrieved
  58:Lib/LightweightRingBuff.h **** 		 *  via a call to \ref RingBuffer_GetCount().
  59:Lib/LightweightRingBuff.h **** 		 */
  60:Lib/LightweightRingBuff.h **** 		#if (BUFFER_SIZE <= 0xFF)
  61:Lib/LightweightRingBuff.h **** 			#define RingBuff_Count_t   uint8_t
  62:Lib/LightweightRingBuff.h **** 		#else
  63:Lib/LightweightRingBuff.h **** 			#define RingBuff_Count_t   uint16_t
  64:Lib/LightweightRingBuff.h **** 		#endif
  65:Lib/LightweightRingBuff.h **** 
  66:Lib/LightweightRingBuff.h **** 	/* Type Defines: */
  67:Lib/LightweightRingBuff.h **** 		/** Type define for a new ring buffer object. Buffers should be initialized via a call to
  68:Lib/LightweightRingBuff.h **** 		 *  \ref RingBuffer_InitBuffer() before use.
  69:Lib/LightweightRingBuff.h **** 		 */
  70:Lib/LightweightRingBuff.h **** 		typedef struct
  71:Lib/LightweightRingBuff.h **** 		{
  72:Lib/LightweightRingBuff.h **** 			RingBuff_Data_t  Buffer[BUFFER_SIZE]; /**< Internal ring buffer data, referenced by the buffer p
  73:Lib/LightweightRingBuff.h **** 			RingBuff_Data_t* In; /**< Current storage location in the circular buffer */
  74:Lib/LightweightRingBuff.h **** 			RingBuff_Data_t* Out; /**< Current retrieval location in the circular buffer */
  75:Lib/LightweightRingBuff.h **** 			RingBuff_Count_t Count;
  76:Lib/LightweightRingBuff.h **** 		} RingBuff_t;
  77:Lib/LightweightRingBuff.h **** 	
  78:Lib/LightweightRingBuff.h **** 	/* Inline Functions: */
  79:Lib/LightweightRingBuff.h **** 		/** Initializes a ring buffer ready for use. Buffers must be initialized via this function
  80:Lib/LightweightRingBuff.h **** 		 *  before any operations are called upon them. Already initialized buffers may be reset
  81:Lib/LightweightRingBuff.h **** 		 *  by re-initializing them using this function.
  82:Lib/LightweightRingBuff.h **** 		 *
  83:Lib/LightweightRingBuff.h **** 		 *  \param[out] Buffer  Pointer to a ring buffer structure to initialize
  84:Lib/LightweightRingBuff.h **** 		 */
  85:Lib/LightweightRingBuff.h **** 		static inline void RingBuffer_InitBuffer(RingBuff_t* const Buffer)
  86:Lib/LightweightRingBuff.h **** 		{
  87:Lib/LightweightRingBuff.h **** 			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
  88:Lib/LightweightRingBuff.h **** 			{
  89:Lib/LightweightRingBuff.h **** 				Buffer->In  = Buffer->Buffer;
  90:Lib/LightweightRingBuff.h **** 				Buffer->Out = Buffer->Buffer;
  91:Lib/LightweightRingBuff.h **** 			}
  92:Lib/LightweightRingBuff.h **** 		}
  93:Lib/LightweightRingBuff.h **** 		
  94:Lib/LightweightRingBuff.h **** 		/** Retrieves the minimum number of bytes stored in a particular buffer. This value is computed
  95:Lib/LightweightRingBuff.h **** 		 *  by entering an atomic lock on the buffer while the IN and OUT locations are fetched, so that
  96:Lib/LightweightRingBuff.h **** 		 *  the buffer cannot be modified while the computation takes place. This value should be cached
  97:Lib/LightweightRingBuff.h **** 		 *  when reading out the contents of the buffer, so that as small a time as possible is spent
  98:Lib/LightweightRingBuff.h **** 		 *  in an atomic lock.
  99:Lib/LightweightRingBuff.h **** 		 *
 100:Lib/LightweightRingBuff.h **** 		 *  \note The value returned by this function is guaranteed to only be the minimum number of byte
 101:Lib/LightweightRingBuff.h **** 		 *        stored in the given buffer; this value may change as other threads write new data and s
 102:Lib/LightweightRingBuff.h **** 		 *        the returned number should be used only to determine how many successive reads may safe
 103:Lib/LightweightRingBuff.h **** 		 *        be performed on the buffer.
 104:Lib/LightweightRingBuff.h **** 		 *
 105:Lib/LightweightRingBuff.h **** 		 *  \param[in] Buffer  Pointer to a ring buffer structure whose count is to be computed
 106:Lib/LightweightRingBuff.h **** 		 */
 107:Lib/LightweightRingBuff.h **** 		static inline RingBuff_Count_t RingBuffer_GetCount(RingBuff_t* const Buffer)
 108:Lib/LightweightRingBuff.h **** 		{
 109:Lib/LightweightRingBuff.h **** 			RingBuff_Count_t Count;
 110:Lib/LightweightRingBuff.h **** 			
 111:Lib/LightweightRingBuff.h **** 			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 112:Lib/LightweightRingBuff.h **** 			{
 113:Lib/LightweightRingBuff.h **** 				Count = Buffer->Count;
 114:Lib/LightweightRingBuff.h **** 			}
 115:Lib/LightweightRingBuff.h **** 			
 116:Lib/LightweightRingBuff.h **** 			return Count;
 117:Lib/LightweightRingBuff.h **** 		}
 118:Lib/LightweightRingBuff.h **** 		
 119:Lib/LightweightRingBuff.h **** 		/** Atomically determines if the specified ring buffer contains any free space. This should
 120:Lib/LightweightRingBuff.h **** 		 *  be tested before storing data to the buffer, to ensure that no data is lost due to a
 121:Lib/LightweightRingBuff.h **** 		 *  buffer overrun.
 122:Lib/LightweightRingBuff.h **** 		 *
 123:Lib/LightweightRingBuff.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into
 124:Lib/LightweightRingBuff.h **** 		 *
 125:Lib/LightweightRingBuff.h **** 		 *  \return Boolean true if the buffer contains no free space, false otherwise
 126:Lib/LightweightRingBuff.h **** 		 */		 
 127:Lib/LightweightRingBuff.h **** 		static inline bool RingBuffer_IsFull(RingBuff_t* const Buffer)
 128:Lib/LightweightRingBuff.h **** 		{
 129:Lib/LightweightRingBuff.h **** 			return (RingBuffer_GetCount(Buffer) == BUFFER_SIZE);
 130:Lib/LightweightRingBuff.h **** 		}
 131:Lib/LightweightRingBuff.h **** 
 132:Lib/LightweightRingBuff.h **** 		/** Atomically determines if the specified ring buffer contains any data. This should
 133:Lib/LightweightRingBuff.h **** 		 *  be tested before removing data from the buffer, to ensure that the buffer does not
 134:Lib/LightweightRingBuff.h **** 		 *  underflow.
 135:Lib/LightweightRingBuff.h **** 		 *
 136:Lib/LightweightRingBuff.h **** 		 *  If the data is to be removed in a loop, store the total number of bytes stored in the
 137:Lib/LightweightRingBuff.h **** 		 *  buffer (via a call to the \ref RingBuffer_GetCount() function) in a temporary variable
 138:Lib/LightweightRingBuff.h **** 		 *  to reduce the time spent in atomicity locks.
 139:Lib/LightweightRingBuff.h **** 		 *
 140:Lib/LightweightRingBuff.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into
 141:Lib/LightweightRingBuff.h **** 		 *
 142:Lib/LightweightRingBuff.h **** 		 *  \return Boolean true if the buffer contains no free space, false otherwise
 143:Lib/LightweightRingBuff.h **** 		 */		 
 144:Lib/LightweightRingBuff.h **** 		static inline bool RingBuffer_IsEmpty(RingBuff_t* const Buffer)
 145:Lib/LightweightRingBuff.h **** 		{
 146:Lib/LightweightRingBuff.h **** 			return (RingBuffer_GetCount(Buffer) == 0);
 147:Lib/LightweightRingBuff.h **** 		}
 148:Lib/LightweightRingBuff.h **** 
 149:Lib/LightweightRingBuff.h **** 		/** Inserts an element into the ring buffer.
 150:Lib/LightweightRingBuff.h **** 		 *
 151:Lib/LightweightRingBuff.h **** 		 *  \note Only one execution thread (main program thread or an ISR) may insert into a single buff
 152:Lib/LightweightRingBuff.h **** 		 *        otherwise data corruption may occur. Insertion and removal may occur from different exe
 153:Lib/LightweightRingBuff.h **** 		 *        threads.
 154:Lib/LightweightRingBuff.h **** 		 *
 155:Lib/LightweightRingBuff.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to insert into
 156:Lib/LightweightRingBuff.h **** 		 *  \param[in]     Data    Data element to insert into the buffer
 157:Lib/LightweightRingBuff.h **** 		 */
 158:Lib/LightweightRingBuff.h **** 		static inline void RingBuffer_Insert(RingBuff_t* const Buffer,
 159:Lib/LightweightRingBuff.h **** 		                                     const RingBuff_Data_t Data)
 160:Lib/LightweightRingBuff.h **** 		{
 161:Lib/LightweightRingBuff.h **** 			*Buffer->In = Data;
 162:Lib/LightweightRingBuff.h **** 			
 163:Lib/LightweightRingBuff.h **** 			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
 164:Lib/LightweightRingBuff.h **** 			  Buffer->In = Buffer->Buffer;
 165:Lib/LightweightRingBuff.h **** 
 166:Lib/LightweightRingBuff.h **** 			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 167:Lib/LightweightRingBuff.h **** 			{
 168:Lib/LightweightRingBuff.h **** 				Buffer->Count++;
 169:Lib/LightweightRingBuff.h **** 			}
 170:Lib/LightweightRingBuff.h **** 		}
 171:Lib/LightweightRingBuff.h **** 
 172:Lib/LightweightRingBuff.h **** 		/** Removes an element from the ring buffer.
 173:Lib/LightweightRingBuff.h **** 		 *
 174:Lib/LightweightRingBuff.h **** 		 *  \note Only one execution thread (main program thread or an ISR) may remove from a single buff
 175:Lib/LightweightRingBuff.h **** 		 *        otherwise data corruption may occur. Insertion and removal may occur from different exe
 176:Lib/LightweightRingBuff.h **** 		 *        threads.
 177:Lib/LightweightRingBuff.h **** 		 *
 178:Lib/LightweightRingBuff.h **** 		 *  \param[in,out] Buffer  Pointer to a ring buffer structure to retrieve from
 179:Lib/LightweightRingBuff.h **** 		 *
 180:Lib/LightweightRingBuff.h **** 		 *  \return Next data element stored in the buffer
 181:Lib/LightweightRingBuff.h **** 		 */
 182:Lib/LightweightRingBuff.h **** 		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
  40               		.loc 2 182 0
  41               		.cfi_startproc
  42               	/* prologue: function */
  43               	/* frame size = 0 */
  44               	/* stack size = 0 */
  45               	.L__stack_usage = 0
  46               	.LVL2:
 183:Lib/LightweightRingBuff.h **** 		{
 184:Lib/LightweightRingBuff.h **** 			RingBuff_Data_t Data = *Buffer->Out;
  47               		.loc 2 184 0
  48 0000 E091 0000 		lds r30,USARTtoUSB_Buffer+130
  49 0004 F091 0000 		lds r31,USARTtoUSB_Buffer+130+1
  50 0008 8191      		ld r24,Z+
  51               	.LVL3:
 185:Lib/LightweightRingBuff.h **** 			
 186:Lib/LightweightRingBuff.h **** 			if (++Buffer->Out == &Buffer->Buffer[BUFFER_SIZE])
  52               		.loc 2 186 0
  53 000a 90E0      		ldi r25,hi8(USARTtoUSB_Buffer+128)
  54 000c E030      		cpi r30,lo8(USARTtoUSB_Buffer+128)
  55 000e F907      		cpc r31,r25
  56 0010 01F0      		breq .L3
  57 0012 F093 0000 		sts USARTtoUSB_Buffer+130+1,r31
  58 0016 E093 0000 		sts USARTtoUSB_Buffer+130,r30
  59               	.L4:
  60               	.LBB103:
 187:Lib/LightweightRingBuff.h **** 			  Buffer->Out = Buffer->Buffer;
 188:Lib/LightweightRingBuff.h **** 
 189:Lib/LightweightRingBuff.h **** 			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
  61               		.loc 2 189 0
  62 001a 2FB7      		in r18,__SREG__
  63               	.LVL4:
  64               	.LBB104:
  65               	.LBB105:
  66               		.file 3 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h"
   1:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** /* Copyright (c) 2007 Dean Camera
   2:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****    All rights reserved.
   3:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
   4:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****    Redistribution and use in source and binary forms, with or without
   5:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****    modification, are permitted provided that the following conditions are met:
   6:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
   7:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****    * Redistributions of source code must retain the above copyright
   8:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer.
   9:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  10:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****    * Redistributions in binary form must reproduce the above copyright
  11:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****      notice, this list of conditions and the following disclaimer in
  12:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****      the documentation and/or other materials provided with the
  13:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****      distribution.
  14:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  15:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****    * Neither the name of the copyright holders nor the names of
  16:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****      contributors may be used to endorse or promote products derived
  17:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****      from this software without specific prior written permission.
  18:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  19:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  20:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  21:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  22:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  23:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  24:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  25:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  26:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  27:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  28:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  29:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****   POSSIBILITY OF SUCH DAMAGE.
  30:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** */
  31:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  32:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** /* $Id$ */
  33:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  34:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** #ifndef _UTIL_ATOMIC_H_
  35:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** #define _UTIL_ATOMIC_H_ 1
  36:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  37:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** #include <avr/io.h>
  38:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** #include <avr/interrupt.h>
  39:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  40:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** #if !defined(__DOXYGEN__)
  41:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** /* Internal helper functions. */
  42:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** static __inline__ uint8_t __iSeiRetVal(void)
  43:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** {
  44:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     sei();
  45:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     return 1;
  46:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** }
  47:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  48:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** static __inline__ uint8_t __iCliRetVal(void)
  49:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** {
  50:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     cli();
  67               		.loc 3 50 0
  68               	/* #APP */
  69               	 ;  50 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h" 1
  70 001c F894      		cli
  71               	 ;  0 "" 2
  72               	.LVL5:
  73               	/* #NOAPP */
  74               	.LBE105:
  75               	.LBE104:
 190:Lib/LightweightRingBuff.h **** 			{
 191:Lib/LightweightRingBuff.h **** 				Buffer->Count--;
  76               		.loc 2 191 0
  77 001e 9091 0000 		lds r25,USARTtoUSB_Buffer+132
  78 0022 9150      		subi r25,lo8(-(-1))
  79 0024 9093 0000 		sts USARTtoUSB_Buffer+132,r25
  80               	.LVL6:
  81               	.LBB106:
  82               	.LBB107:
  51:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     return 1;
  52:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** }
  53:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  54:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** static __inline__ void __iSeiParam(const uint8_t *__s)
  55:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** {
  56:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     sei();
  57:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  58:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     (void)__s;
  59:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** }
  60:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  61:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** static __inline__ void __iCliParam(const uint8_t *__s)
  62:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** {
  63:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     cli();
  64:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  65:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     (void)__s;
  66:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** }
  67:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** 
  68:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** static __inline__ void __iRestore(const  uint8_t *__s)
  69:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h **** {
  70:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     SREG = *__s;
  83               		.loc 3 70 0
  84 0028 2FBF      		out __SREG__,r18
  71:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
  85               		.loc 3 71 0
  86               	.LVL7:
  87               	/* epilogue start */
  88               	.LBE107:
  89               	.LBE106:
  90               	.LBE103:
 192:Lib/LightweightRingBuff.h **** 			}
 193:Lib/LightweightRingBuff.h **** 			
 194:Lib/LightweightRingBuff.h **** 			return Data;
 195:Lib/LightweightRingBuff.h **** 		}
  91               		.loc 2 195 0
  92 002a 0895      		ret
  93               	.LVL8:
  94               	.L3:
 187:Lib/LightweightRingBuff.h **** 
  95               		.loc 2 187 0
  96 002c 20E0      		ldi r18,lo8(USARTtoUSB_Buffer)
  97 002e 30E0      		ldi r19,hi8(USARTtoUSB_Buffer)
  98 0030 3093 0000 		sts USARTtoUSB_Buffer+130+1,r19
  99 0034 2093 0000 		sts USARTtoUSB_Buffer+130,r18
 100 0038 00C0      		rjmp .L4
 101               		.cfi_endproc
 102               	.LFE107:
 104               		.section	.text.SetupHardware,"ax",@progbits
 105               	.global	SetupHardware
 107               	SetupHardware:
 108               	.LFB89:
 109               		.file 4 "Arduino-serialusbkeyboard.c"
   1:Arduino-serialusbkeyboard.c **** /*
   2:Arduino-serialusbkeyboard.c ****              LUFA Library
   3:Arduino-serialusbkeyboard.c ****      Copyright (C) Dean Camera, 2010.
   4:Arduino-serialusbkeyboard.c ****               
   5:Arduino-serialusbkeyboard.c ****   dean [at] fourwalledcubicle [dot] com
   6:Arduino-serialusbkeyboard.c ****       www.fourwalledcubicle.com
   7:Arduino-serialusbkeyboard.c **** */
   8:Arduino-serialusbkeyboard.c **** 
   9:Arduino-serialusbkeyboard.c **** /*
  10:Arduino-serialusbkeyboard.c ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:Arduino-serialusbkeyboard.c **** 
  12:Arduino-serialusbkeyboard.c ****   Permission to use, copy, modify, distribute, and sell this 
  13:Arduino-serialusbkeyboard.c ****   software and its documentation for any purpose is hereby granted
  14:Arduino-serialusbkeyboard.c ****   without fee, provided that the above copyright notice appear in 
  15:Arduino-serialusbkeyboard.c ****   all copies and that both that the copyright notice and this
  16:Arduino-serialusbkeyboard.c ****   permission notice and warranty disclaimer appear in supporting 
  17:Arduino-serialusbkeyboard.c ****   documentation, and that the name of the author not be used in 
  18:Arduino-serialusbkeyboard.c ****   advertising or publicity pertaining to distribution of the 
  19:Arduino-serialusbkeyboard.c ****   software without specific, written prior permission.
  20:Arduino-serialusbkeyboard.c **** 
  21:Arduino-serialusbkeyboard.c ****   The author disclaim all warranties with regard to this
  22:Arduino-serialusbkeyboard.c ****   software, including all implied warranties of merchantability
  23:Arduino-serialusbkeyboard.c ****   and fitness.  In no event shall the author be liable for any
  24:Arduino-serialusbkeyboard.c ****   special, indirect or consequential damages or any damages
  25:Arduino-serialusbkeyboard.c ****   whatsoever resulting from loss of use, data or profits, whether
  26:Arduino-serialusbkeyboard.c ****   in an action of contract, negligence or other tortious action,
  27:Arduino-serialusbkeyboard.c ****   arising out of or in connection with the use or performance of
  28:Arduino-serialusbkeyboard.c ****   this software.
  29:Arduino-serialusbkeyboard.c **** */
  30:Arduino-serialusbkeyboard.c **** 
  31:Arduino-serialusbkeyboard.c **** /** \file
  32:Arduino-serialusbkeyboard.c ****  *
  33:Arduino-serialusbkeyboard.c ****  *  Main source file for the Arduino-usbserial project. This file contains the main tasks of
  34:Arduino-serialusbkeyboard.c ****  *  the project and is responsible for the initial application hardware configuration.
  35:Arduino-serialusbkeyboard.c ****  */
  36:Arduino-serialusbkeyboard.c **** 
  37:Arduino-serialusbkeyboard.c **** #include "Arduino-serialusbkeyboard.h"
  38:Arduino-serialusbkeyboard.c **** 
  39:Arduino-serialusbkeyboard.c **** /** Circular buffer to hold data from the host before it is sent to the device via the serial port.
  40:Arduino-serialusbkeyboard.c **** // RingBuff_t USBtoUSART_Buffer;
  41:Arduino-serialusbkeyboard.c **** 
  42:Arduino-serialusbkeyboard.c **** /** Circular buffer to hold data from the serial port before it is sent to the host. */
  43:Arduino-serialusbkeyboard.c **** RingBuff_t USARTtoUSB_Buffer;
  44:Arduino-serialusbkeyboard.c **** 
  45:Arduino-serialusbkeyboard.c **** /** Pulse generation counters to keep track of the number of milliseconds remaining for each pulse 
  46:Arduino-serialusbkeyboard.c **** // volatile struct
  47:Arduino-serialusbkeyboard.c **** // {
  48:Arduino-serialusbkeyboard.c **** // 	uint8_t TxLEDPulse; /**< Milliseconds remaining for data Tx LED pulse */
  49:Arduino-serialusbkeyboard.c **** // 	uint8_t RxLEDPulse; *< Milliseconds remaining for data Rx LED pulse 
  50:Arduino-serialusbkeyboard.c **** // 	uint8_t PingPongLEDPulse; /**< Milliseconds remaining for enumeration Tx/Rx ping-pong LED pulse
  51:Arduino-serialusbkeyboard.c **** // } PulseMSRemaining;
  52:Arduino-serialusbkeyboard.c **** 
  53:Arduino-serialusbkeyboard.c **** /** LUFA CDC Class driver interface configuration and state information. This structure is
  54:Arduino-serialusbkeyboard.c ****  *  passed to all CDC Class driver functions, so that multiple instances of the same class
  55:Arduino-serialusbkeyboard.c ****  *  within a device can be differentiated from one another.
  56:Arduino-serialusbkeyboard.c ****  */
  57:Arduino-serialusbkeyboard.c **** // USB_ClassInfo_CDC_Device_t VirtualSerial_CDC_Interface =
  58:Arduino-serialusbkeyboard.c **** // 	{
  59:Arduino-serialusbkeyboard.c **** // 		.Config = 
  60:Arduino-serialusbkeyboard.c **** // 			{
  61:Arduino-serialusbkeyboard.c **** // 				.ControlInterfaceNumber         = 0,
  62:Arduino-serialusbkeyboard.c **** 
  63:Arduino-serialusbkeyboard.c **** // 				.DataINEndpointNumber           = CDC_TX_EPNUM,
  64:Arduino-serialusbkeyboard.c **** // 				.DataINEndpointSize             = CDC_TXRX_EPSIZE,
  65:Arduino-serialusbkeyboard.c **** // 				.DataINEndpointDoubleBank       = false,
  66:Arduino-serialusbkeyboard.c **** 
  67:Arduino-serialusbkeyboard.c **** // 				.DataOUTEndpointNumber          = CDC_RX_EPNUM,
  68:Arduino-serialusbkeyboard.c **** // 				.DataOUTEndpointSize            = CDC_TXRX_EPSIZE,
  69:Arduino-serialusbkeyboard.c **** // 				.DataOUTEndpointDoubleBank      = false,
  70:Arduino-serialusbkeyboard.c **** 
  71:Arduino-serialusbkeyboard.c **** // 				.NotificationEndpointNumber     = CDC_NOTIFICATION_EPNUM,
  72:Arduino-serialusbkeyboard.c **** // 				.NotificationEndpointSize       = CDC_NOTIFICATION_EPSIZE,
  73:Arduino-serialusbkeyboard.c **** // 				.NotificationEndpointDoubleBank = false,
  74:Arduino-serialusbkeyboard.c **** // 			},
  75:Arduino-serialusbkeyboard.c **** // 	};
  76:Arduino-serialusbkeyboard.c **** 
  77:Arduino-serialusbkeyboard.c **** /** Indicates what report mode the host has requested, true for normal HID reporting mode, false fo
  78:Arduino-serialusbkeyboard.c ****  *  protocol reporting mode.
  79:Arduino-serialusbkeyboard.c ****  */
  80:Arduino-serialusbkeyboard.c **** bool UsingReportProtocol = true;
  81:Arduino-serialusbkeyboard.c **** 
  82:Arduino-serialusbkeyboard.c **** /** Current Idle period. This is set by the host via a Set Idle HID class request to silence the de
  83:Arduino-serialusbkeyboard.c ****  *  for either the entire idle duration, or until the report status changes (e.g. the user presses 
  84:Arduino-serialusbkeyboard.c ****  */
  85:Arduino-serialusbkeyboard.c **** uint16_t IdleCount = 500;
  86:Arduino-serialusbkeyboard.c **** 
  87:Arduino-serialusbkeyboard.c **** /** Current Idle period remaining. When the IdleCount value is set, this tracks the remaining numbe
  88:Arduino-serialusbkeyboard.c ****  *  milliseconds. This is separate to the IdleCount timer and is incremented and compared as the ho
  89:Arduino-serialusbkeyboard.c ****  *  the current idle period via a Get Idle HID class request, thus its value must be preserved.
  90:Arduino-serialusbkeyboard.c ****  */
  91:Arduino-serialusbkeyboard.c **** uint16_t IdleMSRemaining = 0;
  92:Arduino-serialusbkeyboard.c **** 
  93:Arduino-serialusbkeyboard.c **** uint8_t scancode_buffer[256] = {0};
  94:Arduino-serialusbkeyboard.c **** 
  95:Arduino-serialusbkeyboard.c **** uint8_t header, scancode, press_release;
  96:Arduino-serialusbkeyboard.c **** 
  97:Arduino-serialusbkeyboard.c **** /** Main program entry point. This routine contains the overall program flow, including initial
  98:Arduino-serialusbkeyboard.c ****  *  setup of all components and the main program loop.
  99:Arduino-serialusbkeyboard.c ****  */
 100:Arduino-serialusbkeyboard.c **** int main(void)
 101:Arduino-serialusbkeyboard.c **** {
 102:Arduino-serialusbkeyboard.c **** 	SetupHardware();
 103:Arduino-serialusbkeyboard.c **** 	
 104:Arduino-serialusbkeyboard.c **** 	// RingBuffer_InitBuffer(&USBtoUSART_Buffer);
 105:Arduino-serialusbkeyboard.c **** 	RingBuffer_InitBuffer(&USARTtoUSB_Buffer);
 106:Arduino-serialusbkeyboard.c **** 
 107:Arduino-serialusbkeyboard.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
 108:Arduino-serialusbkeyboard.c **** 	sei();
 109:Arduino-serialusbkeyboard.c **** 
 110:Arduino-serialusbkeyboard.c **** 	for (;;)
 111:Arduino-serialusbkeyboard.c **** 	{
 112:Arduino-serialusbkeyboard.c **** 		/* Only try to read in bytes from the CDC interface if the transmit buffer is not full */
 113:Arduino-serialusbkeyboard.c **** 		// if (!(RingBuffer_IsFull(&USBtoUSART_Buffer)))
 114:Arduino-serialusbkeyboard.c **** 		// {
 115:Arduino-serialusbkeyboard.c **** 		// 	int16_t ReceivedByte = CDC_Device_ReceiveByte(&VirtualSerial_CDC_Interface);
 116:Arduino-serialusbkeyboard.c **** 
 117:Arduino-serialusbkeyboard.c **** 		// 	 Read bytes from the USB OUT endpoint into the USART transmit buffer 
 118:Arduino-serialusbkeyboard.c **** 		// 	if (!(ReceivedByte < 0))
 119:Arduino-serialusbkeyboard.c **** 		// 	  RingBuffer_Insert(&USBtoUSART_Buffer, ReceivedByte);
 120:Arduino-serialusbkeyboard.c **** 		// }
 121:Arduino-serialusbkeyboard.c **** 		
 122:Arduino-serialusbkeyboard.c **** 		/* Check if the UART receive buffer flush timer has expired or the buffer is nearly full */
 123:Arduino-serialusbkeyboard.c **** 		// RingBuff_Count_t BufferCount = RingBuffer_GetCount(&USARTtoUSB_Buffer);
 124:Arduino-serialusbkeyboard.c **** 		// if ((TIFR0 & (1 << TOV0)) || (BufferCount > BUFFER_NEARLY_FULL))
 125:Arduino-serialusbkeyboard.c **** 		// {
 126:Arduino-serialusbkeyboard.c **** 		// 	TIFR0 |= (1 << TOV0);
 127:Arduino-serialusbkeyboard.c **** 
 128:Arduino-serialusbkeyboard.c **** 		// 	// if (USARTtoUSB_Buffer.Count) {
 129:Arduino-serialusbkeyboard.c **** 		// 	// 	LEDs_TurnOnLEDs(LEDMASK_TX);
 130:Arduino-serialusbkeyboard.c **** 		// 	// 	PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;
 131:Arduino-serialusbkeyboard.c **** 		// 	// }
 132:Arduino-serialusbkeyboard.c **** 
 133:Arduino-serialusbkeyboard.c **** 		// 	/* Read bytes from the USART receive buffer into the USB IN endpoint */
 134:Arduino-serialusbkeyboard.c **** 		// 	while (BufferCount--)
 135:Arduino-serialusbkeyboard.c **** 		// 	  // CDC_Device_SendByte(&VirtualSerial_CDC_Interface, RingBuffer_Remove(&USARTtoUSB_Buffer))
 136:Arduino-serialusbkeyboard.c **** 			  
 137:Arduino-serialusbkeyboard.c **** 		// 	/* Turn off TX LED(s) once the TX pulse period has elapsed */
 138:Arduino-serialusbkeyboard.c **** 		// 	if (PulseMSRemaining.TxLEDPulse && !(--PulseMSRemaining.TxLEDPulse))
 139:Arduino-serialusbkeyboard.c **** 		// 	  LEDs_TurnOffLEDs(LEDMASK_TX);
 140:Arduino-serialusbkeyboard.c **** 
 141:Arduino-serialusbkeyboard.c **** 		// 	/* Turn off RX LED(s) once the RX pulse period has elapsed */
 142:Arduino-serialusbkeyboard.c **** 		// 	if (PulseMSRemaining.RxLEDPulse && !(--PulseMSRemaining.RxLEDPulse))
 143:Arduino-serialusbkeyboard.c **** 		// 	  LEDs_TurnOffLEDs(LEDMASK_RX);
 144:Arduino-serialusbkeyboard.c **** 		// }
 145:Arduino-serialusbkeyboard.c **** 		
 146:Arduino-serialusbkeyboard.c **** 		/* Load the next byte from the USART transmit buffer into the USART */
 147:Arduino-serialusbkeyboard.c **** 		// if (!(RingBuffer_IsEmpty(&USBtoUSART_Buffer))) {
 148:Arduino-serialusbkeyboard.c **** 		//   Serial_TxByte(RingBuffer_Remove(&USBtoUSART_Buffer));
 149:Arduino-serialusbkeyboard.c **** 		  	
 150:Arduino-serialusbkeyboard.c **** 		//   	LEDs_TurnOnLEDs(LEDMASK_RX);
 151:Arduino-serialusbkeyboard.c **** 		// 	PulseMSRemaining.RxLEDPulse = TX_RX_LED_PULSE_MS;
 152:Arduino-serialusbkeyboard.c **** 		// }
 153:Arduino-serialusbkeyboard.c **** 		
 154:Arduino-serialusbkeyboard.c **** 		// CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
 155:Arduino-serialusbkeyboard.c **** 		// USB_USBTask();
 156:Arduino-serialusbkeyboard.c ****     RingBuff_Count_t BufferCount = RingBuffer_GetCount(&USARTtoUSB_Buffer);
 157:Arduino-serialusbkeyboard.c ****     
 158:Arduino-serialusbkeyboard.c ****     // if ((TIFR0 & (1 << TOV0)) || (BufferCount > BUFFER_NEARLY_FULL))
 159:Arduino-serialusbkeyboard.c ****     // {
 160:Arduino-serialusbkeyboard.c ****     //         TIFR0 |= (1 << TOV0);
 161:Arduino-serialusbkeyboard.c ****     if (BufferCount > BUFFER_NEARLY_FULL) {
 162:Arduino-serialusbkeyboard.c ****         while(BufferCount--)
 163:Arduino-serialusbkeyboard.c ****             header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 164:Arduino-serialusbkeyboard.c ****     }
 165:Arduino-serialusbkeyboard.c ****         while(BufferCount > 2) {
 166:Arduino-serialusbkeyboard.c ****             if (BufferCount--) {
 167:Arduino-serialusbkeyboard.c ****                 header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 168:Arduino-serialusbkeyboard.c ****                 if(header == 0x00) {
 169:Arduino-serialusbkeyboard.c ****                     if (BufferCount--) {
 170:Arduino-serialusbkeyboard.c ****                         scancode = RingBuffer_Remove(&USARTtoUSB_Buffer);
 171:Arduino-serialusbkeyboard.c ****                     }
 172:Arduino-serialusbkeyboard.c ****                     if (BufferCount--) {
 173:Arduino-serialusbkeyboard.c ****                         press_release = RingBuffer_Remove(&USARTtoUSB_Buffer);
 174:Arduino-serialusbkeyboard.c ****                     }
 175:Arduino-serialusbkeyboard.c ****                     scancode_buffer[scancode] = press_release;
 176:Arduino-serialusbkeyboard.c ****                 }
 177:Arduino-serialusbkeyboard.c ****             }
 178:Arduino-serialusbkeyboard.c ****         }   
 179:Arduino-serialusbkeyboard.c ****     // }
 180:Arduino-serialusbkeyboard.c **** 
 181:Arduino-serialusbkeyboard.c **** 		HID_Task();
 182:Arduino-serialusbkeyboard.c **** 		USB_USBTask();
 183:Arduino-serialusbkeyboard.c **** 
 184:Arduino-serialusbkeyboard.c **** 	}
 185:Arduino-serialusbkeyboard.c **** }
 186:Arduino-serialusbkeyboard.c **** 
 187:Arduino-serialusbkeyboard.c **** /** Configures the board hardware and chip peripherals for the demo's functionality. */
 188:Arduino-serialusbkeyboard.c **** void SetupHardware(void)
 189:Arduino-serialusbkeyboard.c **** {
 110               		.loc 4 189 0
 111               		.cfi_startproc
 112 0000 CF93      		push r28
 113               	.LCFI0:
 114               		.cfi_def_cfa_offset 3
 115               		.cfi_offset 28, -2
 116 0002 DF93      		push r29
 117               	.LCFI1:
 118               		.cfi_def_cfa_offset 4
 119               		.cfi_offset 29, -3
 120               	/* prologue: function */
 121               	/* frame size = 0 */
 122               	/* stack size = 2 */
 123               	.L__stack_usage = 2
 190:Arduino-serialusbkeyboard.c **** 	/* Disable watchdog if enabled by bootloader/fuses */
 191:Arduino-serialusbkeyboard.c **** 	MCUSR &= ~(1 << WDRF);
 124               		.loc 4 191 0
 125 0004 84B7      		in r24,0x34
 126 0006 877F      		andi r24,lo8(-9)
 127 0008 84BF      		out 0x34,r24
 128               	.LBB114:
 129               	.LBB115:
 130               		.file 5 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h"
   1:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /* Copyright (c) 2002, 2004 Marek Michalkiewicz
   2:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    Copyright (c) 2005, 2006, 2007 Eric B. Weddington
   3:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    All rights reserved.
   4:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
   5:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    Redistribution and use in source and binary forms, with or without
   6:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    modification, are permitted provided that the following conditions are met:
   7:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
   8:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    * Redistributions of source code must retain the above copyright
   9:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer.
  10:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  11:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    * Redistributions in binary form must reproduce the above copyright
  12:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****      notice, this list of conditions and the following disclaimer in
  13:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****      the documentation and/or other materials provided with the
  14:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****      distribution.
  15:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  16:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    * Neither the name of the copyright holders nor the names of
  17:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****      contributors may be used to endorse or promote products derived
  18:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****      from this software without specific prior written permission.
  19:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  20:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  21:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  22:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  23:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  24:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  25:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  26:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  27:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  28:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  29:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  30:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****   POSSIBILITY OF SUCH DAMAGE. */
  31:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  32:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /* $Id$ */
  33:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  34:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /*
  35:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    avr/wdt.h - macros for AVR watchdog timer
  36:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****  */
  37:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  38:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #ifndef _AVR_WDT_H_
  39:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define _AVR_WDT_H_
  40:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  41:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #include <avr/io.h>
  42:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #include <stdint.h>
  43:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  44:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /** \file */
  45:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /** \defgroup avr_watchdog <avr/wdt.h>: Watchdog timer handling
  46:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     \code #include <avr/wdt.h> \endcode
  47:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  48:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     This header file declares the interface to some inline macros
  49:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     handling the watchdog timer present in many AVR devices.  In order
  50:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     to prevent the watchdog timer configuration from being
  51:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     accidentally altered by a crashing application, a special timed
  52:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     sequence is required in order to change it.  The macros within
  53:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     this header file handle the required sequence automatically
  54:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     before changing any value.  Interrupts will be disabled during
  55:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     the manipulation.
  56:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  57:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     \note Depending on the fuse configuration of the particular
  58:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     device, further restrictions might apply, in particular it might
  59:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     be disallowed to turn off the watchdog timer.
  60:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  61:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     Note that for newer devices (ATmega88 and newer, effectively any
  62:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     AVR that has the option to also generate interrupts), the watchdog
  63:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     timer remains active even after a system reset (except a power-on
  64:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     condition), using the fastest prescaler value (approximately 15
  65:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     ms).  It is therefore required to turn off the watchdog early
  66:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     during program startup, the datasheet recommends a sequence like
  67:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     the following:
  68:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  69:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     \code
  70:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     #include <stdint.h>
  71:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     #include <avr/wdt.h>
  72:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  73:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     uint8_t mcusr_mirror __attribute__ ((section (".noinit")));
  74:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  75:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     void get_mcusr(void) \
  76:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       __attribute__((naked)) \
  77:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       __attribute__((section(".init3")));
  78:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     void get_mcusr(void)
  79:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     {
  80:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       mcusr_mirror = MCUSR;
  81:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       MCUSR = 0;
  82:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       wdt_disable();
  83:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     }
  84:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     \endcode
  85:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  86:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     Saving the value of MCUSR in \c mcusr_mirror is only needed if the
  87:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     application later wants to examine the reset source, but in particular, 
  88:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     clearing the watchdog reset flag before disabling the
  89:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     watchdog is required, according to the datasheet.
  90:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** */
  91:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  92:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /**
  93:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
  94:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    Reset the watchdog timer.  When the watchdog timer is enabled,
  95:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    a call to this instruction is required before the timer expires,
  96:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    otherwise a watchdog-initiated device reset will occur. 
  97:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** */
  98:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
  99:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_reset() __asm__ __volatile__ ("wdr")
 100:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 101:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #ifndef __DOXYGEN__
 102:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 103:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #if defined(WDP3)
 104:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       _BV(WDP3)
 105:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #else
 106:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** # define _WD_PS3_MASK       0x00
 107:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #endif
 108:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 109:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #if defined(WDTCSR)
 110:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCSR
 111:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #elif defined(WDTCR)
 112:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDTCR
 113:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #else
 114:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #  define _WD_CONTROL_REG     WDT
 115:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #endif
 116:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 117:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #if defined(WDTOE)
 118:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDTOE
 119:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #else
 120:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define _WD_CHANGE_BIT      WDCE
 121:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #endif
 122:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 123:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #endif	/* !__DOXYGEN__ */
 124:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 125:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 126:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /**
 127:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    \ingroup avr_watchdog
 128:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    Enable the watchdog timer, configuring it for expiry after
 129:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    \c timeout (which is a combination of the \c WDP0 through
 130:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    \c WDP2 bits to write into the \c WDTCR register; For those devices 
 131:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    that have a \c WDTCSR register, it uses the combination of the \c WDP0 
 132:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    through \c WDP3 bits).
 133:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 134:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    See also the symbolic constants \c WDTO_15MS et al.
 135:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** */
 136:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 137:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 138:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #if defined(__AVR_XMEGA__)
 139:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 140:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #if defined (WDT_CTRLA) && !defined(RAMPD)
 141:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 142:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 143:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** do { \
 144:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** uint8_t temp; \
 145:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 146:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"wdr"									"\n\t" \
 147:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]"		"\n\t" \
 148:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"				"\n\t" \
 149:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"sbr %[tmp], %[wdt_enable_timeout]"		"\n\t" \
 150:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"				"\n\t" \
 151:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"1:lds %[tmp], %[wdt_status_reg]"		"\n\t" \
 152:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"sbrc %[tmp], %[wdt_syncbusy_bit]"		"\n\t" \
 153:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"rjmp 1b"								"\n\t" \
 154:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	: [tmp]					"=r" (temp) \
 155:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	: [ccp_reg]				"I"  (_SFR_IO_ADDR(CCP)), \
 156:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	  [ioreg_cen_mask]		"r"  ((uint8_t)CCP_IOREG_gc), \
 157:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	  [wdt_reg]				"n"  (_SFR_MEM_ADDR(WDT_CTRLA)), \
 158:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	  [wdt_enable_timeout]	"M"  (timeout), \
 159:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	  [wdt_status_reg]		"n"  (_SFR_MEM_ADDR(WDT_STATUS)), \
 160:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	  [wdt_syncbusy_bit]	"I"  (WDT_SYNCBUSY_bm) \
 161:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ); \
 162:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** } while(0)
 163:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 164:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_disable() \
 165:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** do { \
 166:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** uint8_t temp; \
 167:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 168:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"wdr"								"\n\t" \
 169:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 170:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"lds %[tmp], %[wdt_reg]"			"\n\t" \
 171:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"cbr %[tmp], %[timeout_mask]"       "\n\t" \
 172:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	"sts %[wdt_reg], %[tmp]"			"\n\t" \
 173:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [tmp]            "=r" (temp) \
 174:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [ccp_reg]        "I" (_SFR_IO_ADDR(CCP)),       \
 175:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [ioreg_cen_mask] "r" ((uint8_t)CCP_IOREG_gc),   \
 176:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [wdt_reg]        "n" (_SFR_MEM_ADDR(WDT_CTRLA)),\
 177:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [timeout_mask]   "I" (WDT_PERIOD_gm) \
 178:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ); \
 179:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** } while(0)
 180:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 181:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #else // defined (WDT_CTRLA) && !defined(RAMPD)
 182:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 183:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** /*
 184:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    wdt_enable(timeout) for xmega devices
 185:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ** write signature (CCP_IOREG_gc) that enables change of protected I/O
 186:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    registers to the CCP register
 187:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ** At the same time,
 188:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    1) set WDT change enable (WDT_CEN_bm)
 189:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    2) enable WDT (WDT_ENABLE_bm)
 190:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    3) set timeout (timeout)
 191:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ** Synchronization starts when ENABLE bit of WDT is set. So, wait till it
 192:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    finishes (SYNCBUSY of STATUS register is automatically cleared after the
 193:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****    sync is finished).
 194:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** */
 195:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_enable(timeout) \
 196:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** do { \
 197:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** uint8_t temp; \
 198:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __asm__ __volatile__ (         \
 199:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"              "\n\t" \
 200:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"            "\n\t" \
 201:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]"     "\n\t" \
 202:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[wdt_enable_timeout]" "\n\t" \
 203:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "1:lds %[tmp], %[wdt_status_reg]"       "\n\t" \
 204:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "sbrc %[tmp], %[wdt_syncbusy_bit]"      "\n\t" \
 205:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "rjmp 1b"                               "\n\t" \
 206:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"             "\n\t" \
 207:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [tmp]                "=r" (temp) \
 208:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [rampd]              "I" (_SFR_IO_ADDR(RAMPD)),      \
 209:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [ccp_reg]            "I" (_SFR_IO_ADDR(CCP)),        \
 210:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]     "r" ((uint8_t)CCP_IOREG_gc),     \
 211:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [wdt_reg]            "n" (_SFR_MEM_ADDR(WDT_CTRL)),   \
 212:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [wdt_enable_timeout] "r" ((uint8_t)(WDT_CEN_bm | WDT_ENABLE_bm | timeout)), \
 213:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [wdt_status_reg]     "n" (_SFR_MEM_ADDR(WDT_STATUS)), \
 214:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [wdt_syncbusy_bit]   "I" (WDT_SYNCBUSY_bm)            \
 215:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : "r0" \
 216:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ); \
 217:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** } while(0)
 218:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 219:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_disable() \
 220:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __asm__ __volatile__ (  \
 221:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "in __tmp_reg__, %[rampd]"          "\n\t" \
 222:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[rampd], __zero_reg__"        "\n\t" \
 223:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[ccp_reg], %[ioreg_cen_mask]" "\n\t" \
 224:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "sts %[wdt_reg], %[disable_mask]"   "\n\t" \
 225:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[rampd], __tmp_reg__"         "\n\t" \
 226:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : \
 227:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [rampd]             "I" (_SFR_IO_ADDR(RAMPD)),    \
 228:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [ccp_reg]           "I" (_SFR_IO_ADDR(CCP)),      \
 229:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [ioreg_cen_mask]    "r" ((uint8_t)CCP_IOREG_gc),   \
 230:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [wdt_reg]           "n" (_SFR_MEM_ADDR(WDT_CTRL)), \
 231:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [disable_mask]      "r" ((uint8_t)((~WDT_ENABLE_bm) | WDT_CEN_bm)) \
 232:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : "r0" \
 233:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** );
 234:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 235:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #endif // defined (WDT_CTRLA) && !defined(RAMPD)
 236:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 237:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #elif defined(__AVR_TINY__)
 238:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 239:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_enable(value) \
 240:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 241:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 242:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 243:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 244:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 245:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[WDVALUE]" "\n\t"  \
 246:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t"  \
 247:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : /* no outputs */  \
 248:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),  \
 249:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 250:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 251:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00) \
 252:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       | _BV(WDE) | (value & 0x07) )) \
 253:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : "r16" \
 254:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** )
 255:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 256:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #define wdt_disable() \
 257:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** do { \
 258:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** uint8_t temp_wd; \
 259:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __asm__ __volatile__ ( \
 260:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "in __tmp_reg__,__SREG__" "\n\t"  \
 261:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "cli" "\n\t"  \
 262:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "wdr" "\n\t"  \
 263:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[CCPADDRESS],%[SIGNATURE]" "\n\t"  \
 264:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "in  %[TEMP_WD],%[WDTREG]" "\n\t" \
 265:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "cbr %[TEMP_WD],%[WDVALUE]" "\n\t" \
 266:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out %[WDTREG],%[TEMP_WD]" "\n\t" \
 267:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     "out __SREG__,__tmp_reg__" "\n\t" \
 268:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : /*no output */ \
 269:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)), \
 270:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [SIGNATURE] "r" ((uint8_t)0xD8), \
 271:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)), \
 272:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [TEMP_WD] "d" (temp_wd), \
 273:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****       [WDVALUE] "n" (1 << WDE) \
 274:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****     : "r16" \
 275:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** ); \
 276:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** }while(0)
 277:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 278:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #elif defined(CCP)
 279:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 280:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** static __inline__
 281:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 282:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 283:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** {
 284:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 285:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 286:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 287:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 288:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 289:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 290:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 291:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 292:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 293:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: /* no outputs */
 294:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 295:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 296:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 297:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 298:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 299:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: "r0"
 300:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			);
 301:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 302:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P (_WD_CONTROL_REG))
 303:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 304:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 305:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 306:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 307:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 308:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 309:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 310:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 311:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: /* no outputs */
 312:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 313:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 314:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 315:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 316:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 317:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: "r0"
 318:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			);
 319:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 320:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P (_WD_CONTROL_REG))
 321:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 322:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 323:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 324:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 325:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 326:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 327:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"sts %[WDTREG],%[WDVALUE]" "\n\t"
 328:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 329:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: /* no outputs */
 330:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 331:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 332:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 333:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 334:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 335:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: "r0"
 336:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			);
 337:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 338:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else
 339:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****  	{
 340:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 341:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"in __tmp_reg__,__SREG__" "\n\t"
 342:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"cli" "\n\t"
 343:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"wdr" "\n\t"
 344:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 345:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out %[WDTREG],%[WDVALUE]" "\n\t"
 346:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			"out __SREG__,__tmp_reg__" "\n\t"
 347:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: /* no outputs */
 348:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 349:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[SIGNATURE] "r" ((uint8_t)0xD8),
 350:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 351:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			[WDVALUE] "r" ((uint8_t)((value & 0x08 ? _WD_PS3_MASK : 0x00)
 352:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				| _BV(WDE) | (value & 0x07) ))
 353:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			: "r0"
 354:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 			);
 355:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 356:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** }
 357:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 358:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** static __inline__
 359:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 360:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** void wdt_disable (void)
 361:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** {
 362:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	if (!_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 363:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 364:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 365:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 366:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 367:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 368:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 369:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 370:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 371:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 372:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 373:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 374:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: /*no output */
 375:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 376:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 377:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 378:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 379:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 380:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 381:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				);
 382:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 383:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else if (!_SFR_IO_REG_P (CCP) && _SFR_IO_REG_P(_WD_CONTROL_REG))
 384:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 385:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 386:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 387:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 388:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 389:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 390:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"sts %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 391:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 392:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 393:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 394:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 395:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: /*no output */
 396:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "n" (_SFR_MEM_ADDR(CCP)),
 397:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 398:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 399:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 400:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 401:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 402:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				);
 403:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 404:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else if (_SFR_IO_REG_P (CCP) && !_SFR_IO_REG_P(_WD_CONTROL_REG))
 405:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 406:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 407:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 408:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 409:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 410:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 411:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 412:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"lds %[TEMP_WD],%[WDTREG]" "\n\t"
 413:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 414:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"sts %[WDTREG],%[TEMP_WD]" "\n\t"
 415:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 416:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: /*no output */
 417:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 418:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 419:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDTREG] "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 420:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 421:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 422:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 423:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				);
 424:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 425:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else
 426:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 427:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         uint8_t temp_wd;
 428:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         __asm__ __volatile__ (
 429:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 430:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 431:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 432:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %[CCPADDRESS],%[SIGNATURE]" "\n\t"
 433:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in %[TEMP_WD],%[WDTREG]" "\n\t"
 434:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cbr %[TEMP_WD],%[WDVALUE]" "\n\t"
 435:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMP_WD]" "\n\t"
 436:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 437:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: /*no output */
 438:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: [CCPADDRESS] "I" (_SFR_IO_ADDR(CCP)),
 439:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[SIGNATURE] "r" ((uint8_t)0xD8),
 440:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDTREG] "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 441:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[TEMP_WD] "d" (temp_wd),
 442:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDVALUE] "n" (1 << WDE)
 443:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 444:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				);
 445:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 446:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** }
 447:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 448:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** #else
 449:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 450:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** static __inline__
 451:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 452:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** void wdt_enable (const uint8_t value)
 453:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** {
 454:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 455:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 456:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 457:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 458:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 459:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 460:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %0, %1" "\n\t"
 461:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 462:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %0, %2" "\n \t"
 463:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: /* no outputs */
 464:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "I" (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 465:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 466:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 467:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 468:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 469:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		);
 470:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 471:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else
 472:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 473:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 474:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__" "\n\t"
 475:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli" "\n\t"
 476:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr" "\n\t"
 477:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"sts %0, %1" "\n\t"
 478:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__" "\n\t"
 479:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"sts %0, %2" "\n \t"
 480:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: /* no outputs */
 481:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "n" (_SFR_MEM_ADDR(_WD_CONTROL_REG)),
 482:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"r" ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE))),
 483:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"r" ((uint8_t) ((value & 0x08 ? _WD_PS3_MASK : 0x00) |
 484:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 						_BV(WDE) | (value & 0x07)) )
 485:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 486:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		);
 487:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 488:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** }
 489:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 
 490:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** static __inline__
 491:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** __attribute__ ((__always_inline__))
 492:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** void wdt_disable (void)
 493:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** {
 494:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	if (_SFR_IO_REG_P (_WD_CONTROL_REG))
 495:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 496:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 497:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 498:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in __tmp_reg__,__SREG__"    "\n\t"
 499:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"cli"                        "\n\t"
 500:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"wdr"                        "\n\t"
 501:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"in  %[TEMPREG],%[WDTREG]"   "\n\t"
 502:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"ori %[TEMPREG],%[WDCE_WDE]" "\n\t"
 503:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %[WDTREG],%[TEMPREG]"   "\n\t"
 504:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out %[WDTREG],__zero_reg__" "\n\t"
 505:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				"out __SREG__,__tmp_reg__"   "\n\t"
 506:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: [TEMPREG] "=d" (temp_reg)
 507:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: [WDTREG]  "I"  (_SFR_IO_ADDR(_WD_CONTROL_REG)),
 508:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				[WDCE_WDE]  "n"  ((uint8_t)(_BV(_WD_CHANGE_BIT) | _BV(WDE)))
 509:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 				: "r0"
 510:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		);
 511:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	}
 512:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	else
 513:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 	{
 514:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h ****         uint8_t register temp_reg;
 515:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h **** 		__asm__ __volatile__ (
 131               		.loc 5 515 0
 132               	/* #APP */
 133               	 ;  515 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/avr/wdt.h" 1
 134 000a 0FB6      		in __tmp_reg__,__SREG__
 135 000c F894      		cli
 136 000e A895      		wdr
 137 0010 8091 6000 		lds r24,96
 138 0014 8861      		ori r24,24
 139 0016 8093 6000 		sts 96,r24
 140 001a 1092 6000 		sts 96,__zero_reg__
 141 001e 0FBE      		out __SREG__,__tmp_reg__
 142               		
 143               	 ;  0 "" 2
 144               	.LVL9:
 145               	/* #NOAPP */
 146               	.LBE115:
 147               	.LBE114:
 148               	.LBB116:
 149               	.LBB117:
 150               		.file 6 "../../LUFA/Drivers/Peripheral/Serial.h"
   1:../../LUFA/Drivers/Peripheral/Serial.h **** /*
   2:../../LUFA/Drivers/Peripheral/Serial.h ****              LUFA Library
   3:../../LUFA/Drivers/Peripheral/Serial.h ****      Copyright (C) Dean Camera, 2010.
   4:../../LUFA/Drivers/Peripheral/Serial.h ****               
   5:../../LUFA/Drivers/Peripheral/Serial.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/Peripheral/Serial.h ****       www.fourwalledcubicle.com
   7:../../LUFA/Drivers/Peripheral/Serial.h **** */
   8:../../LUFA/Drivers/Peripheral/Serial.h **** 
   9:../../LUFA/Drivers/Peripheral/Serial.h **** /*
  10:../../LUFA/Drivers/Peripheral/Serial.h ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/Peripheral/Serial.h **** 
  12:../../LUFA/Drivers/Peripheral/Serial.h ****   Permission to use, copy, modify, distribute, and sell this 
  13:../../LUFA/Drivers/Peripheral/Serial.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/Peripheral/Serial.h ****   without fee, provided that the above copyright notice appear in 
  15:../../LUFA/Drivers/Peripheral/Serial.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/Peripheral/Serial.h ****   permission notice and warranty disclaimer appear in supporting 
  17:../../LUFA/Drivers/Peripheral/Serial.h ****   documentation, and that the name of the author not be used in 
  18:../../LUFA/Drivers/Peripheral/Serial.h ****   advertising or publicity pertaining to distribution of the 
  19:../../LUFA/Drivers/Peripheral/Serial.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/Peripheral/Serial.h **** 
  21:../../LUFA/Drivers/Peripheral/Serial.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/Peripheral/Serial.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/Peripheral/Serial.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/Peripheral/Serial.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/Peripheral/Serial.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/Peripheral/Serial.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/Peripheral/Serial.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/Peripheral/Serial.h ****   this software.
  29:../../LUFA/Drivers/Peripheral/Serial.h **** */
  30:../../LUFA/Drivers/Peripheral/Serial.h **** 
  31:../../LUFA/Drivers/Peripheral/Serial.h **** /** \file
  32:../../LUFA/Drivers/Peripheral/Serial.h ****  *  \brief Master include file for the USART peripheral driver.
  33:../../LUFA/Drivers/Peripheral/Serial.h ****  *
  34:../../LUFA/Drivers/Peripheral/Serial.h ****  *  Driver for the USART subsystem on supported USB AVRs.
  35:../../LUFA/Drivers/Peripheral/Serial.h ****  */
  36:../../LUFA/Drivers/Peripheral/Serial.h ****  
  37:../../LUFA/Drivers/Peripheral/Serial.h **** /** \ingroup Group_PeripheralDrivers
  38:../../LUFA/Drivers/Peripheral/Serial.h ****  *  @defgroup Group_Serial Serial USART Driver - LUFA/Drivers/Peripheral/Serial.h
  39:../../LUFA/Drivers/Peripheral/Serial.h ****  *
  40:../../LUFA/Drivers/Peripheral/Serial.h ****  *  \section Sec_Dependencies Module Source Dependencies
  41:../../LUFA/Drivers/Peripheral/Serial.h ****  *  The following files must be built with any user project that uses this module:
  42:../../LUFA/Drivers/Peripheral/Serial.h ****  *    - LUFA/Drivers/Peripheral/Serial.c <i>(Makefile source module name: LUFA_SRC_SERIAL)</i>
  43:../../LUFA/Drivers/Peripheral/Serial.h ****  *
  44:../../LUFA/Drivers/Peripheral/Serial.h ****  *  \section Module Description
  45:../../LUFA/Drivers/Peripheral/Serial.h ****  *  Hardware serial USART driver. This module provides an easy to use driver for
  46:../../LUFA/Drivers/Peripheral/Serial.h ****  *  the setup of and transfer of data over the AVR's USART port.
  47:../../LUFA/Drivers/Peripheral/Serial.h ****  *
  48:../../LUFA/Drivers/Peripheral/Serial.h ****  *  @{
  49:../../LUFA/Drivers/Peripheral/Serial.h ****  */
  50:../../LUFA/Drivers/Peripheral/Serial.h ****  
  51:../../LUFA/Drivers/Peripheral/Serial.h **** #ifndef __SERIAL_H__
  52:../../LUFA/Drivers/Peripheral/Serial.h **** #define __SERIAL_H__
  53:../../LUFA/Drivers/Peripheral/Serial.h **** 
  54:../../LUFA/Drivers/Peripheral/Serial.h **** 	/* Includes: */
  55:../../LUFA/Drivers/Peripheral/Serial.h **** 		#include <avr/io.h>
  56:../../LUFA/Drivers/Peripheral/Serial.h **** 		#include <avr/pgmspace.h>
  57:../../LUFA/Drivers/Peripheral/Serial.h **** 		#include <stdbool.h>
  58:../../LUFA/Drivers/Peripheral/Serial.h **** 		
  59:../../LUFA/Drivers/Peripheral/Serial.h **** 		#include "../../Common/Common.h"
  60:../../LUFA/Drivers/Peripheral/Serial.h **** 		#include "../Misc/TerminalCodes.h"
  61:../../LUFA/Drivers/Peripheral/Serial.h **** 
  62:../../LUFA/Drivers/Peripheral/Serial.h **** 	/* Enable C linkage for C++ Compilers: */
  63:../../LUFA/Drivers/Peripheral/Serial.h **** 		#if defined(__cplusplus)
  64:../../LUFA/Drivers/Peripheral/Serial.h **** 			extern "C" {
  65:../../LUFA/Drivers/Peripheral/Serial.h **** 		#endif
  66:../../LUFA/Drivers/Peripheral/Serial.h **** 
  67:../../LUFA/Drivers/Peripheral/Serial.h **** 	/* Public Interface - May be used in end-application: */
  68:../../LUFA/Drivers/Peripheral/Serial.h **** 		/* Macros: */
  69:../../LUFA/Drivers/Peripheral/Serial.h **** 			/** Macro for calculating the baud value from a given baud rate when the U2X (double speed) bit 
  70:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  not set.
  71:../../LUFA/Drivers/Peripheral/Serial.h **** 			 */
  72:../../LUFA/Drivers/Peripheral/Serial.h **** 			#define SERIAL_UBBRVAL(baud)    ((((F_CPU / 16) + (baud / 2)) / (baud)) - 1)
  73:../../LUFA/Drivers/Peripheral/Serial.h **** 
  74:../../LUFA/Drivers/Peripheral/Serial.h **** 			/** Macro for calculating the baud value from a given baud rate when the U2X (double speed) bit 
  75:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  set.
  76:../../LUFA/Drivers/Peripheral/Serial.h **** 			 */
  77:../../LUFA/Drivers/Peripheral/Serial.h **** 			#define SERIAL_2X_UBBRVAL(baud) ((((F_CPU / 8) + (baud / 2)) / (baud)) - 1)
  78:../../LUFA/Drivers/Peripheral/Serial.h **** 
  79:../../LUFA/Drivers/Peripheral/Serial.h **** 		/* Function Prototypes: */
  80:../../LUFA/Drivers/Peripheral/Serial.h **** 			/** Transmits a given string located in program space (FLASH) through the USART.
  81:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *
  82:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  \param[in] FlashStringPtr  Pointer to a string located in program space.
  83:../../LUFA/Drivers/Peripheral/Serial.h **** 			 */
  84:../../LUFA/Drivers/Peripheral/Serial.h **** 			void Serial_TxString_P(const char* FlashStringPtr) ATTR_NON_NULL_PTR_ARG(1);
  85:../../LUFA/Drivers/Peripheral/Serial.h **** 
  86:../../LUFA/Drivers/Peripheral/Serial.h **** 			/** Transmits a given string located in SRAM memory through the USART.
  87:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *
  88:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  \param[in] StringPtr  Pointer to a string located in SRAM space.
  89:../../LUFA/Drivers/Peripheral/Serial.h **** 			 */
  90:../../LUFA/Drivers/Peripheral/Serial.h **** 			void Serial_TxString(const char* StringPtr) ATTR_NON_NULL_PTR_ARG(1);
  91:../../LUFA/Drivers/Peripheral/Serial.h **** 
  92:../../LUFA/Drivers/Peripheral/Serial.h **** 		/* Inline Functions: */
  93:../../LUFA/Drivers/Peripheral/Serial.h **** 			/** Initializes the USART, ready for serial data transmission and reception. This initializes th
  94:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  standard 8-bit, no parity, 1 stop bit settings suitable for most applications.
  95:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *
  96:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  \param[in] BaudRate     Serial baud rate, in bits per second.
  97:../../LUFA/Drivers/Peripheral/Serial.h **** 			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to doubl
  98:../../LUFA/Drivers/Peripheral/Serial.h **** 			 */
  99:../../LUFA/Drivers/Peripheral/Serial.h **** 			static inline void Serial_Init(const uint32_t BaudRate,
 100:../../LUFA/Drivers/Peripheral/Serial.h **** 			                               const bool DoubleSpeed)
 101:../../LUFA/Drivers/Peripheral/Serial.h **** 			{
 102:../../LUFA/Drivers/Peripheral/Serial.h **** 				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
 151               		.loc 6 102 0
 152 0020 87E6      		ldi r24,lo8(103)
 153 0022 90E0      		ldi r25,0
 154 0024 9093 CD00 		sts 204+1,r25
 155 0028 8093 CC00 		sts 204,r24
 103:../../LUFA/Drivers/Peripheral/Serial.h **** 
 104:../../LUFA/Drivers/Peripheral/Serial.h **** 				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
 156               		.loc 6 104 0
 157 002c 86E0      		ldi r24,lo8(6)
 158 002e 8093 CA00 		sts 202,r24
 105:../../LUFA/Drivers/Peripheral/Serial.h **** 				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
 159               		.loc 6 105 0
 160 0032 1092 C800 		sts 200,__zero_reg__
 106:../../LUFA/Drivers/Peripheral/Serial.h **** 				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
 161               		.loc 6 106 0
 162 0036 C9EC      		ldi r28,lo8(-55)
 163 0038 D0E0      		ldi r29,0
 164 003a 88E1      		ldi r24,lo8(24)
 165 003c 8883      		st Y,r24
 107:../../LUFA/Drivers/Peripheral/Serial.h **** 				
 108:../../LUFA/Drivers/Peripheral/Serial.h **** 				DDRD  |= (1 << 3);
 166               		.loc 6 108 0
 167 003e 539A      		sbi 0xa,3
 109:../../LUFA/Drivers/Peripheral/Serial.h **** 				PORTD |= (1 << 2);
 168               		.loc 6 109 0
 169 0040 5A9A      		sbi 0xb,2
 170               	.LVL10:
 171               	.LBE117:
 172               	.LBE116:
 173               	.LBB118:
 174               	.LBB119:
  69:./Board/LEDs.h **** 				PORTD |= LEDS_ALL_LEDS;
 175               		.loc 1 69 0
 176 0042 8AB1      		in r24,0xa
 177 0044 8063      		ori r24,lo8(48)
 178 0046 8AB9      		out 0xa,r24
  70:./Board/LEDs.h **** 			}
 179               		.loc 1 70 0
 180 0048 8BB1      		in r24,0xb
 181 004a 8063      		ori r24,lo8(48)
 182 004c 8BB9      		out 0xb,r24
 183               	.LBE119:
 184               	.LBE118:
 192:Arduino-serialusbkeyboard.c **** 	wdt_disable();
 193:Arduino-serialusbkeyboard.c **** 
 194:Arduino-serialusbkeyboard.c **** 	/* Disable clock division */
 195:Arduino-serialusbkeyboard.c **** 	// clock_prescale_set(clock_div_1);
 196:Arduino-serialusbkeyboard.c **** 
 197:Arduino-serialusbkeyboard.c **** 	/* Hardware Initialization */
 198:Arduino-serialusbkeyboard.c **** 	Serial_Init(9600, false);
 199:Arduino-serialusbkeyboard.c **** 	LEDs_Init();
 200:Arduino-serialusbkeyboard.c **** 	USB_Init();
 185               		.loc 4 200 0
 186 004e 0E94 0000 		call USB_Init
 187               	.LVL11:
 201:Arduino-serialusbkeyboard.c **** 
 202:Arduino-serialusbkeyboard.c **** 	/* Start the flush timer so that overflows occur rapidly to push received bytes to the USB interfa
 203:Arduino-serialusbkeyboard.c **** 	// TCCR0B = (1 << CS02);
 204:Arduino-serialusbkeyboard.c **** 	
 205:Arduino-serialusbkeyboard.c **** 	/* Pull target /RESET line high */
 206:Arduino-serialusbkeyboard.c **** 	AVR_RESET_LINE_PORT |= AVR_RESET_LINE_MASK;
 188               		.loc 4 206 0
 189 0052 5F9A      		sbi 0xb,7
 207:Arduino-serialusbkeyboard.c **** 	AVR_RESET_LINE_DDR  |= AVR_RESET_LINE_MASK;
 190               		.loc 4 207 0
 191 0054 579A      		sbi 0xa,7
 208:Arduino-serialusbkeyboard.c **** 
 209:Arduino-serialusbkeyboard.c **** 
 210:Arduino-serialusbkeyboard.c **** 
 211:Arduino-serialusbkeyboard.c ****     /* Must turn off USART before reconfiguring it, otherwise incorrect operation may occur */
 212:Arduino-serialusbkeyboard.c ****     UCSR1B = 0;
 192               		.loc 4 212 0
 193 0056 1882      		st Y,__zero_reg__
 213:Arduino-serialusbkeyboard.c **** 
 214:Arduino-serialusbkeyboard.c **** 	UCSR1B = ((1 << RXCIE1) | (0 << TXEN1) | (1 << RXEN1));
 194               		.loc 4 214 0
 195 0058 80E9      		ldi r24,lo8(-112)
 196 005a 8883      		st Y,r24
 197               	/* epilogue start */
 215:Arduino-serialusbkeyboard.c **** 
 216:Arduino-serialusbkeyboard.c **** }
 198               		.loc 4 216 0
 199 005c DF91      		pop r29
 200 005e CF91      		pop r28
 201 0060 0895      		ret
 202               		.cfi_endproc
 203               	.LFE89:
 205               		.section	.text.EVENT_USB_Device_Connect,"ax",@progbits
 206               	.global	EVENT_USB_Device_Connect
 208               	EVENT_USB_Device_Connect:
 209               	.LFB90:
 217:Arduino-serialusbkeyboard.c **** 
 218:Arduino-serialusbkeyboard.c **** /** Event handler for the USB_Connect event. This indicates that the device is enumerating via the 
 219:Arduino-serialusbkeyboard.c ****  *  starts the library USB task to begin the enumeration and USB management process.
 220:Arduino-serialusbkeyboard.c ****  */
 221:Arduino-serialusbkeyboard.c **** void EVENT_USB_Device_Connect(void)
 222:Arduino-serialusbkeyboard.c **** {
 210               		.loc 4 222 0
 211               		.cfi_startproc
 212               	/* prologue: function */
 213               	/* frame size = 0 */
 214               	/* stack size = 0 */
 215               	.L__stack_usage = 0
 223:Arduino-serialusbkeyboard.c **** 	/* Indicate USB enumerating */
 224:Arduino-serialusbkeyboard.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
 216               		.loc 4 224 0
 217 0000 80E1      		ldi r24,lo8(16)
 218 0002 0E94 0000 		call LEDs_SetAllLEDs
 219               	.LVL12:
 225:Arduino-serialusbkeyboard.c **** 
 226:Arduino-serialusbkeyboard.c **** 	/* Default to report protocol on connect */
 227:Arduino-serialusbkeyboard.c **** 	UsingReportProtocol = true;
 220               		.loc 4 227 0
 221 0006 81E0      		ldi r24,lo8(1)
 222 0008 8093 0000 		sts UsingReportProtocol,r24
 223               	/* epilogue start */
 228:Arduino-serialusbkeyboard.c **** }
 224               		.loc 4 228 0
 225 000c 0895      		ret
 226               		.cfi_endproc
 227               	.LFE90:
 229               		.section	.text.EVENT_USB_Device_Disconnect,"ax",@progbits
 230               	.global	EVENT_USB_Device_Disconnect
 232               	EVENT_USB_Device_Disconnect:
 233               	.LFB91:
 229:Arduino-serialusbkeyboard.c **** 
 230:Arduino-serialusbkeyboard.c **** /** Event handler for the USB_Disconnect event. This indicates that the device is no longer connect
 231:Arduino-serialusbkeyboard.c ****  *  the status LEDs.
 232:Arduino-serialusbkeyboard.c ****  */
 233:Arduino-serialusbkeyboard.c **** void EVENT_USB_Device_Disconnect(void)
 234:Arduino-serialusbkeyboard.c **** {
 234               		.loc 4 234 0
 235               		.cfi_startproc
 236               	/* prologue: function */
 237               	/* frame size = 0 */
 238               	/* stack size = 0 */
 239               	.L__stack_usage = 0
 235:Arduino-serialusbkeyboard.c **** 	/* Indicate USB not ready */
 236:Arduino-serialusbkeyboard.c **** 	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
 240               		.loc 4 236 0
 241 0000 80E2      		ldi r24,lo8(32)
 242 0002 0C94 0000 		jmp LEDs_SetAllLEDs
 243               	.LVL13:
 244               		.cfi_endproc
 245               	.LFE91:
 247               		.section	.text.EVENT_USB_Device_ConfigurationChanged,"ax",@progbits
 248               	.global	EVENT_USB_Device_ConfigurationChanged
 250               	EVENT_USB_Device_ConfigurationChanged:
 251               	.LFB92:
 237:Arduino-serialusbkeyboard.c **** }
 238:Arduino-serialusbkeyboard.c **** 
 239:Arduino-serialusbkeyboard.c **** /** Event handler for the library USB Configuration Changed event. */
 240:Arduino-serialusbkeyboard.c **** void EVENT_USB_Device_ConfigurationChanged(void)
 241:Arduino-serialusbkeyboard.c **** {
 252               		.loc 4 241 0
 253               		.cfi_startproc
 254 0000 CF93      		push r28
 255               	.LCFI2:
 256               		.cfi_def_cfa_offset 3
 257               		.cfi_offset 28, -2
 258               	/* prologue: function */
 259               	/* frame size = 0 */
 260               	/* stack size = 1 */
 261               	.L__stack_usage = 1
 262               	.LVL14:
 263               	.LBB130:
 264               	.LBB131:
 265               		.file 7 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h"
   1:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /*
   2:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****              LUFA Library
   3:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****      Copyright (C) Dean Camera, 2010.
   4:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****               
   5:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****       www.fourwalledcubicle.com
   7:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** */
   8:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
   9:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /*
  10:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  12:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   Permission to use, copy, modify, distribute, and sell this 
  13:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   without fee, provided that the above copyright notice appear in 
  15:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   permission notice and warranty disclaimer appear in supporting 
  17:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   documentation, and that the name of the author not be used in 
  18:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   advertising or publicity pertaining to distribution of the 
  19:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  21:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****   this software.
  29:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** */
  30:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  31:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \file
  32:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  \brief USB device endpoint management definitions.
  33:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  34:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  This file contains structures, function prototypes and macros related to the management of the 
  35:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  data endpoints when the library is initialized in USB device mode.
  36:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  37:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  38:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  39:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  40:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  41:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_USB
  42:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointManagement Endpoint Management
  43:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  44:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros and enums related to endpoint management when in USB Device mode. This
  45:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  module contains the endpoint management macros, as well as endpoint interrupt and data
  46:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  send/receive functions for various data types.
  47:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  48:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @{
  49:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  50:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  51:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** @defgroup Group_EndpointRW Endpoint Data Reading and Writing
  52:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  53:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to data reading and writing from and to e
  54:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  55:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  
  56:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_EndpointRW  
  57:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointPrimitiveRW Read/Write of Primitive Data Types
  58:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  59:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of primitive 
  60:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  from and to endpoints.
  61:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */ 
  62:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  63:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** \ingroup Group_EndpointRW  
  64:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  @defgroup Group_EndpointStreamRW Read/Write of Multi-Byte Streams
  65:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  66:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to data reading and writing of data strea
  67:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  and to endpoints.
  68:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */ 
  69:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  70:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** /** @defgroup Group_EndpointPacketManagement Endpoint Packet Management
  71:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *
  72:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  *  Functions, macros, variables, enums and types related to packet management of endpoints.
  73:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h ****  */
  74:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  75:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** #ifndef __ENDPOINT_H__
  76:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** #define __ENDPOINT_H__
  77:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  78:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Includes: */
  79:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include <avr/io.h>
  80:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include <avr/pgmspace.h>
  81:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include <avr/eeprom.h>
  82:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include <stdbool.h>
  83:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  84:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include "../../../Common/Common.h"
  85:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include "../HighLevel/USBTask.h"
  86:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#include "USBInterrupt.h"
  87:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  88:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#if !defined(NO_STREAM_CALLBACKS) || defined(__DOXYGEN__)
  89:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#include "../HighLevel/StreamCallbacks.h"
  90:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#endif
  91:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		
  92:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Enable C linkage for C++ Compilers: */
  93:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#if defined(__cplusplus)
  94:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			extern "C" {
  95:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#endif
  96:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
  97:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Preprocessor Checks: */
  98:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  99:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
 100:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		#endif
 101:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		
 102:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Public Interface - May be used in end-application: */
 103:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Macros: */
 104:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint data direction mask for \ref Endpoint_ConfigureEndpoint(). This indicates that the 
 105:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  should be initialized in the OUT direction - i.e. data flows from host to device.
 106:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 107:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_DIR_OUT                      (0 << EPDIR)
 108:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 109:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint data direction mask for \ref Endpoint_ConfigureEndpoint(). This indicates that the 
 110:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  should be initialized in the IN direction - i.e. data flows from device to host.
 111:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 112:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_DIR_IN                       (1 << EPDIR)
 113:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 114:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 115:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  that the endpoint should have one single bank, which requires less USB FIFO memory but resul
 116:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  in slower transfers as only one USB device (the AVR or the host) can access the endpoint's
 117:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  bank at the one time.
 118:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 119:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_BANK_SINGLE                  (0 << EPBK0)
 120:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 121:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Mask for the bank mode selection for the \ref Endpoint_ConfigureEndpoint() macro. This indic
 122:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  that the endpoint should have two banks, which requires more USB FIFO memory but results
 123:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  in faster transfers as one USB device (the AVR or the host) can access one bank while the ot
 124:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  accesses the second bank.
 125:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 126:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_BANK_DOUBLE                  (1 << EPBK0)
 127:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 128:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint address for the default control endpoint, which always resides in address 0. This i
 129:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  defined for convenience to give more readable code when used with the endpoint macros.
 130:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 131:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_CONTROLEP                    0
 132:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 133:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if (!defined(FIXED_CONTROL_ENDPOINT_SIZE) || defined(__DOXYGEN__))
 134:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				/** Default size of the default control endpoint's bank, until altered by the control endpoint 
 135:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 *  value in the device descriptor. Not available if the FIXED_CONTROL_ENDPOINT_SIZE token is d
 136:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				 */
 137:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_CONTROLEP_DEFAULT_SIZE   8
 138:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 139:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 140:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint number mask, for masking against endpoint addresses to retrieve the endpoint's
 141:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  numerical address in the device.
 142:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 143:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_EPNUM_MASK                   0x07
 144:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 145:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint direction mask, for masking against endpoint addresses to retrieve the endpoint's
 146:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction for comparing with the ENDPOINT_DESCRIPTOR_DIR_* masks.
 147:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 148:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_EPDIR_MASK                   0x80
 149:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 150:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Endpoint bank size mask, for masking against endpoint addresses to retrieve the endpoint's
 151:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  bank size in the device.
 152:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 153:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_EPSIZE_MASK                  0x7F
 154:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 155:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Maximum size in bytes of a given endpoint.
 156:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 157:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] n  Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1)
 158:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */				
 159:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_MAX_SIZE(n)                  _ENDPOINT_GET_MAXSIZE(n)
 160:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 161:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Indicates if the given endpoint supports double banking.
 162:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 163:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] n  Endpoint number, a value between 0 and (ENDPOINT_TOTAL_ENDPOINTS - 1)
 164:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */				
 165:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define ENDPOINT_DOUBLEBANK_SUPPORTED(n)      _ENDPOINT_GET_DOUBLEBANK(n)
 166:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 167:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if !defined(CONTROL_ONLY_DEVICE)
 168:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR) || defi
 169:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					/** Total number of endpoints (including the default control endpoint at address 0) which may
 170:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					 *  be used in the device. Different USB AVR models support different amounts of endpoints,
 171:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					 *  this value reflects the maximum number of endpoints for the currently selected AVR model.
 172:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					 */
 173:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					#define ENDPOINT_TOTAL_ENDPOINTS      7
 174:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 175:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					#define ENDPOINT_TOTAL_ENDPOINTS      5
 176:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 177:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#else
 178:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_TOTAL_ENDPOINTS          1
 179:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 180:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 181:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Enums: */
 182:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Enum for the possible error return codes of the \ref Endpoint_WaitUntilReady() function.
 183:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 184:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointRW
 185:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 186:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			enum Endpoint_WaitUntilReady_ErrorCodes_t
 187:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 188:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_NoError                 = 0, /**< Endpoint is ready for next packet, no erro
 189:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_EndpointStalled         = 1, /**< The endpoint was stalled during the stream
 190:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   transfer by the host or device.
 191:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 192:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_DeviceDisconnected      = 2,	/**< Device was disconnected from the host whil
 193:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   waiting for the endpoint to become ready.
 194:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 195:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_BusSuspended            = 3, /**< The USB bus has been suspended by the host
 196:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   no USB endpoint traffic can occur until th
 197:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   has resumed.
 198:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 199:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_READYWAIT_Timeout                 = 4, /**< The host failed to accept or send the next
 200:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   within the software timeout period set by 
 201:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 *   \ref USB_STREAM_TIMEOUT_MS macro.
 202:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                                 */
 203:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			};
 204:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		
 205:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Enum for the possible error return codes of the Endpoint_*_Stream_* functions.
 206:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 207:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 208:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 209:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			enum Endpoint_Stream_RW_ErrorCodes_t
 210:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 211:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWSTREAM_NoError            = 0, /**< Command completed successfully, no error. */
 212:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWSTREAM_EndpointStalled    = 1, /**< The endpoint was stalled during the stream
 213:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           *   transfer by the host or device.
 214:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           */
 215:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWSTREAM_DeviceDisconnected = 2, /**< Device was disconnected from the host during
 216:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           *   the transfer.
 217:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           */
 218:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWSTREAM_BusSuspended       = 3, /**< The USB bus has been suspended by the host and
 219:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           *   no USB endpoint traffic can occur until the bus
 220:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           *   has resumed.
 221:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           */
 222:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWSTREAM_Timeout            = 4, /**< The host failed to accept or send the next packe
 223:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           *   within the software timeout period set by the
 224:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           *   \ref USB_STREAM_TIMEOUT_MS macro.
 225:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           */
 226:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWSTREAM_CallbackAborted    = 5, /**< Indicates that the stream's callback function
 227:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                               *   aborted the transfer early.
 228:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                           */
 229:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			};
 230:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 231:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Enum for the possible error return codes of the Endpoint_*_Control_Stream_* functions..
 232:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 233:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 234:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 235:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			enum Endpoint_ControlStream_RW_ErrorCodes_t
 236:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 237:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWCSTREAM_NoError            = 0, /**< Command completed successfully, no error. */
 238:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWCSTREAM_HostAborted        = 1, /**< The aborted the transfer prematurely. */
 239:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWCSTREAM_DeviceDisconnected = 2, /**< Device was disconnected from the host during
 240:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                            *   the transfer.
 241:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                            */
 242:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				ENDPOINT_RWCSTREAM_BusSuspended       = 3, /**< The USB bus has been suspended by the host and
 243:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                            *   no USB endpoint traffic can occur until the bus
 244:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                            *   has resumed.
 245:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				                                            */
 246:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			};
 247:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 248:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Inline Functions: */
 249:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Indicates the number of bytes currently stored in the current endpoint's selected bank.
 250:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 251:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note The return width of this function may differ, depending on the maximum endpoint bank s
 252:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        of the selected AVR model.
 253:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 254:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointRW
 255:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 256:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Total number of bytes in the currently selected Endpoint's FIFO buffer.
 257:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 258:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE
 259:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_BytesInEndpoint(void)
 260:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 261:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
 262:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return UEBCX;
 263:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_4_AVR)
 264:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return (((uint16_t)UEBCHX << 8) | UEBCLX);
 265:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#elif defined(USB_SERIES_2_AVR)
 266:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return UEBCLX;
 267:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 268:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 269:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		
 270:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Get the endpoint address of the currently selected endpoint. This is typically used to save
 271:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  the currently selected endpoint number so that it can be restored after another endpoint has
 272:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  been manipulated.
 273:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 274:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Index of the currently selected endpoint.
 275:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 276:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLI
 277:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
 278:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 279:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 280:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return (UENUM & ENDPOINT_EPNUM_MASK);
 281:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 282:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					return ENDPOINT_CONTROLEP;
 283:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 284:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 285:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 286:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Selects the given endpoint number. If the address from the device descriptors is used, the
 287:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  value should be masked with the \ref ENDPOINT_EPNUM_MASK constant to extract only the endpoi
 288:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  number (and discarding the endpoint direction bit).
 289:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 290:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  Any endpoint operations which do not require the endpoint number to be indicated will operat
 291:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  the currently selected endpoint.
 292:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 293:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EndpointNumber Endpoint number to select.
 294:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 295:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 296:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
 297:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 298:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 299:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UENUM = EndpointNumber;
 300:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif			
 301:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 302:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 303:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB control
 304:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  In and Out pointers to the bank's contents.
 305:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 306:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
 307:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 308:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
 309:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
 310:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 311:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UERST = (1 << EndpointNumber);
 312:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UERST = 0;
 313:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 315:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Enables the currently selected endpoint so that data can be sent and received through it to
 316:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  and from a host.
 317:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 318:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
 319:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 320:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
 321:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_EnableEndpoint(void)
 322:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 323:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << EPEN);
 324:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 325:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 326:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Disables the currently selected endpoint so that data cannot be sent and received through it
 327:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  to and from a host.
 328:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 329:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
 330:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_DisableEndpoint(void)
 331:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 332:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX &= ~(1 << EPEN);
 333:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 334:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 335:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint is enabled, but not necessarily configured.
 336:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 337:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
 338:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 339:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 340:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsEnabled(void)
 341:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 342:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UECONX & (1 << EPEN)) ? true : false);
 343:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 344:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 345:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint may be read from (if data is waiting in the en
 346:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  bank and the endpoint is an OUT direction, or if the bank is not yet full if the endpoint is
 347:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction). This function will return false if an error has occurred in the endpoint, if the
 348:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is an OUT direction and no packet (or an empty packet) has been received, or if the endpoint
 349:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction and the endpoint bank is full.
 350:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 351:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 352:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 353:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the currently selected endpoint may be read from or written to, depe
 354:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 355:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 356:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsReadWriteAllowed(void)
 357:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 358:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << RWAL)) ? true : false);
 359:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 360:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 361:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint is configured.
 362:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 363:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the currently selected endpoint has been configured, false otherwise
 364:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 365:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 366:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsConfigured(void)
 367:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 368:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UESTA0X & (1 << CFGOK)) ? true : false);
 369:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 370:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 371:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their
 372:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  interrupt duration has elapsed. Which endpoints have interrupted can be determined by
 373:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  masking the return value against (1 << {Endpoint Number}).
 374:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 375:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Mask whose bits indicate which endpoints have interrupted.
 376:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 377:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_I
 378:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointInterrupts(void)
 379:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 380:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return UEINT;
 381:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 382:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 383:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the specified endpoint number has interrupted (valid only for INTERRUPT type
 384:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoints).
 385:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 386:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] EndpointNumber  Index of the endpoint whose interrupt flag should be tested.
 387:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 388:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the specified endpoint has interrupted, false otherwise.
 389:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 390:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber) ATTR_WARN_UNUSE
 391:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_HasEndpointInterrupted(const uint8_t EndpointNumber)
 392:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 393:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINT & (1 << EndpointNumber)) ? true : false);
 394:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 395:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 396:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the selected IN endpoint is ready for a new packet.
 397:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 398:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 399:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 400:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
 401:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 402:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 403:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsINReady(void)
 404:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 405:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << TXINI))  ? true : false);
 406:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 407:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 408:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the selected OUT endpoint has received new packet.
 409:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 410:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 411:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 412:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
 413:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 414:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 415:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsOUTReceived(void)
 416:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 417:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 418:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 419:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 420:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the current CONTROL type endpoint has received a SETUP packet.
 421:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 422:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 423:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 424:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
 425:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 426:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 427:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsSETUPReceived(void)
 428:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 429:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 430:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 431:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 432:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Clears a received SETUP packet on the currently selected CONTROL type endpoint, freeing up t
 433:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoint for the next packet.
 434:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 435:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 436:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 437:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This is not applicable for non CONTROL type endpoints. 
 438:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 439:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
 440:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearSETUP(void)
 441:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEINTX &= ~(1 << RXSTPI);
 443:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 444:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 445:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Sends an IN packet to the host on the currently selected endpoint, freeing up the endpoint f
 446:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  next packet and switching to the alternative endpoint bank if double banked.
 447:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 448:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 449:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 450:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
 451:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearIN(void)
 452:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 453:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 454:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 455:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 456:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~(1 << TXINI);
 457:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 458:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 459:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 460:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Acknowledges an OUT packet to the host on the currently selected endpoint, freeing up the en
 461:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  for the next packet and switching to the alternative endpoint bank if double banked.
 462:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 463:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 464:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 465:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
 466:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearOUT(void)
 467:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 468:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#if !defined(CONTROL_ONLY_DEVICE)
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 470:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 471:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					UEINTX &= ~(1 << RXOUTI);	
 472:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif
 473:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 474:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 475:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Stalls the current endpoint, indicating to the host that a logical problem occurred with the
 476:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  indicated endpoint and that the current transfer sequence should be aborted. This provides a
 477:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  way for devices to indicate invalid commands to the host so that the current transfer can be
 478:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  aborted and the host can begin its own recovery sequence.
 479:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 480:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  The currently selected endpoint remains stalled until either the \ref Endpoint_ClearStall() 
 481:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is called, or the host issues a CLEAR FEATURE request to the device for the currently select
 482:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoint.
 483:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 484:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 485:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 486:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
 487:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_StallTransaction(void)
 488:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 489:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << STALLRQ);
 490:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 491:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 492:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Clears the STALL condition on the currently selected endpoint.
 493:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 494:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 495:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 496:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
 497:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ClearStall(void)
 498:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 499:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << STALLRQC);
 500:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 501:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 502:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines if the currently selected endpoint is stalled, false otherwise.
 503:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 504:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPacketManagement
 505:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 506:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
 507:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 508:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 509:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_IsStalled(void)
 510:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 511:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return ((UECONX & (1 << STALLRQ)) ? true : false);
 512:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 513:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 514:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Resets the data toggle of the currently selected endpoint. */
 515:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
 516:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_ResetDataToggle(void)
 517:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 518:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECONX |= (1 << RSTDT);
 519:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 520:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 521:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Determines the currently selected endpoint's direction.
 522:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 523:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return The currently selected endpoint's direction, as a ENDPOINT_DIR_* mask.
 524:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 525:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_IN
 526:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_GetEndpointDirection(void)
 527:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 528:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return (UECFG0X & ENDPOINT_DIR_IN);
 529:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 530:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 531:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Sets the direction of the currently selected endpoint.
 532:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 533:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] DirectionMask  New endpoint direction, as a ENDPOINT_DIR_* mask.
 534:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 535:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask) ATTR_ALWAYS_INLINE
 536:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_SetEndpointDirection(const uint8_t DirectionMask)
 537:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 538:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UECFG0X = ((UECFG0X & ~ENDPOINT_DIR_IN) | DirectionMask);
 539:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 540:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 541:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints.
 542:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 543:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 544:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 545:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
 546:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 547:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 548:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_Read_Byte(void)
 549:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 550:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return UEDATX;
 551:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 552:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 553:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes one byte from the currently selected endpoint's bank, for IN direction endpoints.
 554:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 555:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 556:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 557:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
 558:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 559:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
 560:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Byte(const uint8_t Byte)
 561:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 562:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = Byte;
 563:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 564:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 565:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Discards one byte from the currently selected endpoint's bank, for OUT direction endpoints.
 566:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 567:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 568:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 569:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_Byte(void) ATTR_ALWAYS_INLINE;
 570:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_Byte(void)
 571:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 572:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint8_t Dummy;
 573:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 574:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 575:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 576:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 577:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads two bytes from the currently selected endpoint's bank in little endian format, for OUT
 578:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 579:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 580:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 581:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 582:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next word in the currently selected endpoint's FIFO buffer.
 583:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 584:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 585:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_LE(void)
 586:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 587:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				union
 588:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 589:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint16_t Word;
 590:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint8_t  Bytes[2];
 591:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				} Data;
 592:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 593:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[0] = UEDATX;
 594:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[1] = UEDATX;
 595:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 596:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Data.Word;
 597:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 598:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 599:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads two bytes from the currently selected endpoint's bank in big endian format, for OUT
 600:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 601:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 602:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 603:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 604:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next word in the currently selected endpoint's FIFO buffer.
 605:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 606:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_BE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 607:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint16_t Endpoint_Read_Word_BE(void)
 608:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 609:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				union
 610:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 611:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint16_t Word;
 612:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint8_t  Bytes[2];
 613:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				} Data;
 614:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 615:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[1] = UEDATX;
 616:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[0] = UEDATX;
 617:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 618:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Data.Word;
 619:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 620:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 621:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes two bytes to the currently selected endpoint's bank in little endian format, for IN
 622:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 623:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 624:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 625:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 626:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
 627:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 628:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
 629:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
 630:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 631:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word & 0xFF);
 632:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word >> 8);
 633:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 634:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 635:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes two bytes to the currently selected endpoint's bank in big endian format, for IN
 636:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 637:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 638:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 639:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 640:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
 641:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 642:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Word_BE(const uint16_t Word) ATTR_ALWAYS_INLINE;
 643:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_Word_BE(const uint16_t Word)
 644:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 645:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word >> 8);
 646:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (Word & 0xFF);
 647:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 648:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 649:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Discards two bytes from the currently selected endpoint's bank, for OUT direction endpoints.
 650:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 651:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 652:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 653:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_Word(void) ATTR_ALWAYS_INLINE;
 654:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_Word(void)
 655:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 656:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint8_t Dummy;
 657:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 658:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 659:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 660:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 661:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 662:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads four bytes from the currently selected endpoint's bank in little endian format, for OU
 663:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 664:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 665:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 666:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 667:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next double word in the currently selected endpoint's FIFO buffer.
 668:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 669:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint32_t Endpoint_Read_DWord_LE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 670:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint32_t Endpoint_Read_DWord_LE(void)
 671:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 672:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				union
 673:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 674:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint32_t DWord;
 675:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint8_t  Bytes[4];
 676:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				} Data;
 677:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 678:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[0] = UEDATX;
 679:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[1] = UEDATX;
 680:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[2] = UEDATX;
 681:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[3] = UEDATX;
 682:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 683:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Data.DWord;
 684:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 685:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 686:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads four bytes from the currently selected endpoint's bank in big endian format, for OUT
 687:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 688:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 689:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 690:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 691:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Next double word in the currently selected endpoint's FIFO buffer.
 692:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 693:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint32_t Endpoint_Read_DWord_BE(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
 694:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint32_t Endpoint_Read_DWord_BE(void)
 695:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 696:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				union
 697:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
 698:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint32_t DWord;
 699:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					uint8_t  Bytes[4];
 700:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				} Data;
 701:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 702:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[3] = UEDATX;
 703:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[2] = UEDATX;
 704:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[1] = UEDATX;
 705:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Data.Bytes[0] = UEDATX;
 706:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 707:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Data.DWord;
 708:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 709:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 710:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes four bytes to the currently selected endpoint's bank in little endian format, for IN
 711:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 712:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 713:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 714:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 715:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] DWord  Next double word to write to the currently selected endpoint's FIFO buffer
 716:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 717:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_DWord_LE(const uint32_t DWord) ATTR_ALWAYS_INLINE;
 718:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_DWord_LE(const uint32_t DWord)
 719:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 720:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord &  0xFF);
 721:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord >> 8);
 722:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord >> 16);
 723:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord >> 24);
 724:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 725:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 726:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes four bytes to the currently selected endpoint's bank in big endian format, for IN
 727:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  direction endpoints.
 728:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 729:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 730:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 731:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] DWord  Next double word to write to the currently selected endpoint's FIFO buffer
 732:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 733:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_DWord_BE(const uint32_t DWord) ATTR_ALWAYS_INLINE;
 734:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Write_DWord_BE(const uint32_t DWord)
 735:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 736:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord >> 24);
 737:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord >> 16);
 738:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord >> 8);
 739:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				UEDATX = (DWord &  0xFF);
 740:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 741:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 742:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Discards four bytes from the currently selected endpoint's bank, for OUT direction endpoints
 743:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 744:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointPrimitiveRW
 745:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 746:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_DWord(void) ATTR_ALWAYS_INLINE;
 747:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline void Endpoint_Discard_DWord(void)
 748:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
 749:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint8_t Dummy;
 750:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
 751:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 752:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 753:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 754:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				Dummy = UEDATX;
 755:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 756:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 757:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* External Variables: */
 758:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Global indicating the maximum packet size of the default control endpoint located at address
 759:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  0 in the device. This value is set to the value indicated in the device descriptor in the us
 760:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  project once the USB interface is initialized into device mode.
 761:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 762:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  If space is an issue, it is possible to fix this to a static value by defining the control
 763:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoint size in the FIXED_CONTROL_ENDPOINT_SIZE token passed to the compiler in the makefil
 764:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  via the -D switch. When a fixed control endpoint size is used, the size is no longer dynamic
 765:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  read from the descriptors at runtime and instead fixed to the given value. When used, it is
 766:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  important that the descriptor control endpoint size value matches the size given as the
 767:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  FIXED_CONTROL_ENDPOINT_SIZE token - it is recommended that the FIXED_CONTROL_ENDPOINT_SIZE t
 768:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  be used in the descriptors to ensure this.
 769:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 770:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This variable should be treated as read-only in the user application, and never manual
 771:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        changed in value.
 772:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 773:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if (!defined(FIXED_CONTROL_ENDPOINT_SIZE) || defined(__DOXYGEN__))
 774:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				extern uint8_t USB_ControlEndpointSize;
 775:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#else
 776:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define USB_ControlEndpointSize FIXED_CONTROL_ENDPOINT_SIZE
 777:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 778:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 779:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Function Prototypes: */
 780:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if !defined(NO_STREAM_CALLBACKS) || defined(__DOXYGEN__)
 781:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define __CALLBACK_PARAM     , StreamCallbackPtr_t Callback
 782:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#else
 783:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define __CALLBACK_PARAM
 784:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
 785:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		
 786:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Configures the specified endpoint number with the given endpoint type, direction, bank size
 787:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  and banking mode. Endpoints should be allocated in ascending order by their address in the
 788:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  device (i.e. endpoint 1 should be configured before endpoint 2 and so on) to prevent fragmen
 789:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  of the USB FIFO memory.
 790:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 791:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  The endpoint type may be one of the EP_TYPE_* macros listed in LowLevel.h and the direction
 792:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  may be either \ref ENDPOINT_DIR_OUT or \ref ENDPOINT_DIR_IN.
 793:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 794:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  The bank size must indicate the maximum packet size that the endpoint can handle. Different
 795:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  endpoint numbers can handle different maximum packet sizes - refer to the chosen USB AVR's
 796:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  datasheet to determine the maximum bank size for each endpoint.
 797:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 798:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  The banking mode may be either \ref ENDPOINT_BANK_SINGLE or \ref ENDPOINT_BANK_DOUBLE.
 799:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 800:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note The default control endpoint should not be manually configured by the user application
 801:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        it is automatically configured by the library internally.
 802:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
 803:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 804:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine will select the specified endpoint, and the endpoint will remain selected
 805:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        once the routine completes regardless of if the endpoint configuration succeeds.
 806:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 807:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return Boolean true if the configuration succeeded, false otherwise.
 808:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 809:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			bool Endpoint_ConfigureEndpoint(const uint8_t  Number,
 810:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                const uint8_t Type,
 811:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                const uint8_t Direction,
 812:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                const uint16_t Size,
 813:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                const uint8_t Banks);
 814:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 815:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Spin-loops until the currently selected non-control endpoint is ready for the next packet of
 816:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  to be read or written to it.
 817:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 818:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should not be called on CONTROL type endpoints.
 819:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 820:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointRW
 821:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 822:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_WaitUntilReady_ErrorCodes_t enum.
 823:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 824:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_WaitUntilReady(void);
 825:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
 826:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Completes the status stage of a control transfer on a CONTROL type endpoint automatically,
 827:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  with respect to the data direction. This is a convenience function which can be used to
 828:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  simplify user control request handling.
 829:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 830:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			void Endpoint_ClearStatusStage(void);
 831:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 832:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads and discards the given number of bytes from the endpoint from the given buffer,
 833:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding fully read packets from the host as needed. The last packet is not automatically
 834:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarded once the remaining bytes has been read; the user is responsible for manually
 835:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding the last packet from the host via the \ref Endpoint_ClearOUT() macro. Between
 836:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  each USB packet, the given stream callback function is executed repeatedly until the next
 837:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  packet is ready, allowing for early aborts of stream transfers.
 838:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 839:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *	The callback routine should be created according to the information in \ref Group_StreamCallb
 840:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbac
 841:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  disabled and this function has the Callback parameter omitted.
 842:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 843:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should not be used on CONTROL type endpoints.
 844:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 845:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 846:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 847:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to send via the currently selected endpoint.
 848:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 849:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 850:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 851:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 852:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Discard_Stream(uint16_t Length
 853:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                __CALLBACK_PARAM);
 854:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 855:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes the given number of bytes to the endpoint from the given buffer in little endian,
 856:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  sending full packets to the host as needed. The last packet filled is not automatically sent
 857:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  the user is responsible for manually sending the last written packet to the host via the
 858:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ref Endpoint_ClearIN() macro. Between each USB packet, the given stream callback function
 859:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is executed repeatedly until the endpoint is ready to accept the next packet, allowing for e
 860:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  aborts of stream transfers.
 861:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 862:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *	The callback routine should be created according to the information in \ref Group_StreamCallb
 863:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbac
 864:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  disabled and this function has the Callback parameter omitted.
 865:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 866:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should not be used on CONTROL type endpoints.
 867:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 868:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 869:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 870:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer    Pointer to the source data buffer to read from.
 871:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to read for the currently selected endpoint into the bu
 872:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 873:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 874:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 875:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 876:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Stream_LE(const void* Buffer,
 877:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 uint16_t Length
 878:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 879:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 880:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Write_Stream_LE().
 881:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 882:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 883:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 884:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer    Pointer to the source data buffer to read from.
 885:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to read for the currently selected endpoint into the bu
 886:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 887:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 888:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 889:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 890:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_EStream_LE(const void* Buffer,
 891:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  uint16_t Length
 892:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 893:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 894:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** FLASH buffer source version of \ref Endpoint_Write_Stream_LE().
 895:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 896:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \pre The FLASH data must be located in the first 64KB of FLASH for this function to work cor
 897:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 898:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 899:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 900:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer    Pointer to the source data buffer to read from.
 901:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to read for the currently selected endpoint into the bu
 902:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 903:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 904:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 905:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 906:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_PStream_LE(const void* Buffer,
 907:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  uint16_t Length
 908:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 909:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 910:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes the given number of bytes to the endpoint from the given buffer in big endian,
 911:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  sending full packets to the host as needed. The last packet filled is not automatically sent
 912:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  the user is responsible for manually sending the last written packet to the host via the
 913:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ref Endpoint_ClearIN() macro. Between each USB packet, the given stream callback function
 914:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is executed repeatedly until the endpoint is ready to accept the next packet, allowing for e
 915:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  aborts of stream transfers.
 916:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 917:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *	The callback routine should be created according to the information in \ref Group_StreamCallb
 918:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbac
 919:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  disabled and this function has the Callback parameter omitted.
 920:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 921:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should not be used on CONTROL type endpoints.
 922:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 923:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 924:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 925:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer    Pointer to the source data buffer to read from.
 926:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to read for the currently selected endpoint into the bu
 927:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 928:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 929:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 930:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 931:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Stream_BE(const void* Buffer,
 932:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 uint16_t Length
 933:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 934:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 935:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Write_Stream_BE().
 936:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 937:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 938:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 939:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer    Pointer to the source data buffer to read from.
 940:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to read for the currently selected endpoint into the bu
 941:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 942:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 943:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 944:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 945:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_EStream_BE(const void* Buffer,
 946:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  uint16_t Length
 947:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 948:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 949:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** FLASH buffer source version of \ref Endpoint_Write_Stream_BE().
 950:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 951:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \pre The FLASH data must be located in the first 64KB of FLASH for this function to work cor
 952:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 953:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 954:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 955:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer    Pointer to the source data buffer to read from.
 956:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length    Number of bytes to read for the currently selected endpoint into the bu
 957:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Callback  Name of a callback routine to call between successive USB packet transf
 958:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 959:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 960:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 961:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_PStream_BE(const void* Buffer,
 962:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  uint16_t Length
 963:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                  __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 964:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 965:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads the given number of bytes from the endpoint from the given buffer in little endian,
 966:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding fully read packets from the host as needed. The last packet is not automatically
 967:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarded once the remaining bytes has been read; the user is responsible for manually
 968:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding the last packet from the host via the \ref Endpoint_ClearOUT() macro. Between
 969:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  each USB packet, the given stream callback function is executed repeatedly until the endpoin
 970:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is ready to accept the next packet, allowing for early aborts of stream transfers.
 971:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 972:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *	The callback routine should be created according to the information in \ref Group_StreamCallb
 973:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbac
 974:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  disabled and this function has the Callback parameter omitted.
 975:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 976:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should not be used on CONTROL type endpoints.
 977:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 978:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 979:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 980:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer    Pointer to the destination data buffer to write to.
 981:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length    Number of bytes to send via the currently selected endpoint.
 982:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Callback  Name of a callback routine to call between successive USB packet trans
 983:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 984:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 985:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
 986:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_Stream_LE(void* Buffer,
 987:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                uint16_t Length
 988:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
 989:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
 990:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Read_Stream_LE().
 991:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 992:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
 993:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 994:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer    Pointer to the destination data buffer to write to, located in EEPROM 
 995:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length    Number of bytes to send via the currently selected endpoint.
 996:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Callback  Name of a callback routine to call between successive USB packet trans
 997:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
 998:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
 999:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1000:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_EStream_LE(void* Buffer,
1001:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 uint16_t Length
1002:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
1003:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
1004:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads the given number of bytes from the endpoint from the given buffer in big endian,
1005:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding fully read packets from the host as needed. The last packet is not automatically
1006:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarded once the remaining bytes has been read; the user is responsible for manually
1007:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding the last packet from the host via the \ref Endpoint_ClearOUT() macro. Between
1008:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  each USB packet, the given stream callback function is executed repeatedly until the endpoin
1009:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  is ready to accept the next packet, allowing for early aborts of stream transfers.
1010:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1011:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *	The callback routine should be created according to the information in \ref Group_StreamCallb
1012:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbac
1013:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  disabled and this function has the Callback parameter omitted.
1014:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1015:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should not be used on CONTROL type endpoints.
1016:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1017:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1018:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1019:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer    Pointer to the destination data buffer to write to.
1020:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length    Number of bytes to send via the currently selected endpoint.
1021:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Callback  Name of a callback routine to call between successive USB packet trans
1022:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1023:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
1024:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1025:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_Stream_BE(void* Buffer,
1026:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                uint16_t Length
1027:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
1028:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1029:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Read_Stream_BE().
1030:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1031:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1032:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1033:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer    Pointer to the destination data buffer to write to, located in EEPROM 
1034:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length    Number of bytes to send via the currently selected endpoint.
1035:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Callback  Name of a callback routine to call between successive USB packet trans
1036:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1037:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_Stream_RW_ErrorCodes_t enum.
1038:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1039:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_EStream_BE(void* Buffer,
1040:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 uint16_t Length
1041:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                 __CALLBACK_PARAM) ATTR_NON_NULL_PTR_ARG(1);
1042:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1043:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes the given number of bytes to the CONTROL type endpoint from the given buffer in littl
1044:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  sending full packets to the host as needed. The host OUT acknowledgement is not automaticall
1045:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  in both failure and success states; the user is responsible for manually clearing the setup 
1046:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  finalize the transfer via the \ref Endpoint_ClearOUT() macro.
1047:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1048:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1049:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1050:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1051:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1052:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1053:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1054:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1055:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1056:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1057:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1058:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1059:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer  Pointer to the source data buffer to read from.
1060:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length  Number of bytes to read for the currently selected endpoint into the buff
1061:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1062:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1063:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1064:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Control_Stream_LE(const void* Buffer,
1065:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                         uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1066:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1067:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of Endpoint_Write_Control_Stream_LE.
1068:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1069:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1070:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1071:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1072:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1073:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1074:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1075:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1076:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1077:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1078:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1079:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1080:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer  Pointer to the source data buffer to read from.
1081:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length  Number of bytes to read for the currently selected endpoint into the buff
1082:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1083:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1084:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1085:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Control_EStream_LE(const void* Buffer,
1086:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                          uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1087:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1088:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** FLASH buffer source version of \ref Endpoint_Write_Control_Stream_LE().
1089:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1090:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \pre The FLASH data must be located in the first 64KB of FLASH for this function to work cor
1091:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1092:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1093:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1094:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1095:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1096:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1097:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1098:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1099:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1100:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1101:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1102:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1103:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer  Pointer to the source data buffer to read from.
1104:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length  Number of bytes to read for the currently selected endpoint into the buff
1105:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1106:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1107:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1108:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Control_PStream_LE(const void* Buffer,
1109:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                          uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1110:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1111:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Writes the given number of bytes to the CONTROL type endpoint from the given buffer in big e
1112:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  sending full packets to the host as needed. The host OUT acknowledgement is not automaticall
1113:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  in both failure and success states; the user is responsible for manually clearing the setup 
1114:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  finalize the transfer via the \ref Endpoint_ClearOUT() macro.
1115:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1116:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1117:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1118:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1119:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1120:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1121:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1122:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1123:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1124:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1125:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1126:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1127:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer  Pointer to the source data buffer to read from.
1128:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length  Number of bytes to read for the currently selected endpoint into the buff
1129:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1130:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1131:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1132:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Control_Stream_BE(const void* Buffer,
1133:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                         uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1134:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1135:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Write_Control_Stream_BE().
1136:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1137:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1138:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1139:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1140:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1141:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1142:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1143:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1144:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1145:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1146:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1147:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1148:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer  Pointer to the source data buffer to read from.
1149:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length  Number of bytes to read for the currently selected endpoint into the buff
1150:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1151:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1152:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1153:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Control_EStream_BE(const void* Buffer,
1154:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                          uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1155:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1156:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** FLASH buffer source version of \ref Endpoint_Write_Control_Stream_BE().
1157:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1158:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \pre The FLASH data must be located in the first 64KB of FLASH for this function to work cor
1159:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1160:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1161:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1162:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1163:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1164:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1165:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1166:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1167:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1168:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1169:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1170:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1171:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Buffer  Pointer to the source data buffer to read from.
1172:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in] Length  Number of bytes to read for the currently selected endpoint into the buff
1173:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1174:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1175:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1176:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Write_Control_PStream_BE(const void* Buffer,
1177:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                          uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1178:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1179:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads the given number of bytes from the CONTROL endpoint from the given buffer in little en
1180:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding fully read packets from the host as needed. The device IN acknowledgement is not
1181:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  automatically sent after success or failure states; the user is responsible for manually sen
1182:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  setup IN to finalize the transfer via the \ref Endpoint_ClearIN() macro.
1183:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1184:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1185:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1186:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1187:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1188:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1189:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1190:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1191:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1192:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1193:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1194:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1195:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer  Pointer to the destination data buffer to write to.
1196:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length  Number of bytes to send via the currently selected endpoint.
1197:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1198:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1199:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1200:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_Control_Stream_LE(void* Buffer,
1201:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                        uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1202:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1203:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Read_Control_Stream_LE().
1204:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1205:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1206:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1207:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1208:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1209:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1210:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1211:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1212:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1213:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1214:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1215:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1216:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer  Pointer to the destination data buffer to write to.
1217:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length  Number of bytes to send via the currently selected endpoint.
1218:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1219:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1220:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1221:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_Control_EStream_LE(void* Buffer,
1222:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                         uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1223:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1224:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** Reads the given number of bytes from the CONTROL endpoint from the given buffer in big endia
1225:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  discarding fully read packets from the host as needed. The device IN acknowledgement is not
1226:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  automatically sent after success or failure states; the user is responsible for manually sen
1227:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  setup IN to finalize the transfer via the \ref Endpoint_ClearIN() macro.
1228:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1229:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1230:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1231:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1232:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1233:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1234:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1235:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1236:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1237:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1238:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1239:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1240:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer  Pointer to the destination data buffer to write to.
1241:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length  Number of bytes to send via the currently selected endpoint.
1242:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1243:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1244:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1245:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_Control_Stream_BE(void* Buffer,
1246:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                        uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1247:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
1248:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			/** EEPROM buffer source version of \ref Endpoint_Read_Control_Stream_BE().
1249:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1250:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This function automatically clears the control transfer's status stage. Do not manuall
1251:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        to clear the status stage when using this routine in a control transaction.
1252:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *        \n\n
1253:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1254:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \note This routine should only be used on CONTROL type endpoints.
1255:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1256:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \warning Unlike the standard stream read/write commands, the control stream commands cannot 
1257:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *           together; i.e. the entire stream data must be read or written at the one time.
1258:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1259:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \ingroup Group_EndpointStreamRW
1260:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1261:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[out] Buffer  Pointer to the destination data buffer to write to.
1262:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \param[in]  Length  Number of bytes to send via the currently selected endpoint.
1263:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *
1264:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 *  \return A value from the \ref Endpoint_ControlStream_RW_ErrorCodes_t enum.
1265:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			 */
1266:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_Read_Control_EStream_BE(void* Buffer,
1267:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                         uint16_t Length) ATTR_NON_NULL_PTR_ARG(1);
1268:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1269:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	/* Private Interface - For use in library only: */
1270:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 	#if !defined(__DOXYGEN__)
1271:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Macros: */
1272:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_MAXSIZE(n)               _ENDPOINT_GET_MAXSIZE2(ENDPOINT_DETAILS_EP ## n)
1273:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_MAXSIZE2(details)        _ENDPOINT_GET_MAXSIZE3(details)
1274:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_MAXSIZE3(maxsize, db)    maxsize
1275:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1276:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_DOUBLEBANK(n)            _ENDPOINT_GET_DOUBLEBANK2(ENDPOINT_DETAILS_EP ## 
1277:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_DOUBLEBANK2(details)     _ENDPOINT_GET_DOUBLEBANK3(details)
1278:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define _ENDPOINT_GET_DOUBLEBANK3(maxsize, db) db
1279:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
1280:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
1281:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP0               64,  true
1282:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP1               256, true
1283:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP2               64,  true
1284:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP3               64,  true
1285:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP4               64,  true
1286:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP5               64,  true
1287:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP6               64,  true
1288:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#else
1289:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP0               64,  true
1290:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP1               64,  false
1291:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP2               64,  false
1292:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP3               64,  true
1293:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#define ENDPOINT_DETAILS_EP4               64,  true			
1294:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#endif
1295:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1296:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			#define Endpoint_ConfigureEndpoint(Number, Type, Direction, Size, Banks)                        
1297:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                     (__builtin_constant_p(Size) ? Endpoint_ConfigureEndpointStatic((Number),   
1298:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                                    (Type),     
1299:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                                    (Direction),
1300:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                                    Size, Banks)
1301:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                   Endpoint_ConfigureEndpointDynamic((Number),  
1302:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                                     (Type),    
1303:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                                     (Direction)
1304:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                                                     Size, Banks
1305:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1306:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Function Prototypes: */
1307:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			void    Endpoint_ClearEndpoints(void);
1308:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			uint8_t Endpoint_BytesToEPSizeMaskDynamic(const uint16_t Size);
1309:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			bool    Endpoint_ConfigureEndpoint_Prv(const uint8_t Number,
1310:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                       const uint8_t UECFG0XData,
1311:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                       const uint8_t UECFG1XData);			
1312:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 
1313:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 		/* Inline Functions: */
1314:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT A
1315:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
1316:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
1317:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint8_t  MaskVal    = 0;
1318:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				uint16_t CheckBytes = 8;
1319:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
1320:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				while (CheckBytes < Bytes)
1321:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				{
1322:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					MaskVal++;
1323:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 					CheckBytes <<= 1;
1324:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				}
1325:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				
1326:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return (MaskVal << EPSIZE0);
1327:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
1328:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			
1329:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			static inline bool Endpoint_ConfigureEndpointStatic(const uint8_t Number,
1330:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                    const uint8_t Type,
1331:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                    const uint8_t Direction,
1332:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                    const uint16_t Size,
1333:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			                                                    const uint8_t Banks)
1334:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			{
1335:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
 266               		.loc 7 1335 0
 267 0002 42E0      		ldi r20,lo8(2)
 268 0004 61EC      		ldi r22,lo8(-63)
 269 0006 81E0      		ldi r24,lo8(1)
 270 0008 0E94 0000 		call Endpoint_ConfigureEndpoint_Prv
 271               	.LVL15:
 272 000c C82F      		mov r28,r24
 273               	.LVL16:
 274               	.LBE131:
 275               	.LBE130:
 276               	.LBB132:
 277               	.LBB133:
 278 000e 42E0      		ldi r20,lo8(2)
 279 0010 60EC      		ldi r22,lo8(-64)
 280 0012 82E0      		ldi r24,lo8(2)
 281 0014 0E94 0000 		call Endpoint_ConfigureEndpoint_Prv
 282               	.LVL17:
 283               	.LBE133:
 284               	.LBE132:
 285               	.LBB134:
 286               	.LBB135:
 287               		.file 8 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h"
   1:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** /*
   2:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****              LUFA Library
   3:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****      Copyright (C) Dean Camera, 2010.
   4:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****               
   5:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   dean [at] fourwalledcubicle [dot] com
   6:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****       www.fourwalledcubicle.com
   7:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** */
   8:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
   9:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** /*
  10:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   Copyright 2010  Dean Camera (dean [at] fourwalledcubicle [dot] com)
  11:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  12:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   Permission to use, copy, modify, distribute, and sell this 
  13:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   software and its documentation for any purpose is hereby granted
  14:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   without fee, provided that the above copyright notice appear in 
  15:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   all copies and that both that the copyright notice and this
  16:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   permission notice and warranty disclaimer appear in supporting 
  17:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   documentation, and that the name of the author not be used in 
  18:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   advertising or publicity pertaining to distribution of the 
  19:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   software without specific, written prior permission.
  20:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  21:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   The author disclaim all warranties with regard to this
  22:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   software, including all implied warranties of merchantability
  23:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   and fitness.  In no event shall the author be liable for any
  24:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   special, indirect or consequential damages or any damages
  25:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   whatsoever resulting from loss of use, data or profits, whether
  26:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   in an action of contract, negligence or other tortious action,
  27:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   arising out of or in connection with the use or performance of
  28:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****   this software.
  29:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** */
  30:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  31:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** /** \file
  32:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  \brief USB device mode definitions.
  33:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *
  34:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  This file contains structures, function prototypes and macros related to USB device mode.
  35:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *
  36:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  \note This file should not be included directly. It is automatically included as needed by the 
  37:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *        dispatch header located in LUFA/Drivers/USB/USB.h.
  38:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  */
  39:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  40:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** /** \ingroup Group_USB
  41:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  @defgroup Group_Device Device Management
  42:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *
  43:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  USB Device mode related macros and enums. This module contains macros and enums which are used 
  44:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  the USB controller is initialized in device mode.
  45:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *
  46:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  *  @{
  47:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h ****  */
  48:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  49:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** #ifndef __USBDEVICE_H__
  50:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** #define __USBDEVICE_H__
  51:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  52:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 	/* Includes: */
  53:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include <avr/io.h>
  54:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include <avr/pgmspace.h>
  55:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include <avr/eeprom.h>
  56:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  57:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include "../../../Common/Common.h"	
  58:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include "../HighLevel/StdDescriptors.h"
  59:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include "USBInterrupt.h"
  60:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#include "Endpoint.h"
  61:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  62:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 	/* Preprocessor Checks: */
  63:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#if (defined(USE_RAM_DESCRIPTORS) && defined(USE_EEPROM_DESCRIPTORS))
  64:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			#error USE_RAM_DESCRIPTORS and USE_EEPROM_DESCRIPTORS are mutually exclusive.
  65:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#endif
  66:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  67:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#if !defined(__INCLUDE_FROM_USB_DRIVER)
  68:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			#error Do not include this file directly. Include LUFA/Drivers/USB/USB.h instead.
  69:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		#endif
  70:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			
  71:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 	/* Public Interface - May be used in end-application: */
  72:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		/* Macros: */
  73:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR) || defin
  74:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				/** Mask for the Options parameter of the \ref USB_Init() function. This indicates that the
  75:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *  USB interface should be initialized in low speed (1.5Mb/s) mode.
  76:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *
  77:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *  \note Low Speed mode is not available on all USB AVR models.
  78:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *        \n\n
  79:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *
  80:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *  \note Restrictions apply on the number, size and type of endpoints which can be used
  81:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 *        when running in low speed mode -- refer to the USB 2.0 standard.
  82:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				 */
  83:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				#define USB_DEVICE_OPT_LOWSPEED            (1 << 0)
  84:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			#endif
  85:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			
  86:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			/** Mask for the Options parameter of the \ref USB_Init() function. This indicates that the
  87:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  USB interface should be initialized in full speed (12Mb/s) mode.
  88:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 */
  89:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			#define USB_DEVICE_OPT_FULLSPEED               (0 << 0)
  90:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 
  91:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		/* Function Prototypes: */
  92:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			/** Sends a Remote Wakeup request to the host. This signals to the host that the device should
  93:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  be taken out of suspended mode, and communications should resume.
  94:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *
  95:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  Typically, this is implemented so that HID devices (mice, keyboards, etc.) can wake up the
  96:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  host computer when the host has suspended all USB devices to enter a low power state.
  97:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *
  98:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  \note This macro should only be used if the device has indicated to the host that it
  99:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        supports the Remote Wakeup feature in the device descriptors, and should only be
 100:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        issued if the host is currently allowing remote wakeup events from the device (i.e.,
 101:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        the \ref USB_RemoteWakeupEnabled flag is set). When the NO_DEVICE_REMOTE_WAKEUP compil
 102:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        time option is used, this macro is unavailable.
 103:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        \n
 104:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *
 105:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  \note The USB clock must be running for this function to operate. If the stack is initialize
 106:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        the \ref USB_OPT_MANUAL_PLL option enabled, the user must ensure that the PLL is runni
 107:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *        before attempting to call this function.
 108:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *
 109:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  \see \ref Group_Descriptors for more information on the RMWAKEUP feature and device descript
 110:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 */
 111:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			void USB_Device_SendRemoteWakeup(void);
 112:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			
 113:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		/* Type Defines: */
 114:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			enum USB_Device_States_t
 115:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			{
 116:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				DEVICE_STATE_Unattached                   = 0, /**< Internally implemented by the library. This
 117:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   that the device is not currently connected 
 118:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                */
 119:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				DEVICE_STATE_Powered                      = 1, /**< Internally implemented by the library. This
 120:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   that the device is connected to a host, but
 121:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   yet begun.
 122:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                */
 123:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				DEVICE_STATE_Default                      = 2, /**< Internally implemented by the library. This
 124:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   that the device's USB bus has been reset by
 125:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   now waiting for the host to begin the enume
 126:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                */
 127:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				DEVICE_STATE_Addressed                    = 3, /**< Internally implemented by the library. This
 128:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   that the device has been addressed by the U
 129:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   yet configured.
 130:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                */
 131:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				DEVICE_STATE_Configured                   = 4, /**< May be implemented by the user project. Thi
 132:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   that the device has been enumerated by the 
 133:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   for USB communications to begin.
 134:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                */
 135:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				DEVICE_STATE_Suspended                    = 5, /**< May be implemented by the user project. Thi
 136:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   that the USB bus has been suspended by the 
 137:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   should power down to a minimal power level 
 138:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                *   resumed.
 139:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				                                                */
 140:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			};
 141:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			
 142:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 		/* Inline Functions: */
 143:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			/** Enables the device mode Start Of Frame events. When enabled, this causes the
 144:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  \ref EVENT_USB_Device_StartOfFrame() event to fire once per millisecond, synchronized to the
 145:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 *  at the start of each USB frame when enumerated in device mode.
 146:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			 */
 147:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			static inline void USB_Device_EnableSOFEvents(void) ATTR_ALWAYS_INLINE;
 148:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			static inline void USB_Device_EnableSOFEvents(void)
 149:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 			{
 150:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Device.h **** 				USB_INT_Enable(USB_INT_SOFI);
 288               		.loc 8 150 0
 289 0018 9091 E200 		lds r25,226
 290 001c 9460      		ori r25,lo8(4)
 291 001e 9093 E200 		sts 226,r25
 292               	.LBE135:
 293               	.LBE134:
 242:Arduino-serialusbkeyboard.c **** 	// CDC_Device_ConfigureEndpoints(&VirtualSerial_CDC_Interface);
 243:Arduino-serialusbkeyboard.c **** 
 244:Arduino-serialusbkeyboard.c **** 
 245:Arduino-serialusbkeyboard.c **** 	bool ConfigSuccess = true;
 246:Arduino-serialusbkeyboard.c **** 
 247:Arduino-serialusbkeyboard.c **** 	/* Setup HID Report Endpoints */
 248:Arduino-serialusbkeyboard.c **** 	ConfigSuccess &= Endpoint_ConfigureEndpoint(KEYBOARD_IN_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_IN,
 249:Arduino-serialusbkeyboard.c **** 	                                            KEYBOARD_EPSIZE, ENDPOINT_BANK_SINGLE);
 250:Arduino-serialusbkeyboard.c **** 	ConfigSuccess &= Endpoint_ConfigureEndpoint(KEYBOARD_OUT_EPNUM, EP_TYPE_INTERRUPT, ENDPOINT_DIR_OU
 251:Arduino-serialusbkeyboard.c **** 	                                            KEYBOARD_EPSIZE, ENDPOINT_BANK_SINGLE);
 252:Arduino-serialusbkeyboard.c **** 
 253:Arduino-serialusbkeyboard.c **** 	/* Turn on Start-of-Frame events for tracking HID report period exiry */
 254:Arduino-serialusbkeyboard.c **** 	USB_Device_EnableSOFEvents();
 255:Arduino-serialusbkeyboard.c **** 
 256:Arduino-serialusbkeyboard.c **** 	/* Indicate endpoint configuration success or failure */
 257:Arduino-serialusbkeyboard.c **** 	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
 294               		.loc 4 257 0
 295 0022 8823      		tst r24
 296 0024 01F0      		breq .L12
 297 0026 80E1      		ldi r24,lo8(16)
 298               	.LVL18:
 299 0028 C111      		cpse r28,__zero_reg__
 300 002a 00C0      		rjmp .L9
 301               	.L12:
 302 002c 80E2      		ldi r24,lo8(32)
 303               	.L9:
 304               	/* epilogue start */
 258:Arduino-serialusbkeyboard.c **** }
 305               		.loc 4 258 0 discriminator 4
 306 002e CF91      		pop r28
 257:Arduino-serialusbkeyboard.c **** }
 307               		.loc 4 257 0 discriminator 4
 308 0030 0C94 0000 		jmp LEDs_SetAllLEDs
 309               	.LVL19:
 310               		.cfi_endproc
 311               	.LFE92:
 313               		.section	.text.EVENT_USB_Device_StartOfFrame,"ax",@progbits
 314               	.global	EVENT_USB_Device_StartOfFrame
 316               	EVENT_USB_Device_StartOfFrame:
 317               	.LFB94:
 259:Arduino-serialusbkeyboard.c **** 
 260:Arduino-serialusbkeyboard.c **** /** Event handler for the library USB Unhandled Control Request event. */
 261:Arduino-serialusbkeyboard.c **** void EVENT_USB_Device_UnhandledControlRequest(void)
 262:Arduino-serialusbkeyboard.c **** {
 263:Arduino-serialusbkeyboard.c **** 	// CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
 264:Arduino-serialusbkeyboard.c **** 
 265:Arduino-serialusbkeyboard.c **** 
 266:Arduino-serialusbkeyboard.c **** 	/* Handle HID Class specific requests */
 267:Arduino-serialusbkeyboard.c **** 	switch (USB_ControlRequest.bRequest)
 268:Arduino-serialusbkeyboard.c **** 	{
 269:Arduino-serialusbkeyboard.c **** 		case REQ_GetReport:
 270:Arduino-serialusbkeyboard.c **** 			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE)
 271:Arduino-serialusbkeyboard.c **** 			{
 272:Arduino-serialusbkeyboard.c **** 				USB_KeyboardReport_Data_t KeyboardReportData;
 273:Arduino-serialusbkeyboard.c **** 
 274:Arduino-serialusbkeyboard.c **** 				/* Create the next keyboard report for transmission to the host */
 275:Arduino-serialusbkeyboard.c **** 				CreateKeyboardReport(&KeyboardReportData);
 276:Arduino-serialusbkeyboard.c **** 
 277:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearSETUP();
 278:Arduino-serialusbkeyboard.c **** 
 279:Arduino-serialusbkeyboard.c **** 				/* Write the report data to the control endpoint */
 280:Arduino-serialusbkeyboard.c **** 				Endpoint_Write_Control_Stream_LE(&KeyboardReportData, sizeof(KeyboardReportData));
 281:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearOUT();
 282:Arduino-serialusbkeyboard.c **** 			}
 283:Arduino-serialusbkeyboard.c **** 
 284:Arduino-serialusbkeyboard.c **** 			break;
 285:Arduino-serialusbkeyboard.c **** 		case REQ_SetReport:
 286:Arduino-serialusbkeyboard.c **** 			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE)
 287:Arduino-serialusbkeyboard.c **** 			{
 288:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearSETUP();
 289:Arduino-serialusbkeyboard.c **** 
 290:Arduino-serialusbkeyboard.c **** 				/* Wait until the LED report has been sent by the host */
 291:Arduino-serialusbkeyboard.c **** 				while (!(Endpoint_IsOUTReceived()))
 292:Arduino-serialusbkeyboard.c **** 				{
 293:Arduino-serialusbkeyboard.c **** 					if (USB_DeviceState == DEVICE_STATE_Unattached)
 294:Arduino-serialusbkeyboard.c **** 					  return;
 295:Arduino-serialusbkeyboard.c **** 				}
 296:Arduino-serialusbkeyboard.c **** 
 297:Arduino-serialusbkeyboard.c **** 				/* Read in the LED report from the host */
 298:Arduino-serialusbkeyboard.c **** 				uint8_t LEDStatus = Endpoint_Read_Byte();
 299:Arduino-serialusbkeyboard.c **** 
 300:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearOUT();
 301:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearStatusStage();
 302:Arduino-serialusbkeyboard.c **** 
 303:Arduino-serialusbkeyboard.c **** 				/* Process the incoming LED report */
 304:Arduino-serialusbkeyboard.c **** 				ProcessLEDReport(LEDStatus);
 305:Arduino-serialusbkeyboard.c **** 			}
 306:Arduino-serialusbkeyboard.c **** 
 307:Arduino-serialusbkeyboard.c **** 			break;
 308:Arduino-serialusbkeyboard.c **** 		case REQ_GetProtocol:
 309:Arduino-serialusbkeyboard.c **** 			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE)
 310:Arduino-serialusbkeyboard.c **** 			{
 311:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearSETUP();
 312:Arduino-serialusbkeyboard.c **** 
 313:Arduino-serialusbkeyboard.c **** 				/* Write the current protocol flag to the host */
 314:Arduino-serialusbkeyboard.c **** 				Endpoint_Write_Byte(UsingReportProtocol);
 315:Arduino-serialusbkeyboard.c **** 
 316:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearIN();
 317:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearStatusStage();
 318:Arduino-serialusbkeyboard.c **** 			}
 319:Arduino-serialusbkeyboard.c **** 
 320:Arduino-serialusbkeyboard.c **** 			break;
 321:Arduino-serialusbkeyboard.c **** 		case REQ_SetProtocol:
 322:Arduino-serialusbkeyboard.c **** 			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE)
 323:Arduino-serialusbkeyboard.c **** 			{
 324:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearSETUP();
 325:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearStatusStage();
 326:Arduino-serialusbkeyboard.c **** 
 327:Arduino-serialusbkeyboard.c **** 				/* Set or clear the flag depending on what the host indicates that the current Protocol should 
 328:Arduino-serialusbkeyboard.c **** 				UsingReportProtocol = (USB_ControlRequest.wValue != 0);
 329:Arduino-serialusbkeyboard.c **** 			}
 330:Arduino-serialusbkeyboard.c **** 
 331:Arduino-serialusbkeyboard.c **** 			break;
 332:Arduino-serialusbkeyboard.c **** 		case REQ_SetIdle:
 333:Arduino-serialusbkeyboard.c **** 			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE)
 334:Arduino-serialusbkeyboard.c **** 			{
 335:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearSETUP();
 336:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearStatusStage();
 337:Arduino-serialusbkeyboard.c **** 
 338:Arduino-serialusbkeyboard.c **** 				/* Get idle period in MSB, IdleCount must be multiplied by 4 to get number of milliseconds */
 339:Arduino-serialusbkeyboard.c **** 				IdleCount = ((USB_ControlRequest.wValue & 0xFF00) >> 6);
 340:Arduino-serialusbkeyboard.c **** 			}
 341:Arduino-serialusbkeyboard.c **** 
 342:Arduino-serialusbkeyboard.c **** 			break;
 343:Arduino-serialusbkeyboard.c **** 		case REQ_GetIdle:
 344:Arduino-serialusbkeyboard.c **** 			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE)
 345:Arduino-serialusbkeyboard.c **** 			{
 346:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearSETUP();
 347:Arduino-serialusbkeyboard.c **** 
 348:Arduino-serialusbkeyboard.c **** 				/* Write the current idle duration to the host, must be divided by 4 before sent to host */
 349:Arduino-serialusbkeyboard.c **** 				Endpoint_Write_Byte(IdleCount >> 2);
 350:Arduino-serialusbkeyboard.c **** 
 351:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearIN();
 352:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearStatusStage();
 353:Arduino-serialusbkeyboard.c **** 			}
 354:Arduino-serialusbkeyboard.c **** 
 355:Arduino-serialusbkeyboard.c **** 			break;
 356:Arduino-serialusbkeyboard.c **** 	}
 357:Arduino-serialusbkeyboard.c **** }
 358:Arduino-serialusbkeyboard.c **** 
 359:Arduino-serialusbkeyboard.c **** /** Event handler for the USB device Start Of Frame event. */
 360:Arduino-serialusbkeyboard.c **** void EVENT_USB_Device_StartOfFrame(void)
 361:Arduino-serialusbkeyboard.c **** {
 318               		.loc 4 361 0
 319               		.cfi_startproc
 320               	/* prologue: function */
 321               	/* frame size = 0 */
 322               	/* stack size = 0 */
 323               	.L__stack_usage = 0
 362:Arduino-serialusbkeyboard.c **** 	/* One millisecond has elapsed, decrement the idle time remaining counter if it has not already el
 363:Arduino-serialusbkeyboard.c **** 	if (IdleMSRemaining)
 324               		.loc 4 363 0
 325 0000 8091 0000 		lds r24,IdleMSRemaining
 326 0004 9091 0000 		lds r25,IdleMSRemaining+1
 327 0008 0097      		sbiw r24,0
 328 000a 01F0      		breq .L16
 364:Arduino-serialusbkeyboard.c **** 	  IdleMSRemaining--;
 329               		.loc 4 364 0
 330 000c 0197      		sbiw r24,1
 331 000e 9093 0000 		sts IdleMSRemaining+1,r25
 332 0012 8093 0000 		sts IdleMSRemaining,r24
 333               	.L16:
 334               	/* epilogue start */
 365:Arduino-serialusbkeyboard.c **** }
 335               		.loc 4 365 0
 336 0016 0895      		ret
 337               		.cfi_endproc
 338               	.LFE94:
 340               		.section	.text.CreateKeyboardReport,"ax",@progbits
 341               	.global	CreateKeyboardReport
 343               	CreateKeyboardReport:
 344               	.LFB95:
 366:Arduino-serialusbkeyboard.c **** 
 367:Arduino-serialusbkeyboard.c **** /** Fills the given HID report data structure with the next HID report to send to the host.
 368:Arduino-serialusbkeyboard.c ****  *
 369:Arduino-serialusbkeyboard.c ****  *  \param[out] ReportData  Pointer to a HID report data structure to be filled
 370:Arduino-serialusbkeyboard.c ****  */
 371:Arduino-serialusbkeyboard.c **** void CreateKeyboardReport(USB_KeyboardReport_Data_t* const ReportData)
 372:Arduino-serialusbkeyboard.c **** {
 345               		.loc 4 372 0
 346               		.cfi_startproc
 347               	.LVL20:
 348 0000 CF93      		push r28
 349               	.LCFI3:
 350               		.cfi_def_cfa_offset 3
 351               		.cfi_offset 28, -2
 352 0002 DF93      		push r29
 353               	.LCFI4:
 354               		.cfi_def_cfa_offset 4
 355               		.cfi_offset 29, -3
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 2 */
 359               	.L__stack_usage = 2
 360 0004 FC01      		movw r30,r24
 373:Arduino-serialusbkeyboard.c **** 	// uint8_t JoyStatus_LCL     = Joystick_GetStatus();
 374:Arduino-serialusbkeyboard.c **** 	// uint8_t ButtonStatus_LCL  = Buttons_GetStatus();
 375:Arduino-serialusbkeyboard.c **** 
 376:Arduino-serialusbkeyboard.c ****     /* Clear the report contents */
 377:Arduino-serialusbkeyboard.c ****     memset(ReportData, 0, sizeof(USB_KeyboardReport_Data_t));
 361               		.loc 4 377 0
 362 0006 88E0      		ldi r24,lo8(8)
 363               	.LVL21:
 364 0008 DF01      		movw r26,r30
 365               		0:
 366 000a 1D92      		st X+,__zero_reg__
 367 000c 8A95      		dec r24
 368 000e 01F4      		brne 0b
 378:Arduino-serialusbkeyboard.c **** 
 379:Arduino-serialusbkeyboard.c **** 
 380:Arduino-serialusbkeyboard.c ****                 /* Make sent key uppercase by indicating that the left shift key is pressed */
 381:Arduino-serialusbkeyboard.c ****                 ReportData->Modifier = 0;
 369               		.loc 4 381 0
 370 0010 1082      		st Z,__zero_reg__
 382:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe0] == 0x55)
 371               		.loc 4 382 0
 372 0012 8091 0000 		lds r24,scancode_buffer+224
 373 0016 8535      		cpi r24,lo8(85)
 374 0018 01F4      		brne .L22
 383:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_LEFTCTRL;
 375               		.loc 4 383 0
 376 001a 81E0      		ldi r24,lo8(1)
 377 001c 8083      		st Z,r24
 378               	.L22:
 384:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe1] == 0x55)
 379               		.loc 4 384 0
 380 001e 8091 0000 		lds r24,scancode_buffer+225
 381 0022 8535      		cpi r24,lo8(85)
 382 0024 01F4      		brne .L23
 385:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_LEFTSHIFT;
 383               		.loc 4 385 0
 384 0026 8081      		ld r24,Z
 385 0028 8260      		ori r24,lo8(2)
 386 002a 8083      		st Z,r24
 387               	.L23:
 386:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe2] == 0x55)
 388               		.loc 4 386 0
 389 002c 8091 0000 		lds r24,scancode_buffer+226
 390 0030 8535      		cpi r24,lo8(85)
 391 0032 01F4      		brne .L24
 387:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_LEFTALT;
 392               		.loc 4 387 0
 393 0034 8081      		ld r24,Z
 394 0036 8460      		ori r24,lo8(4)
 395 0038 8083      		st Z,r24
 396               	.L24:
 388:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe3] == 0x55)
 397               		.loc 4 388 0
 398 003a 8091 0000 		lds r24,scancode_buffer+227
 399 003e 8535      		cpi r24,lo8(85)
 400 0040 01F4      		brne .L25
 389:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_LEFTGUI;
 401               		.loc 4 389 0
 402 0042 8081      		ld r24,Z
 403 0044 8860      		ori r24,lo8(8)
 404 0046 8083      		st Z,r24
 405               	.L25:
 390:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe4] == 0x55)
 406               		.loc 4 390 0
 407 0048 8091 0000 		lds r24,scancode_buffer+228
 408 004c 8535      		cpi r24,lo8(85)
 409 004e 01F4      		brne .L26
 391:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTCTRL;
 410               		.loc 4 391 0
 411 0050 8081      		ld r24,Z
 412 0052 8061      		ori r24,lo8(16)
 413 0054 8083      		st Z,r24
 414               	.L26:
 392:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe5] == 0x55)
 415               		.loc 4 392 0
 416 0056 8091 0000 		lds r24,scancode_buffer+229
 417 005a 8535      		cpi r24,lo8(85)
 418 005c 01F4      		brne .L27
 393:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTSHIFT;
 419               		.loc 4 393 0
 420 005e 8081      		ld r24,Z
 421 0060 8062      		ori r24,lo8(32)
 422 0062 8083      		st Z,r24
 423               	.L27:
 394:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe6] == 0x55)
 424               		.loc 4 394 0
 425 0064 8091 0000 		lds r24,scancode_buffer+230
 426 0068 8535      		cpi r24,lo8(85)
 427 006a 01F4      		brne .L28
 395:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTALT;
 428               		.loc 4 395 0
 429 006c 8081      		ld r24,Z
 430 006e 8064      		ori r24,lo8(64)
 431 0070 8083      		st Z,r24
 432               	.L28:
 396:Arduino-serialusbkeyboard.c ****                 if(scancode_buffer[0xe7] == 0x55)
 433               		.loc 4 396 0
 434 0072 8091 0000 		lds r24,scancode_buffer+231
 435 0076 8535      		cpi r24,lo8(85)
 436 0078 01F4      		brne .L29
 397:Arduino-serialusbkeyboard.c ****                     ReportData->Modifier |= KEYBOARD_MODIFER_RIGHTGUI;
 437               		.loc 4 397 0
 438 007a 8081      		ld r24,Z
 439 007c 8068      		ori r24,lo8(-128)
 440 007e 8083      		st Z,r24
 441               	.L29:
 442 0080 A0E0      		ldi r26,lo8(scancode_buffer)
 443 0082 B0E0      		ldi r27,hi8(scancode_buffer)
 444               	.LVL22:
 372:Arduino-serialusbkeyboard.c **** 	// uint8_t JoyStatus_LCL     = Joystick_GetStatus();
 445               		.loc 4 372 0 discriminator 3
 446 0084 80E0      		ldi r24,0
 447 0086 90E0      		ldi r25,0
 448               	.LVL23:
 449               	.L32:
 450               	.LBB136:
 398:Arduino-serialusbkeyboard.c **** 
 399:Arduino-serialusbkeyboard.c ****                 for(uint8_t UsedKeyCodes = 0, i=0; UsedKeyCodes < 6 && i < 128; i++) {
 400:Arduino-serialusbkeyboard.c ****                     if(scancode_buffer[i] == 0x55)
 451               		.loc 4 400 0
 452 0088 2D91      		ld r18,X+
 453 008a 2535      		cpi r18,lo8(85)
 454 008c 01F4      		brne .L30
 455               	.LVL24:
 401:Arduino-serialusbkeyboard.c ****                         ReportData->KeyCode[UsedKeyCodes++] = i;
 456               		.loc 4 401 0
 457 008e EF01      		movw r28,r30
 458 0090 C90F      		add r28,r25
 459 0092 D11D      		adc r29,__zero_reg__
 460 0094 8A83      		std Y+2,r24
 461 0096 9F5F      		subi r25,lo8(-(1))
 462               	.LVL25:
 463               	.L30:
 399:Arduino-serialusbkeyboard.c ****                     if(scancode_buffer[i] == 0x55)
 464               		.loc 4 399 0 discriminator 2
 465 0098 8F5F      		subi r24,lo8(-(1))
 466               	.LVL26:
 467 009a 9630      		cpi r25,lo8(6)
 468 009c 01F4      		brne .L31
 469               	.L21:
 470               	/* epilogue start */
 471               	.LBE136:
 402:Arduino-serialusbkeyboard.c ****     }
 403:Arduino-serialusbkeyboard.c **** 
 404:Arduino-serialusbkeyboard.c **** }
 472               		.loc 4 404 0
 473 009e DF91      		pop r29
 474 00a0 CF91      		pop r28
 475 00a2 0895      		ret
 476               	.L31:
 477               	.LBB137:
 399:Arduino-serialusbkeyboard.c ****                     if(scancode_buffer[i] == 0x55)
 478               		.loc 4 399 0 discriminator 3
 479 00a4 8038      		cpi r24,lo8(-128)
 480 00a6 01F4      		brne .L32
 481 00a8 00C0      		rjmp .L21
 482               	.LBE137:
 483               		.cfi_endproc
 484               	.LFE95:
 486               		.section	.text.ProcessLEDReport,"ax",@progbits
 487               	.global	ProcessLEDReport
 489               	ProcessLEDReport:
 490               	.LFB96:
 405:Arduino-serialusbkeyboard.c **** 
 406:Arduino-serialusbkeyboard.c **** /** Processes a received LED report, and updates the board LEDs states to match.
 407:Arduino-serialusbkeyboard.c ****  *
 408:Arduino-serialusbkeyboard.c ****  *  \param[in] LEDReport  LED status report from the host
 409:Arduino-serialusbkeyboard.c ****  */
 410:Arduino-serialusbkeyboard.c **** void ProcessLEDReport(const uint8_t LEDReport)
 411:Arduino-serialusbkeyboard.c **** {
 491               		.loc 4 411 0
 492               		.cfi_startproc
 493               	.LVL27:
 494               	/* prologue: function */
 495               	/* frame size = 0 */
 496               	/* stack size = 0 */
 497               	.L__stack_usage = 0
 412:Arduino-serialusbkeyboard.c **** 	uint8_t LEDMask = LEDS_LED2;
 413:Arduino-serialusbkeyboard.c **** 
 414:Arduino-serialusbkeyboard.c **** 	if (LEDReport & KEYBOARD_LED_NUMLOCK)
 498               		.loc 4 414 0
 499 0000 80FF      		sbrs r24,0
 500 0002 00C0      		rjmp .L37
 415:Arduino-serialusbkeyboard.c **** 	  LEDMask |= LEDS_LED1;
 501               		.loc 4 415 0
 502 0004 80E3      		ldi r24,lo8(48)
 503               	.LVL28:
 504               	.L36:
 416:Arduino-serialusbkeyboard.c **** 
 417:Arduino-serialusbkeyboard.c **** 	if (LEDReport & KEYBOARD_LED_CAPSLOCK)
 418:Arduino-serialusbkeyboard.c **** 	  LEDMask |= LEDS_LED3;
 419:Arduino-serialusbkeyboard.c **** 
 420:Arduino-serialusbkeyboard.c **** 	if (LEDReport & KEYBOARD_LED_SCROLLLOCK)
 421:Arduino-serialusbkeyboard.c **** 	  LEDMask |= LEDS_LED4;
 422:Arduino-serialusbkeyboard.c **** 
 423:Arduino-serialusbkeyboard.c **** 	/* Set the status LEDs to the current Keyboard LED status */
 424:Arduino-serialusbkeyboard.c **** 	LEDs_SetAllLEDs(LEDMask);
 505               		.loc 4 424 0
 506 0006 0C94 0000 		jmp LEDs_SetAllLEDs
 507               	.LVL29:
 508               	.L37:
 412:Arduino-serialusbkeyboard.c **** 
 509               		.loc 4 412 0
 510 000a 80E1      		ldi r24,lo8(16)
 511               	.LVL30:
 512 000c 00C0      		rjmp .L36
 513               		.cfi_endproc
 514               	.LFE96:
 516               		.section	.text.EVENT_USB_Device_UnhandledControlRequest,"ax",@progbits
 517               	.global	EVENT_USB_Device_UnhandledControlRequest
 519               	EVENT_USB_Device_UnhandledControlRequest:
 520               	.LFB93:
 262:Arduino-serialusbkeyboard.c **** 	// CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
 521               		.loc 4 262 0
 522               		.cfi_startproc
 523 0000 1F93      		push r17
 524               	.LCFI5:
 525               		.cfi_def_cfa_offset 3
 526               		.cfi_offset 17, -2
 527 0002 CF93      		push r28
 528               	.LCFI6:
 529               		.cfi_def_cfa_offset 4
 530               		.cfi_offset 28, -3
 531 0004 DF93      		push r29
 532               	.LCFI7:
 533               		.cfi_def_cfa_offset 5
 534               		.cfi_offset 29, -4
 535 0006 CDB7      		in r28,__SP_L__
 536 0008 DEB7      		in r29,__SP_H__
 537               	.LCFI8:
 538               		.cfi_def_cfa_register 28
 539 000a 2897      		sbiw r28,8
 540               	.LCFI9:
 541               		.cfi_def_cfa_offset 13
 542 000c 0FB6      		in __tmp_reg__,__SREG__
 543 000e F894      		cli
 544 0010 DEBF      		out __SP_H__,r29
 545 0012 0FBE      		out __SREG__,__tmp_reg__
 546 0014 CDBF      		out __SP_L__,r28
 547               	/* prologue: function */
 548               	/* frame size = 8 */
 549               	/* stack size = 11 */
 550               	.L__stack_usage = 11
 267:Arduino-serialusbkeyboard.c **** 	{
 551               		.loc 4 267 0
 552 0016 8091 0000 		lds r24,USB_ControlRequest+1
 553 001a 8330      		cpi r24,lo8(3)
 554 001c 01F4      		brne .+2
 555 001e 00C0      		rjmp .L40
 556 0020 00F4      		brsh .L41
 557 0022 8130      		cpi r24,lo8(1)
 558 0024 01F0      		breq .L42
 559 0026 8230      		cpi r24,lo8(2)
 560 0028 01F4      		brne .+2
 561 002a 00C0      		rjmp .L43
 562               	.L38:
 563               	/* epilogue start */
 357:Arduino-serialusbkeyboard.c **** 
 564               		.loc 4 357 0
 565 002c 2896      		adiw r28,8
 566 002e 0FB6      		in __tmp_reg__,__SREG__
 567 0030 F894      		cli
 568 0032 DEBF      		out __SP_H__,r29
 569 0034 0FBE      		out __SREG__,__tmp_reg__
 570 0036 CDBF      		out __SP_L__,r28
 571 0038 DF91      		pop r29
 572 003a CF91      		pop r28
 573 003c 1F91      		pop r17
 574 003e 0895      		ret
 575               	.L41:
 267:Arduino-serialusbkeyboard.c **** 	{
 576               		.loc 4 267 0
 577 0040 8A30      		cpi r24,lo8(10)
 578 0042 01F4      		brne .+2
 579 0044 00C0      		rjmp .L44
 580 0046 8B30      		cpi r24,lo8(11)
 581 0048 01F4      		brne .+2
 582 004a 00C0      		rjmp .L45
 583 004c 8930      		cpi r24,lo8(9)
 584 004e 01F4      		brne .L38
 286:Arduino-serialusbkeyboard.c **** 			{
 585               		.loc 4 286 0
 586 0050 8091 0000 		lds r24,USB_ControlRequest
 587 0054 8132      		cpi r24,lo8(33)
 588 0056 01F4      		brne .L38
 589               	.LBB138:
 590               	.LBB139:
 591               	.LBB140:
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 592               		.loc 7 442 0
 593 0058 8091 E800 		lds r24,232
 594 005c 877F      		andi r24,lo8(-9)
 595 005e 8093 E800 		sts 232,r24
 596               	.L49:
 597               	.LBE140:
 598               	.LBE139:
 599               	.LBB141:
 600               	.LBB142:
 417:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 601               		.loc 7 417 0
 602 0062 8091 E800 		lds r24,232
 603               	.LBE142:
 604               	.LBE141:
 291:Arduino-serialusbkeyboard.c **** 				{
 605               		.loc 4 291 0
 606 0066 82FF      		sbrs r24,2
 607 0068 00C0      		rjmp .L50
 608               	.LBB143:
 609               	.LBB144:
 550:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 610               		.loc 7 550 0
 611 006a 1091 F100 		lds r17,241
 612               	.LBE144:
 613               	.LBE143:
 614               	.LBB145:
 615               	.LBB146:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 616               		.loc 7 469 0
 617 006e 8091 E800 		lds r24,232
 618 0072 8B77      		andi r24,lo8(123)
 619 0074 8093 E800 		sts 232,r24
 620               	.LBE146:
 621               	.LBE145:
 301:Arduino-serialusbkeyboard.c **** 
 622               		.loc 4 301 0
 623 0078 0E94 0000 		call Endpoint_ClearStatusStage
 624               	.LVL31:
 304:Arduino-serialusbkeyboard.c **** 			}
 625               		.loc 4 304 0
 626 007c 812F      		mov r24,r17
 627 007e 0E94 0000 		call ProcessLEDReport
 628               	.LVL32:
 629 0082 00C0      		rjmp .L38
 630               	.L42:
 631               	.LBE138:
 270:Arduino-serialusbkeyboard.c **** 			{
 632               		.loc 4 270 0
 633 0084 8091 0000 		lds r24,USB_ControlRequest
 634 0088 813A      		cpi r24,lo8(-95)
 635 008a 01F4      		brne .L38
 636               	.LBB147:
 275:Arduino-serialusbkeyboard.c **** 
 637               		.loc 4 275 0
 638 008c CE01      		movw r24,r28
 639 008e 0196      		adiw r24,1
 640 0090 0E94 0000 		call CreateKeyboardReport
 641               	.LVL33:
 642               	.LBB148:
 643               	.LBB149:
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 644               		.loc 7 442 0
 645 0094 8091 E800 		lds r24,232
 646 0098 877F      		andi r24,lo8(-9)
 647 009a 8093 E800 		sts 232,r24
 648               	.LBE149:
 649               	.LBE148:
 280:Arduino-serialusbkeyboard.c **** 				Endpoint_ClearOUT();
 650               		.loc 4 280 0
 651 009e 68E0      		ldi r22,lo8(8)
 652 00a0 70E0      		ldi r23,0
 653 00a2 CE01      		movw r24,r28
 654 00a4 0196      		adiw r24,1
 655 00a6 0E94 0000 		call Endpoint_Write_Control_Stream_LE
 656               	.LVL34:
 657               	.LBB150:
 658               	.LBB151:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 659               		.loc 7 469 0
 660 00aa 8091 E800 		lds r24,232
 661 00ae 8B77      		andi r24,lo8(123)
 662 00b0 8093 E800 		sts 232,r24
 663 00b4 00C0      		rjmp .L38
 664               	.L50:
 665               	.LBE151:
 666               	.LBE150:
 667               	.LBE147:
 668               	.LBB152:
 293:Arduino-serialusbkeyboard.c **** 					  return;
 669               		.loc 4 293 0
 670 00b6 8EB3      		in r24,0x1e
 671 00b8 8111      		cpse r24,__zero_reg__
 672 00ba 00C0      		rjmp .L49
 673 00bc 00C0      		rjmp .L38
 674               	.L40:
 675               	.LBE152:
 309:Arduino-serialusbkeyboard.c **** 			{
 676               		.loc 4 309 0
 677 00be 8091 0000 		lds r24,USB_ControlRequest
 678 00c2 813A      		cpi r24,lo8(-95)
 679 00c4 01F0      		breq .+2
 680 00c6 00C0      		rjmp .L38
 681               	.LBB153:
 682               	.LBB154:
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 683               		.loc 7 442 0
 684 00c8 8091 E800 		lds r24,232
 685 00cc 877F      		andi r24,lo8(-9)
 686 00ce 8093 E800 		sts 232,r24
 687               	.LBE154:
 688               	.LBE153:
 314:Arduino-serialusbkeyboard.c **** 
 689               		.loc 4 314 0
 690 00d2 8091 0000 		lds r24,UsingReportProtocol
 691               	.LVL35:
 692               	.L55:
 693               	.LBB155:
 694               	.LBB156:
 562:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 695               		.loc 7 562 0
 696 00d6 8093 F100 		sts 241,r24
 697               	.LVL36:
 698               	.LBE156:
 699               	.LBE155:
 700               	.LBB157:
 701               	.LBB158:
 454:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 702               		.loc 7 454 0
 703 00da 8091 E800 		lds r24,232
 704 00de 8E77      		andi r24,lo8(126)
 705 00e0 8093 E800 		sts 232,r24
 706               	.LBE158:
 707               	.LBE157:
 352:Arduino-serialusbkeyboard.c **** 			}
 708               		.loc 4 352 0
 709 00e4 0E94 0000 		call Endpoint_ClearStatusStage
 710               	.LVL37:
 711 00e8 00C0      		rjmp .L38
 712               	.L45:
 322:Arduino-serialusbkeyboard.c **** 			{
 713               		.loc 4 322 0
 714 00ea 8091 0000 		lds r24,USB_ControlRequest
 715 00ee 8132      		cpi r24,lo8(33)
 716 00f0 01F0      		breq .+2
 717 00f2 00C0      		rjmp .L38
 718               	.LBB159:
 719               	.LBB160:
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 720               		.loc 7 442 0
 721 00f4 8091 E800 		lds r24,232
 722 00f8 877F      		andi r24,lo8(-9)
 723 00fa 8093 E800 		sts 232,r24
 724               	.LBE160:
 725               	.LBE159:
 325:Arduino-serialusbkeyboard.c **** 
 726               		.loc 4 325 0
 727 00fe 0E94 0000 		call Endpoint_ClearStatusStage
 728               	.LVL38:
 328:Arduino-serialusbkeyboard.c **** 			}
 729               		.loc 4 328 0
 730 0102 81E0      		ldi r24,lo8(1)
 731 0104 2091 0000 		lds r18,USB_ControlRequest+2
 732 0108 3091 0000 		lds r19,USB_ControlRequest+2+1
 733 010c 232B      		or r18,r19
 734 010e 01F4      		brne .L51
 735 0110 80E0      		ldi r24,0
 736               	.L51:
 737 0112 8093 0000 		sts UsingReportProtocol,r24
 738 0116 00C0      		rjmp .L38
 739               	.L44:
 333:Arduino-serialusbkeyboard.c **** 			{
 740               		.loc 4 333 0
 741 0118 8091 0000 		lds r24,USB_ControlRequest
 742 011c 8132      		cpi r24,lo8(33)
 743 011e 01F0      		breq .+2
 744 0120 00C0      		rjmp .L38
 745               	.LBB161:
 746               	.LBB162:
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 747               		.loc 7 442 0
 748 0122 8091 E800 		lds r24,232
 749 0126 877F      		andi r24,lo8(-9)
 750 0128 8093 E800 		sts 232,r24
 751               	.LBE162:
 752               	.LBE161:
 336:Arduino-serialusbkeyboard.c **** 
 753               		.loc 4 336 0
 754 012c 0E94 0000 		call Endpoint_ClearStatusStage
 755               	.LVL39:
 339:Arduino-serialusbkeyboard.c **** 			}
 756               		.loc 4 339 0
 757 0130 8091 0000 		lds r24,USB_ControlRequest+2
 758 0134 9091 0000 		lds r25,USB_ControlRequest+2+1
 759 0138 36E0      		ldi r19,6
 760               		1:
 761 013a 9695      		lsr r25
 762 013c 8795      		ror r24
 763 013e 3A95      		dec r19
 764 0140 01F4      		brne 1b
 765 0142 8C7F      		andi r24,252
 766 0144 9370      		andi r25,3
 767 0146 9093 0000 		sts IdleCount+1,r25
 768 014a 8093 0000 		sts IdleCount,r24
 769 014e 00C0      		rjmp .L38
 770               	.L43:
 344:Arduino-serialusbkeyboard.c **** 			{
 771               		.loc 4 344 0
 772 0150 8091 0000 		lds r24,USB_ControlRequest
 773 0154 813A      		cpi r24,lo8(-95)
 774 0156 01F0      		breq .+2
 775 0158 00C0      		rjmp .L38
 776               	.LBB163:
 777               	.LBB164:
 442:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 778               		.loc 7 442 0
 779 015a 8091 E800 		lds r24,232
 780 015e 877F      		andi r24,lo8(-9)
 781 0160 8093 E800 		sts 232,r24
 782               	.LBE164:
 783               	.LBE163:
 349:Arduino-serialusbkeyboard.c **** 
 784               		.loc 4 349 0
 785 0164 8091 0000 		lds r24,IdleCount
 786 0168 9091 0000 		lds r25,IdleCount+1
 787 016c 9695      		lsr r25
 788 016e 8795      		ror r24
 789 0170 9695      		lsr r25
 790 0172 8795      		ror r24
 791 0174 00C0      		rjmp .L55
 792               		.cfi_endproc
 793               	.LFE93:
 795               		.section	.text.SendNextReport,"ax",@progbits
 796               	.global	SendNextReport
 798               	SendNextReport:
 799               	.LFB97:
 425:Arduino-serialusbkeyboard.c **** }
 426:Arduino-serialusbkeyboard.c **** 
 427:Arduino-serialusbkeyboard.c **** /** Sends the next HID report to the host, via the keyboard data endpoint. */
 428:Arduino-serialusbkeyboard.c **** void SendNextReport(void)
 429:Arduino-serialusbkeyboard.c **** {
 800               		.loc 4 429 0
 801               		.cfi_startproc
 802 0000 CF93      		push r28
 803               	.LCFI10:
 804               		.cfi_def_cfa_offset 3
 805               		.cfi_offset 28, -2
 806 0002 DF93      		push r29
 807               	.LCFI11:
 808               		.cfi_def_cfa_offset 4
 809               		.cfi_offset 29, -3
 810 0004 CDB7      		in r28,__SP_L__
 811 0006 DEB7      		in r29,__SP_H__
 812               	.LCFI12:
 813               		.cfi_def_cfa_register 28
 814 0008 2897      		sbiw r28,8
 815               	.LCFI13:
 816               		.cfi_def_cfa_offset 12
 817 000a 0FB6      		in __tmp_reg__,__SREG__
 818 000c F894      		cli
 819 000e DEBF      		out __SP_H__,r29
 820 0010 0FBE      		out __SREG__,__tmp_reg__
 821 0012 CDBF      		out __SP_L__,r28
 822               	/* prologue: function */
 823               	/* frame size = 8 */
 824               	/* stack size = 10 */
 825               	.L__stack_usage = 10
 826               	.LVL40:
 430:Arduino-serialusbkeyboard.c **** 	static USB_KeyboardReport_Data_t PrevKeyboardReportData;
 431:Arduino-serialusbkeyboard.c **** 	USB_KeyboardReport_Data_t        KeyboardReportData;
 432:Arduino-serialusbkeyboard.c **** 	bool                             SendReport = true;
 433:Arduino-serialusbkeyboard.c **** 
 434:Arduino-serialusbkeyboard.c **** 	/* Create the next keyboard report for transmission to the host */
 435:Arduino-serialusbkeyboard.c **** 	CreateKeyboardReport(&KeyboardReportData);
 827               		.loc 4 435 0
 828 0014 CE01      		movw r24,r28
 829 0016 0196      		adiw r24,1
 830 0018 0E94 0000 		call CreateKeyboardReport
 831               	.LVL41:
 436:Arduino-serialusbkeyboard.c **** 
 437:Arduino-serialusbkeyboard.c **** 	/* Check to see if the report data has changed - if so a report MUST be sent */
 438:Arduino-serialusbkeyboard.c **** 	SendReport = (memcmp(&PrevKeyboardReportData, &KeyboardReportData, sizeof(USB_KeyboardReport_Data_
 832               		.loc 4 438 0
 833 001c 48E0      		ldi r20,lo8(8)
 834 001e 50E0      		ldi r21,0
 835 0020 BE01      		movw r22,r28
 836 0022 6F5F      		subi r22,-1
 837 0024 7F4F      		sbci r23,-1
 838 0026 80E0      		ldi r24,lo8(PrevKeyboardReportData.2820)
 839 0028 90E0      		ldi r25,hi8(PrevKeyboardReportData.2820)
 840 002a 0E94 0000 		call memcmp
 841               	.LVL42:
 842 002e 21E0      		ldi r18,lo8(1)
 843 0030 892B      		or r24,r25
 844 0032 01F4      		brne .L57
 845 0034 20E0      		ldi r18,0
 846               	.L57:
 847               	.LVL43:
 439:Arduino-serialusbkeyboard.c **** 
 440:Arduino-serialusbkeyboard.c **** 	/* Check if the idle period is set and has elapsed */
 441:Arduino-serialusbkeyboard.c **** 	if ((IdleCount != HID_IDLE_CHANGESONLY) && (!(IdleMSRemaining)))
 848               		.loc 4 441 0
 849 0036 8091 0000 		lds r24,IdleCount
 850 003a 9091 0000 		lds r25,IdleCount+1
 851 003e 0097      		sbiw r24,0
 852 0040 01F0      		breq .L58
 853               		.loc 4 441 0 is_stmt 0 discriminator 1
 854 0042 4091 0000 		lds r20,IdleMSRemaining
 855 0046 5091 0000 		lds r21,IdleMSRemaining+1
 856 004a 452B      		or r20,r21
 857 004c 01F4      		brne .L58
 442:Arduino-serialusbkeyboard.c **** 	{
 443:Arduino-serialusbkeyboard.c **** 		/* Reset the idle time remaining counter */
 444:Arduino-serialusbkeyboard.c **** 		IdleMSRemaining = IdleCount;
 858               		.loc 4 444 0 is_stmt 1
 859 004e 9093 0000 		sts IdleMSRemaining+1,r25
 860 0052 8093 0000 		sts IdleMSRemaining,r24
 861               	.LVL44:
 445:Arduino-serialusbkeyboard.c **** 
 446:Arduino-serialusbkeyboard.c **** 		/* Idle period is set and has elapsed, must send a report to the host */
 447:Arduino-serialusbkeyboard.c **** 		SendReport = true;
 862               		.loc 4 447 0
 863 0056 21E0      		ldi r18,lo8(1)
 864               	.LVL45:
 865               	.L58:
 866               	.LBB165:
 867               	.LBB166:
 299:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif			
 868               		.loc 7 299 0
 869 0058 81E0      		ldi r24,lo8(1)
 870 005a 8093 E900 		sts 233,r24
 871               	.LVL46:
 872               	.LBE166:
 873               	.LBE165:
 874               	.LBB167:
 875               	.LBB168:
 358:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 876               		.loc 7 358 0
 877 005e 8091 E800 		lds r24,232
 878               	.LBE168:
 879               	.LBE167:
 448:Arduino-serialusbkeyboard.c **** 	}
 449:Arduino-serialusbkeyboard.c **** 
 450:Arduino-serialusbkeyboard.c **** 	/* Select the Keyboard Report Endpoint */
 451:Arduino-serialusbkeyboard.c **** 	Endpoint_SelectEndpoint(KEYBOARD_IN_EPNUM);
 452:Arduino-serialusbkeyboard.c **** 
 453:Arduino-serialusbkeyboard.c **** 	/* Check if Keyboard Endpoint Ready for Read/Write and if we should send a new report */
 454:Arduino-serialusbkeyboard.c **** 	if (Endpoint_IsReadWriteAllowed() && SendReport)
 880               		.loc 4 454 0
 881 0062 85FF      		sbrs r24,5
 882 0064 00C0      		rjmp .L56
 883               		.loc 4 454 0 is_stmt 0 discriminator 1
 884 0066 2223      		tst r18
 885 0068 01F0      		breq .L56
 455:Arduino-serialusbkeyboard.c **** 	{
 456:Arduino-serialusbkeyboard.c **** 		/* Save the current report data for later comparison to check for changes */
 457:Arduino-serialusbkeyboard.c **** 		PrevKeyboardReportData = KeyboardReportData;
 886               		.loc 4 457 0 is_stmt 1
 887 006a 88E0      		ldi r24,lo8(8)
 888 006c FE01      		movw r30,r28
 889 006e 3196      		adiw r30,1
 890 0070 A0E0      		ldi r26,lo8(PrevKeyboardReportData.2820)
 891 0072 B0E0      		ldi r27,hi8(PrevKeyboardReportData.2820)
 892               		0:
 893 0074 0190      		ld r0,Z+
 894 0076 0D92      		st X+,r0
 895 0078 8A95      		dec r24
 896 007a 01F4      		brne 0b
 458:Arduino-serialusbkeyboard.c **** 
 459:Arduino-serialusbkeyboard.c **** 		/* Write Keyboard Report Data */
 460:Arduino-serialusbkeyboard.c **** 		Endpoint_Write_Stream_LE(&KeyboardReportData, sizeof(KeyboardReportData), NO_STREAM_CALLBACK);
 897               		.loc 4 460 0
 898 007c 50E0      		ldi r21,0
 899 007e 40E0      		ldi r20,0
 900 0080 68E0      		ldi r22,lo8(8)
 901 0082 70E0      		ldi r23,0
 902 0084 CE01      		movw r24,r28
 903 0086 0196      		adiw r24,1
 904 0088 0E94 0000 		call Endpoint_Write_Stream_LE
 905               	.LVL47:
 906               	.LBB169:
 907               	.LBB170:
 454:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 908               		.loc 7 454 0
 909 008c 8091 E800 		lds r24,232
 910 0090 8E77      		andi r24,lo8(126)
 911 0092 8093 E800 		sts 232,r24
 912               	.L56:
 913               	/* epilogue start */
 914               	.LBE170:
 915               	.LBE169:
 461:Arduino-serialusbkeyboard.c **** 
 462:Arduino-serialusbkeyboard.c **** 		/* Finalize the stream transfer to send the last packet */
 463:Arduino-serialusbkeyboard.c **** 		Endpoint_ClearIN();
 464:Arduino-serialusbkeyboard.c **** 	}
 465:Arduino-serialusbkeyboard.c **** }
 916               		.loc 4 465 0
 917 0096 2896      		adiw r28,8
 918 0098 0FB6      		in __tmp_reg__,__SREG__
 919 009a F894      		cli
 920 009c DEBF      		out __SP_H__,r29
 921 009e 0FBE      		out __SREG__,__tmp_reg__
 922 00a0 CDBF      		out __SP_L__,r28
 923 00a2 DF91      		pop r29
 924 00a4 CF91      		pop r28
 925 00a6 0895      		ret
 926               		.cfi_endproc
 927               	.LFE97:
 929               		.section	.text.ReceiveNextReport,"ax",@progbits
 930               	.global	ReceiveNextReport
 932               	ReceiveNextReport:
 933               	.LFB98:
 466:Arduino-serialusbkeyboard.c **** 
 467:Arduino-serialusbkeyboard.c **** /** Reads the next LED status report from the host from the LED data endpoint, if one has been sent
 468:Arduino-serialusbkeyboard.c **** void ReceiveNextReport(void)
 469:Arduino-serialusbkeyboard.c **** {
 934               		.loc 4 469 0
 935               		.cfi_startproc
 936               	/* prologue: function */
 937               	/* frame size = 0 */
 938               	/* stack size = 0 */
 939               	.L__stack_usage = 0
 940               	.LVL48:
 941               	.LBB171:
 942               	.LBB172:
 299:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#endif			
 943               		.loc 7 299 0
 944 0000 82E0      		ldi r24,lo8(2)
 945 0002 8093 E900 		sts 233,r24
 946               	.LVL49:
 947               	.LBE172:
 948               	.LBE171:
 949               	.LBB173:
 950               	.LBB174:
 417:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 951               		.loc 7 417 0
 952 0006 8091 E800 		lds r24,232
 953               	.LBE174:
 954               	.LBE173:
 470:Arduino-serialusbkeyboard.c **** 	/* Select the Keyboard LED Report Endpoint */
 471:Arduino-serialusbkeyboard.c **** 	Endpoint_SelectEndpoint(KEYBOARD_OUT_EPNUM);
 472:Arduino-serialusbkeyboard.c **** 
 473:Arduino-serialusbkeyboard.c **** 	/* Check if Keyboard LED Endpoint contains a packet */
 474:Arduino-serialusbkeyboard.c **** 	if (Endpoint_IsOUTReceived())
 955               		.loc 4 474 0
 956 000a 82FF      		sbrs r24,2
 957 000c 00C0      		rjmp .L69
 958               	.LBB175:
 959               	.LBB176:
 358:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 960               		.loc 7 358 0
 961 000e 8091 E800 		lds r24,232
 962               	.LBE176:
 963               	.LBE175:
 475:Arduino-serialusbkeyboard.c **** 	{
 476:Arduino-serialusbkeyboard.c **** 		/* Check to see if the packet contains data */
 477:Arduino-serialusbkeyboard.c **** 		if (Endpoint_IsReadWriteAllowed())
 964               		.loc 4 477 0
 965 0012 85FF      		sbrs r24,5
 966 0014 00C0      		rjmp .L71
 967               	.LBB177:
 968               	.LBB178:
 969               	.LBB179:
 550:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 			}
 970               		.loc 7 550 0
 971 0016 8091 F100 		lds r24,241
 972               	.LBE179:
 973               	.LBE178:
 478:Arduino-serialusbkeyboard.c **** 		{
 479:Arduino-serialusbkeyboard.c **** 			/* Read in the LED report from the host */
 480:Arduino-serialusbkeyboard.c **** 			uint8_t LEDReport = Endpoint_Read_Byte();
 481:Arduino-serialusbkeyboard.c **** 
 482:Arduino-serialusbkeyboard.c **** 			/* Process the read LED report from the host */
 483:Arduino-serialusbkeyboard.c **** 			ProcessLEDReport(LEDReport);
 974               		.loc 4 483 0
 975 001a 0E94 0000 		call ProcessLEDReport
 976               	.LVL50:
 977               	.L71:
 978               	.LBE177:
 979               	.LBB180:
 980               	.LBB181:
 469:../../LUFA/Drivers/USB/HighLevel/../LowLevel/Endpoint.h **** 				#else
 981               		.loc 7 469 0
 982 001e 8091 E800 		lds r24,232
 983 0022 8B77      		andi r24,lo8(123)
 984 0024 8093 E800 		sts 232,r24
 985               	.L69:
 986               	/* epilogue start */
 987               	.LBE181:
 988               	.LBE180:
 484:Arduino-serialusbkeyboard.c **** 		}
 485:Arduino-serialusbkeyboard.c **** 
 486:Arduino-serialusbkeyboard.c **** 		/* Handshake the OUT Endpoint - clear endpoint and ready for next report */
 487:Arduino-serialusbkeyboard.c **** 		Endpoint_ClearOUT();
 488:Arduino-serialusbkeyboard.c **** 	}
 489:Arduino-serialusbkeyboard.c **** }
 989               		.loc 4 489 0
 990 0028 0895      		ret
 991               		.cfi_endproc
 992               	.LFE98:
 994               		.section	.text.HID_Task,"ax",@progbits
 995               	.global	HID_Task
 997               	HID_Task:
 998               	.LFB99:
 490:Arduino-serialusbkeyboard.c **** 
 491:Arduino-serialusbkeyboard.c **** /** Function to manage HID report generation and transmission to the host, when in report mode. */
 492:Arduino-serialusbkeyboard.c **** void HID_Task(void)
 493:Arduino-serialusbkeyboard.c **** {
 999               		.loc 4 493 0
 1000               		.cfi_startproc
 1001               	/* prologue: function */
 1002               	/* frame size = 0 */
 1003               	/* stack size = 0 */
 1004               	.L__stack_usage = 0
 494:Arduino-serialusbkeyboard.c **** 	/* Device must be connected and configured for the task to run */
 495:Arduino-serialusbkeyboard.c **** 	if (USB_DeviceState != DEVICE_STATE_Configured)
 1005               		.loc 4 495 0
 1006 0000 8EB3      		in r24,0x1e
 1007 0002 8430      		cpi r24,lo8(4)
 1008 0004 01F4      		brne .L78
 496:Arduino-serialusbkeyboard.c **** 	  return;
 497:Arduino-serialusbkeyboard.c **** 
 498:Arduino-serialusbkeyboard.c **** 	/* Send the next keypress report to the host */
 499:Arduino-serialusbkeyboard.c **** 	SendNextReport();
 1009               		.loc 4 499 0
 1010 0006 0E94 0000 		call SendNextReport
 1011               	.LVL51:
 500:Arduino-serialusbkeyboard.c **** 
 501:Arduino-serialusbkeyboard.c **** 	/* Process the LED report sent from the host */
 502:Arduino-serialusbkeyboard.c **** 	ReceiveNextReport();
 1012               		.loc 4 502 0
 1013 000a 0C94 0000 		jmp ReceiveNextReport
 1014               	.LVL52:
 1015               	.L78:
 1016               	/* epilogue start */
 503:Arduino-serialusbkeyboard.c **** }
 1017               		.loc 4 503 0
 1018 000e 0895      		ret
 1019               		.cfi_endproc
 1020               	.LFE99:
 1022               		.section	.text.startup.main,"ax",@progbits
 1023               	.global	main
 1025               	main:
 1026               	.LFB88:
 101:Arduino-serialusbkeyboard.c **** 	SetupHardware();
 1027               		.loc 4 101 0
 1028               		.cfi_startproc
 1029               	/* prologue: function */
 1030               	/* frame size = 0 */
 1031               	/* stack size = 0 */
 1032               	.L__stack_usage = 0
 102:Arduino-serialusbkeyboard.c **** 	
 1033               		.loc 4 102 0
 1034 0000 0E94 0000 		call SetupHardware
 1035               	.LVL53:
 1036               	.LBB197:
 1037               	.LBB198:
  87:Lib/LightweightRingBuff.h **** 			{
 1038               		.loc 2 87 0
 1039 0004 2FB7      		in r18,__SREG__
 1040               	.LVL54:
 1041               	.LBB199:
 1042               	.LBB200:
  50:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     return 1;
 1043               		.loc 3 50 0
 1044               	/* #APP */
 1045               	 ;  50 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h" 1
 1046 0006 F894      		cli
 1047               	 ;  0 "" 2
 1048               	.LVL55:
 1049               	/* #NOAPP */
 1050               	.LBE200:
 1051               	.LBE199:
  89:Lib/LightweightRingBuff.h **** 				Buffer->Out = Buffer->Buffer;
 1052               		.loc 2 89 0
 1053 0008 80E0      		ldi r24,lo8(USARTtoUSB_Buffer)
 1054 000a 90E0      		ldi r25,hi8(USARTtoUSB_Buffer)
 1055 000c 9093 0000 		sts USARTtoUSB_Buffer+128+1,r25
 1056 0010 8093 0000 		sts USARTtoUSB_Buffer+128,r24
  90:Lib/LightweightRingBuff.h **** 			}
 1057               		.loc 2 90 0
 1058 0014 9093 0000 		sts USARTtoUSB_Buffer+130+1,r25
 1059 0018 8093 0000 		sts USARTtoUSB_Buffer+130,r24
 1060               	.LVL56:
 1061               	.LBB201:
 1062               	.LBB202:
  70:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1063               		.loc 3 70 0
 1064 001c 2FBF      		out __SREG__,r18
 1065               		.loc 3 71 0
 1066               	.LVL57:
 1067               	.LBE202:
 1068               	.LBE201:
 1069               	.LBE198:
 1070               	.LBE197:
 107:Arduino-serialusbkeyboard.c **** 	sei();
 1071               		.loc 4 107 0
 1072 001e 80E2      		ldi r24,lo8(32)
 1073 0020 0E94 0000 		call LEDs_SetAllLEDs
 1074               	.LVL58:
 108:Arduino-serialusbkeyboard.c **** 
 1075               		.loc 4 108 0
 1076               	/* #APP */
 1077               	 ;  108 "Arduino-serialusbkeyboard.c" 1
 1078 0024 7894      		sei
 1079               	 ;  0 "" 2
 1080               	.LVL59:
 1081               	/* #NOAPP */
 1082               	.L87:
 1083               	.LBB203:
 1084               	.LBB204:
 1085               	.LBB205:
 1086               	.LBB206:
 111:Lib/LightweightRingBuff.h **** 			{
 1087               		.loc 2 111 0
 1088 0026 8FB7      		in r24,__SREG__
 1089               	.LVL60:
 1090               	.LBB207:
 1091               	.LBB208:
  50:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     return 1;
 1092               		.loc 3 50 0
 1093               	/* #APP */
 1094               	 ;  50 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h" 1
 1095 0028 F894      		cli
 1096               	 ;  0 "" 2
 1097               	.LVL61:
 1098               	/* #NOAPP */
 1099               	.LBE208:
 1100               	.LBE207:
 113:Lib/LightweightRingBuff.h **** 			}
 1101               		.loc 2 113 0
 1102 002a C091 0000 		lds r28,USARTtoUSB_Buffer+132
 1103               	.LVL62:
 1104               	.LBB209:
 1105               	.LBB210:
  70:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1106               		.loc 3 70 0
 1107 002e 8FBF      		out __SREG__,r24
 1108               		.loc 3 71 0
 1109               	.LVL63:
 1110               	.LBE210:
 1111               	.LBE209:
 1112               	.LBE206:
 1113               	.LBE205:
 1114               	.LBE204:
 161:Arduino-serialusbkeyboard.c ****         while(BufferCount--)
 1115               		.loc 4 161 0
 1116 0030 C136      		cpi r28,lo8(97)
 1117 0032 00F0      		brlo .L85
 1118               	.L81:
 1119               	.LVL64:
 162:Arduino-serialusbkeyboard.c ****             header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 1120               		.loc 4 162 0
 1121               	.LVL65:
 1122 0034 C150      		subi r28,1
 1123 0036 00F4      		brcc .L83
 1124               	.L85:
 165:Arduino-serialusbkeyboard.c ****             if (BufferCount--) {
 1125               		.loc 4 165 0
 1126 0038 C330      		cpi r28,lo8(3)
 1127 003a 00F4      		brsh .L86
 181:Arduino-serialusbkeyboard.c **** 		USB_USBTask();
 1128               		.loc 4 181 0
 1129 003c 0E94 0000 		call HID_Task
 1130               	.LVL66:
 182:Arduino-serialusbkeyboard.c **** 
 1131               		.loc 4 182 0
 1132 0040 0E94 0000 		call USB_USBTask
 1133               	.LVL67:
 1134               	.LBE203:
 111:Arduino-serialusbkeyboard.c **** 		/* Only try to read in bytes from the CDC interface if the transmit buffer is not full */
 1135               		.loc 4 111 0
 1136 0044 00C0      		rjmp .L87
 1137               	.L83:
 1138               	.LBB211:
 163:Arduino-serialusbkeyboard.c ****     }
 1139               		.loc 4 163 0
 1140 0046 0E94 0000 		call RingBuffer_Remove.constprop.3
 1141               	.LVL68:
 1142 004a 8093 0000 		sts header,r24
 1143 004e 00C0      		rjmp .L81
 1144               	.L86:
 166:Arduino-serialusbkeyboard.c ****                 header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 1145               		.loc 4 166 0
 1146 0050 DFEF      		ldi r29,lo8(-1)
 1147 0052 DC0F      		add r29,r28
 1148               	.LVL69:
 167:Arduino-serialusbkeyboard.c ****                 if(header == 0x00) {
 1149               		.loc 4 167 0
 1150 0054 0E94 0000 		call RingBuffer_Remove.constprop.3
 1151               	.LVL70:
 1152 0058 8093 0000 		sts header,r24
 168:Arduino-serialusbkeyboard.c ****                     if (BufferCount--) {
 1153               		.loc 4 168 0
 1154 005c 8111      		cpse r24,__zero_reg__
 1155 005e 00C0      		rjmp .L88
 1156               	.LVL71:
 170:Arduino-serialusbkeyboard.c ****                     }
 1157               		.loc 4 170 0
 1158 0060 0E94 0000 		call RingBuffer_Remove.constprop.3
 1159               	.LVL72:
 1160 0064 8093 0000 		sts scancode,r24
 172:Arduino-serialusbkeyboard.c ****                         press_release = RingBuffer_Remove(&USARTtoUSB_Buffer);
 1161               		.loc 4 172 0
 1162 0068 C350      		subi r28,lo8(-(-3))
 1163               	.LVL73:
 173:Arduino-serialusbkeyboard.c ****                     }
 1164               		.loc 4 173 0
 1165 006a 0E94 0000 		call RingBuffer_Remove.constprop.3
 1166               	.LVL74:
 1167 006e 8093 0000 		sts press_release,r24
 175:Arduino-serialusbkeyboard.c ****                 }
 1168               		.loc 4 175 0
 1169 0072 E091 0000 		lds r30,scancode
 1170 0076 F0E0      		ldi r31,0
 1171 0078 E050      		subi r30,lo8(-(scancode_buffer))
 1172 007a F040      		sbci r31,hi8(-(scancode_buffer))
 1173 007c 8083      		st Z,r24
 1174 007e 00C0      		rjmp .L85
 1175               	.LVL75:
 1176               	.L88:
 166:Arduino-serialusbkeyboard.c ****                 header = RingBuffer_Remove(&USARTtoUSB_Buffer);
 1177               		.loc 4 166 0
 1178 0080 CD2F      		mov r28,r29
 1179 0082 00C0      		rjmp .L85
 1180               	.LBE211:
 1181               		.cfi_endproc
 1182               	.LFE88:
 1184               		.section	.text.__vector_23,"ax",@progbits
 1185               	.global	__vector_23
 1187               	__vector_23:
 1188               	.LFB100:
 504:Arduino-serialusbkeyboard.c **** 
 505:Arduino-serialusbkeyboard.c **** 
 506:Arduino-serialusbkeyboard.c **** /** Event handler for the CDC Class driver Line Encoding Changed event.
 507:Arduino-serialusbkeyboard.c ****  *
 508:Arduino-serialusbkeyboard.c ****  *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being r
 509:Arduino-serialusbkeyboard.c ****  */
 510:Arduino-serialusbkeyboard.c **** // void EVENT_CDC_Device_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
 511:Arduino-serialusbkeyboard.c **** // {
 512:Arduino-serialusbkeyboard.c **** // 	uint8_t ConfigMask = 0;
 513:Arduino-serialusbkeyboard.c **** 
 514:Arduino-serialusbkeyboard.c **** // 	switch (CDCInterfaceInfo->State.LineEncoding.ParityType)
 515:Arduino-serialusbkeyboard.c **** // 	{
 516:Arduino-serialusbkeyboard.c **** // 		case CDC_PARITY_Odd:
 517:Arduino-serialusbkeyboard.c **** // 			ConfigMask = ((1 << UPM11) | (1 << UPM10));		
 518:Arduino-serialusbkeyboard.c **** // 			break;
 519:Arduino-serialusbkeyboard.c **** // 		case CDC_PARITY_Even:
 520:Arduino-serialusbkeyboard.c **** // 			ConfigMask = (1 << UPM11);		
 521:Arduino-serialusbkeyboard.c **** // 			break;
 522:Arduino-serialusbkeyboard.c **** // 	}
 523:Arduino-serialusbkeyboard.c **** 
 524:Arduino-serialusbkeyboard.c **** // 	if (CDCInterfaceInfo->State.LineEncoding.CharFormat == CDC_LINEENCODING_TwoStopBits)
 525:Arduino-serialusbkeyboard.c **** // 	  ConfigMask |= (1 << USBS1);
 526:Arduino-serialusbkeyboard.c **** 
 527:Arduino-serialusbkeyboard.c **** // 	switch (CDCInterfaceInfo->State.LineEncoding.DataBits)
 528:Arduino-serialusbkeyboard.c **** // 	{
 529:Arduino-serialusbkeyboard.c **** // 		case 6:
 530:Arduino-serialusbkeyboard.c **** // 			ConfigMask |= (1 << UCSZ10);
 531:Arduino-serialusbkeyboard.c **** // 			break;
 532:Arduino-serialusbkeyboard.c **** // 		case 7:
 533:Arduino-serialusbkeyboard.c **** // 			ConfigMask |= (1 << UCSZ11);
 534:Arduino-serialusbkeyboard.c **** // 			break;
 535:Arduino-serialusbkeyboard.c **** // 		case 8:
 536:Arduino-serialusbkeyboard.c **** // 			ConfigMask |= ((1 << UCSZ11) | (1 << UCSZ10));
 537:Arduino-serialusbkeyboard.c **** // 			break;
 538:Arduino-serialusbkeyboard.c **** // 	}
 539:Arduino-serialusbkeyboard.c **** 
 540:Arduino-serialusbkeyboard.c **** // 	/* Must turn off USART before reconfiguring it, otherwise incorrect operation may occur */
 541:Arduino-serialusbkeyboard.c **** // 	UCSR1B = 0;
 542:Arduino-serialusbkeyboard.c **** // 	UCSR1A = 0;
 543:Arduino-serialusbkeyboard.c **** // 	UCSR1C = 0;
 544:Arduino-serialusbkeyboard.c **** 
 545:Arduino-serialusbkeyboard.c **** // 	/* Special case 57600 baud for compatibility with the ATmega328 bootloader. */	
 546:Arduino-serialusbkeyboard.c **** // 	UBRR1  = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600)
 547:Arduino-serialusbkeyboard.c **** // 			 ? SERIAL_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS)
 548:Arduino-serialusbkeyboard.c **** // 			 : SERIAL_2X_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);	
 549:Arduino-serialusbkeyboard.c **** 
 550:Arduino-serialusbkeyboard.c **** // 	UCSR1C = ConfigMask;
 551:Arduino-serialusbkeyboard.c **** // 	UCSR1A = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600) ? 0 : (1 << U2X1);
 552:Arduino-serialusbkeyboard.c **** // 	UCSR1B = ((1 << RXCIE1) | (1 << TXEN1) | (1 << RXEN1));
 553:Arduino-serialusbkeyboard.c **** // }
 554:Arduino-serialusbkeyboard.c **** 
 555:Arduino-serialusbkeyboard.c **** /** ISR to manage the reception of data from the serial port, placing received bytes into a circula
 556:Arduino-serialusbkeyboard.c ****  *  for later transmission to the host.
 557:Arduino-serialusbkeyboard.c ****  */
 558:Arduino-serialusbkeyboard.c **** ISR(USART1_RX_vect, ISR_BLOCK)
 559:Arduino-serialusbkeyboard.c **** {
 1189               		.loc 4 559 0
 1190               		.cfi_startproc
 1191 0000 1F92      		push r1
 1192               	.LCFI14:
 1193               		.cfi_def_cfa_offset 3
 1194               		.cfi_offset 1, -2
 1195 0002 0F92      		push r0
 1196               	.LCFI15:
 1197               		.cfi_def_cfa_offset 4
 1198               		.cfi_offset 0, -3
 1199 0004 0FB6      		in r0,__SREG__
 1200 0006 0F92      		push r0
 1201 0008 1124      		clr __zero_reg__
 1202 000a 2F93      		push r18
 1203               	.LCFI16:
 1204               		.cfi_def_cfa_offset 5
 1205               		.cfi_offset 18, -4
 1206 000c 8F93      		push r24
 1207               	.LCFI17:
 1208               		.cfi_def_cfa_offset 6
 1209               		.cfi_offset 24, -5
 1210 000e 9F93      		push r25
 1211               	.LCFI18:
 1212               		.cfi_def_cfa_offset 7
 1213               		.cfi_offset 25, -6
 1214 0010 EF93      		push r30
 1215               	.LCFI19:
 1216               		.cfi_def_cfa_offset 8
 1217               		.cfi_offset 30, -7
 1218 0012 FF93      		push r31
 1219               	.LCFI20:
 1220               		.cfi_def_cfa_offset 9
 1221               		.cfi_offset 31, -8
 1222               	/* prologue: Signal */
 1223               	/* frame size = 0 */
 1224               	/* stack size = 8 */
 1225               	.L__stack_usage = 8
 560:Arduino-serialusbkeyboard.c **** 	uint8_t ReceivedByte = UDR1;
 1226               		.loc 4 560 0
 1227 0014 8091 CE00 		lds r24,206
 1228               	.LVL76:
 561:Arduino-serialusbkeyboard.c **** 
 562:Arduino-serialusbkeyboard.c **** 	if (USB_DeviceState == DEVICE_STATE_Configured)
 1229               		.loc 4 562 0
 1230 0018 9EB3      		in r25,0x1e
 1231 001a 9430      		cpi r25,lo8(4)
 1232 001c 01F4      		brne .L90
 1233               	.LVL77:
 1234               	.LBB219:
 1235               	.LBB220:
 161:Lib/LightweightRingBuff.h **** 			
 1236               		.loc 2 161 0
 1237 001e E091 0000 		lds r30,USARTtoUSB_Buffer+128
 1238 0022 F091 0000 		lds r31,USARTtoUSB_Buffer+128+1
 1239 0026 8083      		st Z,r24
 163:Lib/LightweightRingBuff.h **** 			  Buffer->In = Buffer->Buffer;
 1240               		.loc 2 163 0
 1241 0028 E091 0000 		lds r30,USARTtoUSB_Buffer+128
 1242 002c F091 0000 		lds r31,USARTtoUSB_Buffer+128+1
 1243 0030 CF01      		movw r24,r30
 1244               	.LVL78:
 1245 0032 0196      		adiw r24,1
 1246 0034 20E0      		ldi r18,hi8(USARTtoUSB_Buffer+128)
 1247 0036 8030      		cpi r24,lo8(USARTtoUSB_Buffer+128)
 1248 0038 9207      		cpc r25,r18
 1249 003a 01F0      		breq .L92
 1250 003c 9093 0000 		sts USARTtoUSB_Buffer+128+1,r25
 1251 0040 8093 0000 		sts USARTtoUSB_Buffer+128,r24
 1252               	.L93:
 1253               	.LBB221:
 166:Lib/LightweightRingBuff.h **** 			{
 1254               		.loc 2 166 0
 1255 0044 9FB7      		in r25,__SREG__
 1256               	.LVL79:
 1257               	.LBB222:
 1258               	.LBB223:
  50:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     return 1;
 1259               		.loc 3 50 0
 1260               	/* #APP */
 1261               	 ;  50 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h" 1
 1262 0046 F894      		cli
 1263               	 ;  0 "" 2
 1264               	.LVL80:
 1265               	/* #NOAPP */
 1266               	.LBE223:
 1267               	.LBE222:
 168:Lib/LightweightRingBuff.h **** 			}
 1268               		.loc 2 168 0
 1269 0048 8091 0000 		lds r24,USARTtoUSB_Buffer+132
 1270 004c 8F5F      		subi r24,lo8(-(1))
 1271 004e 8093 0000 		sts USARTtoUSB_Buffer+132,r24
 1272               	.LVL81:
 1273               	.LBB224:
 1274               	.LBB225:
  70:/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/util/atomic.h ****     __asm__ volatile ("" ::: "memory");
 1275               		.loc 3 70 0
 1276 0052 9FBF      		out __SREG__,r25
 1277               		.loc 3 71 0
 1278               	.LVL82:
 1279               	.L90:
 1280               	/* epilogue start */
 1281               	.LBE225:
 1282               	.LBE224:
 1283               	.LBE221:
 1284               	.LBE220:
 1285               	.LBE219:
 563:Arduino-serialusbkeyboard.c **** 	  RingBuffer_Insert(&USARTtoUSB_Buffer, ReceivedByte);
 564:Arduino-serialusbkeyboard.c **** }
 1286               		.loc 4 564 0
 1287 0054 FF91      		pop r31
 1288 0056 EF91      		pop r30
 1289 0058 9F91      		pop r25
 1290 005a 8F91      		pop r24
 1291 005c 2F91      		pop r18
 1292 005e 0F90      		pop r0
 1293 0060 0FBE      		out __SREG__,r0
 1294 0062 0F90      		pop r0
 1295 0064 1F90      		pop r1
 1296 0066 1895      		reti
 1297               	.LVL83:
 1298               	.L92:
 1299               	.LBB227:
 1300               	.LBB226:
 164:Lib/LightweightRingBuff.h **** 
 1301               		.loc 2 164 0
 1302 0068 80E0      		ldi r24,lo8(USARTtoUSB_Buffer)
 1303 006a 90E0      		ldi r25,hi8(USARTtoUSB_Buffer)
 1304 006c 9283      		std Z+2,r25
 1305 006e 8183      		std Z+1,r24
 1306 0070 00C0      		rjmp .L93
 1307               	.LBE226:
 1308               	.LBE227:
 1309               		.cfi_endproc
 1310               	.LFE100:
 1312               		.local	PrevKeyboardReportData.2820
 1313               		.comm	PrevKeyboardReportData.2820,8,1
 1314               		.comm	press_release,1,1
 1315               		.comm	scancode,1,1
 1316               		.comm	header,1,1
 1317               	.global	scancode_buffer
 1318               		.section .bss
 1321               	scancode_buffer:
 1322 0000 0000 0000 		.zero	256
 1322      0000 0000 
 1322      0000 0000 
 1322      0000 0000 
 1322      0000 0000 
 1323               	.global	IdleMSRemaining
 1326               	IdleMSRemaining:
 1327 0100 0000      		.zero	2
 1328               	.global	IdleCount
 1329               		.data
 1332               	IdleCount:
 1333 0000 F401      		.word	500
 1334               	.global	UsingReportProtocol
 1337               	UsingReportProtocol:
 1338 0002 01        		.byte	1
 1339               		.comm	USARTtoUSB_Buffer,133,1
 1340               		.text
 1341               	.Letext0:
 1342               		.file 9 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/stdint.h"
 1343               		.file 10 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/StdRequestType.h"
 1344               		.file 11 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/../HighLevel/DeviceStandardReq.h"
 1345               		.file 12 "../../LUFA/Drivers/USB/HighLevel/USBTask.h"
 1346               		.file 13 "Arduino-serialusbkeyboard.h"
 1347               		.file 14 "/Applications/Arduino.app/Contents/Java/hardware/tools/avr/avr/include/string.h"
 1348               		.file 15 "../../LUFA/Drivers/USB/HighLevel/../LowLevel/USBController.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 Arduino-serialusbkeyboard.c
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:2      *ABS*:000000000000003e __SP_H__
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:3      *ABS*:000000000000003d __SP_L__
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:4      *ABS*:000000000000003f __SREG__
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:5      *ABS*:0000000000000000 __tmp_reg__
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:6      *ABS*:0000000000000001 __zero_reg__
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:12     .text.LEDs_SetAllLEDs:0000000000000000 LEDs_SetAllLEDs
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:37     .text.RingBuffer_Remove.constprop.3:0000000000000000 RingBuffer_Remove.constprop.3
                            *COM*:0000000000000085 USARTtoUSB_Buffer
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:107    .text.SetupHardware:0000000000000000 SetupHardware
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:208    .text.EVENT_USB_Device_Connect:0000000000000000 EVENT_USB_Device_Connect
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:1337   .data:0000000000000002 UsingReportProtocol
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:232    .text.EVENT_USB_Device_Disconnect:0000000000000000 EVENT_USB_Device_Disconnect
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:250    .text.EVENT_USB_Device_ConfigurationChanged:0000000000000000 EVENT_USB_Device_ConfigurationChanged
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:316    .text.EVENT_USB_Device_StartOfFrame:0000000000000000 EVENT_USB_Device_StartOfFrame
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:1326   .bss:0000000000000100 IdleMSRemaining
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:343    .text.CreateKeyboardReport:0000000000000000 CreateKeyboardReport
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:1321   .bss:0000000000000000 scancode_buffer
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:489    .text.ProcessLEDReport:0000000000000000 ProcessLEDReport
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:519    .text.EVENT_USB_Device_UnhandledControlRequest:0000000000000000 EVENT_USB_Device_UnhandledControlRequest
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:1332   .data:0000000000000000 IdleCount
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:798    .text.SendNextReport:0000000000000000 SendNextReport
                             .bss:0000000000000102 PrevKeyboardReportData.2820
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:932    .text.ReceiveNextReport:0000000000000000 ReceiveNextReport
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:997    .text.HID_Task:0000000000000000 HID_Task
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:1025   .text.startup.main:0000000000000000 main
                            *COM*:0000000000000001 header
                            *COM*:0000000000000001 scancode
                            *COM*:0000000000000001 press_release
/var/folders/j8/tgcwrqr14993zwf2fgrl_9qc0000gq/T//ccSYGwkL.s:1187   .text.__vector_23:0000000000000000 __vector_23

UNDEFINED SYMBOLS
USB_Init
Endpoint_ConfigureEndpoint_Prv
USB_ControlRequest
Endpoint_ClearStatusStage
Endpoint_Write_Control_Stream_LE
memcmp
Endpoint_Write_Stream_LE
USB_USBTask
__do_copy_data
__do_clear_bss
