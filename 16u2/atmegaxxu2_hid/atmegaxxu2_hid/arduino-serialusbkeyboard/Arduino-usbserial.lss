
Arduino-usbserial.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00800100  00000f64  00000ff8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000f64  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000119  00800116  00800116  0000100e  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  0000100e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001020  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000350  00000000  00000000  00001060  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000059b4  00000000  00000000  000013b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001979  00000000  00000000  00006d64  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000033bd  00000000  00000000  000086dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000874  00000000  00000000  0000ba9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001e96  00000000  00000000  0000c310  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000384c  00000000  00000000  0000e1a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000450  00000000  00000000  000119f2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	8a c0       	rjmp	.+276    	; 0x116 <__ctors_end>
   2:	00 00       	nop
   4:	a3 c0       	rjmp	.+326    	; 0x14c <__bad_interrupt>
   6:	00 00       	nop
   8:	a1 c0       	rjmp	.+322    	; 0x14c <__bad_interrupt>
   a:	00 00       	nop
   c:	9f c0       	rjmp	.+318    	; 0x14c <__bad_interrupt>
   e:	00 00       	nop
  10:	9d c0       	rjmp	.+314    	; 0x14c <__bad_interrupt>
  12:	00 00       	nop
  14:	9b c0       	rjmp	.+310    	; 0x14c <__bad_interrupt>
  16:	00 00       	nop
  18:	99 c0       	rjmp	.+306    	; 0x14c <__bad_interrupt>
  1a:	00 00       	nop
  1c:	97 c0       	rjmp	.+302    	; 0x14c <__bad_interrupt>
  1e:	00 00       	nop
  20:	95 c0       	rjmp	.+298    	; 0x14c <__bad_interrupt>
  22:	00 00       	nop
  24:	93 c0       	rjmp	.+294    	; 0x14c <__bad_interrupt>
  26:	00 00       	nop
  28:	91 c0       	rjmp	.+290    	; 0x14c <__bad_interrupt>
  2a:	00 00       	nop
  2c:	03 c4       	rjmp	.+2054   	; 0x834 <__vector_11>
  2e:	00 00       	nop
  30:	a8 c4       	rjmp	.+2384   	; 0x982 <__vector_12>
  32:	00 00       	nop
  34:	8b c0       	rjmp	.+278    	; 0x14c <__bad_interrupt>
  36:	00 00       	nop
  38:	89 c0       	rjmp	.+274    	; 0x14c <__bad_interrupt>
  3a:	00 00       	nop
  3c:	87 c0       	rjmp	.+270    	; 0x14c <__bad_interrupt>
  3e:	00 00       	nop
  40:	85 c0       	rjmp	.+266    	; 0x14c <__bad_interrupt>
  42:	00 00       	nop
  44:	83 c0       	rjmp	.+262    	; 0x14c <__bad_interrupt>
  46:	00 00       	nop
  48:	81 c0       	rjmp	.+258    	; 0x14c <__bad_interrupt>
  4a:	00 00       	nop
  4c:	7f c0       	rjmp	.+254    	; 0x14c <__bad_interrupt>
  4e:	00 00       	nop
  50:	7d c0       	rjmp	.+250    	; 0x14c <__bad_interrupt>
  52:	00 00       	nop
  54:	7b c0       	rjmp	.+246    	; 0x14c <__bad_interrupt>
  56:	00 00       	nop
  58:	79 c0       	rjmp	.+242    	; 0x14c <__bad_interrupt>
  5a:	00 00       	nop
  5c:	cd c1       	rjmp	.+922    	; 0x3f8 <__vector_23>
  5e:	00 00       	nop
  60:	75 c0       	rjmp	.+234    	; 0x14c <__bad_interrupt>
  62:	00 00       	nop
  64:	73 c0       	rjmp	.+230    	; 0x14c <__bad_interrupt>
  66:	00 00       	nop
  68:	71 c0       	rjmp	.+226    	; 0x14c <__bad_interrupt>
  6a:	00 00       	nop
  6c:	6f c0       	rjmp	.+222    	; 0x14c <__bad_interrupt>
  6e:	00 00       	nop
  70:	6d c0       	rjmp	.+218    	; 0x14c <__bad_interrupt>
  72:	00 00       	nop

00000074 <ProductString>:
  74:	18 03 41 00 72 00 64 00 75 00 69 00 6e 00 6f 00     ..A.r.d.u.i.n.o.
  84:	20 00 55 00 6e 00 6f 00 00 00                        .U.n.o...

0000008e <ManufacturerString>:
  8e:	32 03 41 00 72 00 64 00 75 00 69 00 6e 00 6f 00     2.A.r.d.u.i.n.o.
  9e:	20 00 28 00 77 00 77 00 77 00 2e 00 61 00 72 00      .(.w.w.w...a.r.
  ae:	64 00 75 00 69 00 6e 00 6f 00 2e 00 63 00 63 00     d.u.i.n.o...c.c.
  be:	29 00 00 00                                         )...

000000c2 <LanguageString>:
  c2:	04 03 09 04                                         ....

000000c6 <ConfigurationDescriptor>:
  c6:	09 02 3e 00 02 01 00 c0 32 09 04 00 00 01 02 02     ..>.....2.......
  d6:	01 00 05 24 00 01 10 04 24 02 06 05 24 06 00 01     ...$....$...$...
  e6:	07 05 82 03 08 00 ff 09 04 01 00 02 0a 00 00 00     ................
  f6:	07 05 04 02 40 00 01 07 05 83 02 40 00 01           ....@......@..

00000104 <DeviceDescriptor>:
 104:	12 01 10 01 02 00 00 08 eb 03 4b 20 01 00 01 02     ..........K ....
 114:	dc 01                                               ..

00000116 <__ctors_end>:
 116:	11 24       	eor	r1, r1
 118:	1f be       	out	0x3f, r1	; 63
 11a:	cf ef       	ldi	r28, 0xFF	; 255
 11c:	d2 e0       	ldi	r29, 0x02	; 2
 11e:	de bf       	out	0x3e, r29	; 62
 120:	cd bf       	out	0x3d, r28	; 61

00000122 <__do_copy_data>:
 122:	11 e0       	ldi	r17, 0x01	; 1
 124:	a0 e0       	ldi	r26, 0x00	; 0
 126:	b1 e0       	ldi	r27, 0x01	; 1
 128:	e4 e6       	ldi	r30, 0x64	; 100
 12a:	ff e0       	ldi	r31, 0x0F	; 15
 12c:	02 c0       	rjmp	.+4      	; 0x132 <__do_copy_data+0x10>
 12e:	05 90       	lpm	r0, Z+
 130:	0d 92       	st	X+, r0
 132:	a6 31       	cpi	r26, 0x16	; 22
 134:	b1 07       	cpc	r27, r17
 136:	d9 f7       	brne	.-10     	; 0x12e <__do_copy_data+0xc>

00000138 <__do_clear_bss>:
 138:	22 e0       	ldi	r18, 0x02	; 2
 13a:	a6 e1       	ldi	r26, 0x16	; 22
 13c:	b1 e0       	ldi	r27, 0x01	; 1
 13e:	01 c0       	rjmp	.+2      	; 0x142 <.do_clear_bss_start>

00000140 <.do_clear_bss_loop>:
 140:	1d 92       	st	X+, r1

00000142 <.do_clear_bss_start>:
 142:	af 32       	cpi	r26, 0x2F	; 47
 144:	b2 07       	cpc	r27, r18
 146:	e1 f7       	brne	.-8      	; 0x140 <.do_clear_bss_loop>
 148:	2c d0       	rcall	.+88     	; 0x1a2 <main>
 14a:	0a c7       	rjmp	.+3604   	; 0xf60 <_exit>

0000014c <__bad_interrupt>:
 14c:	59 cf       	rjmp	.-334    	; 0x0 <__vectors>

0000014e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
 14e:	84 b7       	in	r24, 0x34	; 52
 150:	87 7f       	andi	r24, 0xF7	; 247
 152:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
 154:	0f b6       	in	r0, 0x3f	; 63
 156:	f8 94       	cli
 158:	a8 95       	wdr
 15a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__EEPROM_REGION_LENGTH__+0x7f0060>
 15e:	88 61       	ori	r24, 0x18	; 24
 160:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__EEPROM_REGION_LENGTH__+0x7f0060>
 164:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__EEPROM_REGION_LENGTH__+0x7f0060>
 168:	0f be       	out	0x3f, r0	; 63
			 *  \param[in] DoubleSpeed  Enables double speed mode when set, halving the sample time to double the baud rate.
			 */
			static inline void Serial_Init(const uint32_t BaudRate,
			                               const bool DoubleSpeed)
			{
				UBRR1  = (DoubleSpeed ? SERIAL_2X_UBBRVAL(BaudRate) : SERIAL_UBBRVAL(BaudRate));
 16a:	87 e6       	ldi	r24, 0x67	; 103
 16c:	90 e0       	ldi	r25, 0x00	; 0
 16e:	90 93 cd 00 	sts	0x00CD, r25	; 0x8000cd <__EEPROM_REGION_LENGTH__+0x7f00cd>
 172:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__EEPROM_REGION_LENGTH__+0x7f00cc>

				UCSR1C = ((1 << UCSZ11) | (1 << UCSZ10));
 176:	86 e0       	ldi	r24, 0x06	; 6
 178:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__EEPROM_REGION_LENGTH__+0x7f00ca>
				UCSR1A = (DoubleSpeed ? (1 << U2X1) : 0);
 17c:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__EEPROM_REGION_LENGTH__+0x7f00c8>
				UCSR1B = ((1 << TXEN1)  | (1 << RXEN1));
 180:	88 e1       	ldi	r24, 0x18	; 24
 182:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__EEPROM_REGION_LENGTH__+0x7f00c9>
				
				DDRD  |= (1 << 3);
 186:	53 9a       	sbi	0x0a, 3	; 10
				PORTD |= (1 << 2);
 188:	5a 9a       	sbi	0x0b, 2	; 11

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |= LEDS_ALL_LEDS;
 18a:	8a b1       	in	r24, 0x0a	; 10
 18c:	80 63       	ori	r24, 0x30	; 48
 18e:	8a b9       	out	0x0a, r24	; 10
				PORTD |= LEDS_ALL_LEDS;
 190:	8b b1       	in	r24, 0x0b	; 11
 192:	80 63       	ori	r24, 0x30	; 48
 194:	8b b9       	out	0x0b, r24	; 11
	wdt_disable();

	/* Hardware Initialization */
	Serial_Init(9600, false);
	LEDs_Init();
	USB_Init();
 196:	43 d3       	rcall	.+1670   	; 0x81e <USB_Init>

	/* Start the flush timer so that overflows occur rapidly to push received bytes to the USB interface */
	TCCR0B = (1 << CS02);
 198:	84 e0       	ldi	r24, 0x04	; 4
 19a:	85 bd       	out	0x25, r24	; 37
	
	/* Pull target /RESET line high */
	AVR_RESET_LINE_PORT |= AVR_RESET_LINE_MASK;
 19c:	5f 9a       	sbi	0x0b, 7	; 11
	AVR_RESET_LINE_DDR  |= AVR_RESET_LINE_MASK;
 19e:	57 9a       	sbi	0x0a, 7	; 10
}
 1a0:	08 95       	ret

000001a2 <main>:
/** Main program entry point. This routine contains the overall program flow, including initial
 *  setup of all components and the main program loop.
 */
int main(void)
{
	SetupHardware();
 1a2:	d5 df       	rcall	.-86     	; 0x14e <SetupHardware>
		 *
		 *  \param[out] Buffer  Pointer to a ring buffer structure to initialize
		 */
		static inline void RingBuffer_InitBuffer(RingBuff_t* const Buffer)
		{
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 1a4:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 1a6:	f8 94       	cli
			{
				Buffer->In  = Buffer->Buffer;
 1a8:	8e e9       	ldi	r24, 0x9E	; 158
 1aa:	91 e0       	ldi	r25, 0x01	; 1
 1ac:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <USBtoUSART_Buffer+0x81>
 1b0:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <USBtoUSART_Buffer+0x80>
				Buffer->Out = Buffer->Buffer;
 1b4:	90 93 21 02 	sts	0x0221, r25	; 0x800221 <USBtoUSART_Buffer+0x83>
 1b8:	80 93 20 02 	sts	0x0220, r24	; 0x800220 <USBtoUSART_Buffer+0x82>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 1bc:	2f bf       	out	0x3f, r18	; 63
		 *
		 *  \param[out] Buffer  Pointer to a ring buffer structure to initialize
		 */
		static inline void RingBuffer_InitBuffer(RingBuff_t* const Buffer)
		{
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 1be:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 1c0:	f8 94       	cli
			{
				Buffer->In  = Buffer->Buffer;
 1c2:	89 e1       	ldi	r24, 0x19	; 25
 1c4:	91 e0       	ldi	r25, 0x01	; 1
 1c6:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <USARTtoUSB_Buffer+0x81>
 1ca:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <USARTtoUSB_Buffer+0x80>
				Buffer->Out = Buffer->Buffer;
 1ce:	90 93 9c 01 	sts	0x019C, r25	; 0x80019c <USARTtoUSB_Buffer+0x83>
 1d2:	80 93 9b 01 	sts	0x019B, r24	; 0x80019b <USARTtoUSB_Buffer+0x82>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 1d6:	2f bf       	out	0x3f, r18	; 63
	
	RingBuffer_InitBuffer(&USBtoUSART_Buffer);
	RingBuffer_InitBuffer(&USARTtoUSB_Buffer);

	sei();
 1d8:	78 94       	sei
		{
			RingBuff_Count_t Count;
			
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
			{
				Count = Buffer->Count;
 1da:	ce e9       	ldi	r28, 0x9E	; 158
 1dc:	d1 e0       	ldi	r29, 0x01	; 1
		 *
		 *  \return Next data element stored in the buffer
		 */
		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
		{
			RingBuff_Data_t Data = *Buffer->Out;
 1de:	8c 01       	movw	r16, r24
		{
			TIFR0 |= (1 << TOV0);

			if (USARTtoUSB_Buffer.Count) {
				LEDs_TurnOnLEDs(LEDMASK_TX);
				PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;
 1e0:	83 e0       	ldi	r24, 0x03	; 3
 1e2:	e8 2e       	mov	r14, r24
		 */
		static inline RingBuff_Count_t RingBuffer_GetCount(RingBuff_t* const Buffer)
		{
			RingBuff_Count_t Count;
			
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 1e4:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 1e6:	f8 94       	cli
			{
				Count = Buffer->Count;
 1e8:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <USBtoUSART_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 1ec:	9f bf       	out	0x3f, r25	; 63
	sei();

	for (;;)
	{
		/* Only try to read in bytes from the CDC interface if the transmit buffer is not full */
		if (!(RingBuffer_IsFull(&USBtoUSART_Buffer)))
 1ee:	80 38       	cpi	r24, 0x80	; 128
 1f0:	01 f1       	breq	.+64     	; 0x232 <main+0x90>
		{
			int16_t ReceivedByte = CDC_Device_ReceiveByte(&VirtualSerial_CDC_Interface);
 1f2:	80 e0       	ldi	r24, 0x00	; 0
 1f4:	91 e0       	ldi	r25, 0x01	; 1
 1f6:	62 d6       	rcall	.+3268   	; 0xebc <CDC_Device_ReceiveByte>

			/* Read bytes from the USB OUT endpoint into the USART transmit buffer */
			if (!(ReceivedByte < 0))
 1f8:	97 fd       	sbrc	r25, 7
 1fa:	1b c0       	rjmp	.+54     	; 0x232 <main+0x90>
		 *  \param[in]     Data    Data element to insert into the buffer
		 */
		static inline void RingBuffer_Insert(RingBuff_t* const Buffer,
		                                     const RingBuff_Data_t Data)
		{
			*Buffer->In = Data;
 1fc:	e0 91 1e 02 	lds	r30, 0x021E	; 0x80021e <USBtoUSART_Buffer+0x80>
 200:	f0 91 1f 02 	lds	r31, 0x021F	; 0x80021f <USBtoUSART_Buffer+0x81>
			  RingBuffer_Insert(&USBtoUSART_Buffer, ReceivedByte);
 204:	80 83       	st	Z, r24
			
			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
 206:	80 91 1e 02 	lds	r24, 0x021E	; 0x80021e <USBtoUSART_Buffer+0x80>
 20a:	90 91 1f 02 	lds	r25, 0x021F	; 0x80021f <USBtoUSART_Buffer+0x81>
 20e:	01 96       	adiw	r24, 0x01	; 1
 210:	22 e0       	ldi	r18, 0x02	; 2
 212:	8e 31       	cpi	r24, 0x1E	; 30
 214:	92 07       	cpc	r25, r18
 216:	09 f4       	brne	.+2      	; 0x21a <main+0x78>
 218:	65 c0       	rjmp	.+202    	; 0x2e4 <main+0x142>
 21a:	90 93 1f 02 	sts	0x021F, r25	; 0x80021f <USBtoUSART_Buffer+0x81>
 21e:	80 93 1e 02 	sts	0x021E, r24	; 0x80021e <USBtoUSART_Buffer+0x80>
			  Buffer->In = Buffer->Buffer;

			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 222:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 224:	f8 94       	cli
			{
				Buffer->Count++;
 226:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <USBtoUSART_Buffer+0x84>
 22a:	8f 5f       	subi	r24, 0xFF	; 255
 22c:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <USBtoUSART_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 230:	9f bf       	out	0x3f, r25	; 63
		 */
		static inline RingBuff_Count_t RingBuffer_GetCount(RingBuff_t* const Buffer)
		{
			RingBuff_Count_t Count;
			
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 232:	8f b7       	in	r24, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 234:	f8 94       	cli
			{
				Count = Buffer->Count;
 236:	f0 90 9d 01 	lds	r15, 0x019D	; 0x80019d <USARTtoUSB_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 23a:	8f bf       	out	0x3f, r24	; 63
		}
		
		/* Check if the UART receive buffer flush timer has expired or the buffer is nearly full */
		RingBuff_Count_t BufferCount = RingBuffer_GetCount(&USARTtoUSB_Buffer);
		if ((TIFR0 & (1 << TOV0)) || (BufferCount > BUFFER_NEARLY_FULL))
 23c:	a8 99       	sbic	0x15, 0	; 21
 23e:	03 c0       	rjmp	.+6      	; 0x246 <main+0xa4>
 240:	80 e6       	ldi	r24, 0x60	; 96
 242:	8f 15       	cp	r24, r15
 244:	20 f5       	brcc	.+72     	; 0x28e <main+0xec>
		{
			TIFR0 |= (1 << TOV0);
 246:	a8 9a       	sbi	0x15, 0	; 21

			if (USARTtoUSB_Buffer.Count) {
 248:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <USARTtoUSB_Buffer+0x84>
 24c:	88 23       	and	r24, r24
 24e:	19 f0       	breq	.+6      	; 0x256 <main+0xb4>
			}
			
			static inline void LEDs_TurnOnLEDs(const uint8_t LEDMask)
			{
				PORTD &= ~LEDMask;
 250:	5d 98       	cbi	0x0b, 5	; 11
				LEDs_TurnOnLEDs(LEDMASK_TX);
				PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;
 252:	e0 92 16 01 	sts	0x0116, r14	; 0x800116 <__data_end>
			}

			/* Read bytes from the USART receive buffer into the USB IN endpoint */
			while (BufferCount--)
 256:	fa 94       	dec	r15
 258:	8f ef       	ldi	r24, 0xFF	; 255
 25a:	f8 12       	cpse	r15, r24
 25c:	48 c0       	rjmp	.+144    	; 0x2ee <main+0x14c>
			  CDC_Device_SendByte(&VirtualSerial_CDC_Interface, RingBuffer_Remove(&USARTtoUSB_Buffer));
			  
			/* Turn off TX LED(s) once the TX pulse period has elapsed */
			if (PulseMSRemaining.TxLEDPulse && !(--PulseMSRemaining.TxLEDPulse))
 25e:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <__data_end>
 262:	88 23       	and	r24, r24
 264:	41 f0       	breq	.+16     	; 0x276 <main+0xd4>
 266:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <__data_end>
 26a:	81 50       	subi	r24, 0x01	; 1
 26c:	80 93 16 01 	sts	0x0116, r24	; 0x800116 <__data_end>
 270:	81 11       	cpse	r24, r1
 272:	01 c0       	rjmp	.+2      	; 0x276 <main+0xd4>
			}

			static inline void LEDs_TurnOffLEDs(const uint8_t LEDMask)
			{
				PORTD |= LEDMask;
 274:	5d 9a       	sbi	0x0b, 5	; 11
			  LEDs_TurnOffLEDs(LEDMASK_TX);

			/* Turn off RX LED(s) once the RX pulse period has elapsed */
			if (PulseMSRemaining.RxLEDPulse && !(--PulseMSRemaining.RxLEDPulse))
 276:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <__data_end+0x1>
 27a:	88 23       	and	r24, r24
 27c:	41 f0       	breq	.+16     	; 0x28e <main+0xec>
 27e:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <__data_end+0x1>
 282:	81 50       	subi	r24, 0x01	; 1
 284:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <__data_end+0x1>
 288:	81 11       	cpse	r24, r1
 28a:	01 c0       	rjmp	.+2      	; 0x28e <main+0xec>
 28c:	5c 9a       	sbi	0x0b, 4	; 11
		 */
		static inline RingBuff_Count_t RingBuffer_GetCount(RingBuff_t* const Buffer)
		{
			RingBuff_Count_t Count;
			
			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 28e:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 290:	f8 94       	cli
			{
				Count = Buffer->Count;
 292:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <USBtoUSART_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 296:	9f bf       	out	0x3f, r25	; 63
			  LEDs_TurnOffLEDs(LEDMASK_RX);
		}
		
		/* Load the next byte from the USART transmit buffer into the USART */
		if (!(RingBuffer_IsEmpty(&USBtoUSART_Buffer))) {
 298:	88 23       	and	r24, r24
 29a:	f9 f0       	breq	.+62     	; 0x2da <main+0x138>
		 *
		 *  \return Next data element stored in the buffer
		 */
		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
		{
			RingBuff_Data_t Data = *Buffer->Out;
 29c:	e0 91 20 02 	lds	r30, 0x0220	; 0x800220 <USBtoUSART_Buffer+0x82>
 2a0:	f0 91 21 02 	lds	r31, 0x0221	; 0x800221 <USBtoUSART_Buffer+0x83>
 2a4:	91 91       	ld	r25, Z+
			
			if (++Buffer->Out == &Buffer->Buffer[BUFFER_SIZE])
 2a6:	22 e0       	ldi	r18, 0x02	; 2
 2a8:	ee 31       	cpi	r30, 0x1E	; 30
 2aa:	f2 07       	cpc	r31, r18
 2ac:	09 f4       	brne	.+2      	; 0x2b0 <main+0x10e>
 2ae:	3d c0       	rjmp	.+122    	; 0x32a <__stack+0x2b>
 2b0:	f0 93 21 02 	sts	0x0221, r31	; 0x800221 <USBtoUSART_Buffer+0x83>
 2b4:	e0 93 20 02 	sts	0x0220, r30	; 0x800220 <USBtoUSART_Buffer+0x82>
			  Buffer->Out = Buffer->Buffer;

			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 2b8:	2f b7       	in	r18, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 2ba:	f8 94       	cli
			{
				Buffer->Count--;
 2bc:	80 91 22 02 	lds	r24, 0x0222	; 0x800222 <USBtoUSART_Buffer+0x84>
 2c0:	81 50       	subi	r24, 0x01	; 1
 2c2:	80 93 22 02 	sts	0x0222, r24	; 0x800222 <USBtoUSART_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 2c6:	2f bf       	out	0x3f, r18	; 63
			 *  \param[in] DataByte  Byte to transmit through the USART.
			 */
			static inline void Serial_TxByte(const char DataByte) ATTR_ALWAYS_INLINE;
			static inline void Serial_TxByte(const char DataByte)
			{
				while (!(UCSR1A & (1 << UDRE1)));
 2c8:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__EEPROM_REGION_LENGTH__+0x7f00c8>
 2cc:	85 ff       	sbrs	r24, 5
 2ce:	fc cf       	rjmp	.-8      	; 0x2c8 <main+0x126>
				UDR1 = DataByte;
 2d0:	90 93 ce 00 	sts	0x00CE, r25	; 0x8000ce <__EEPROM_REGION_LENGTH__+0x7f00ce>
				PORTD |= LEDS_ALL_LEDS;
			}
			
			static inline void LEDs_TurnOnLEDs(const uint8_t LEDMask)
			{
				PORTD &= ~LEDMask;
 2d4:	5c 98       	cbi	0x0b, 4	; 11
		  Serial_TxByte(RingBuffer_Remove(&USBtoUSART_Buffer));
		  	
		  	LEDs_TurnOnLEDs(LEDMASK_RX);
			PulseMSRemaining.RxLEDPulse = TX_RX_LED_PULSE_MS;
 2d6:	e0 92 17 01 	sts	0x0117, r14	; 0x800117 <__data_end+0x1>
		}
		
		CDC_Device_USBTask(&VirtualSerial_CDC_Interface);
 2da:	80 e0       	ldi	r24, 0x00	; 0
 2dc:	91 e0       	ldi	r25, 0x01	; 1
		USB_USBTask();
 2de:	e0 d5       	rcall	.+3008   	; 0xea0 <CDC_Device_USBTask>
 2e0:	d1 d4       	rcall	.+2466   	; 0xc84 <USB_USBTask>
	RingBuffer_InitBuffer(&USARTtoUSB_Buffer);

	sei();

	for (;;)
	{
 2e2:	80 cf       	rjmp	.-256    	; 0x1e4 <main+0x42>
		                                     const RingBuff_Data_t Data)
		{
			*Buffer->In = Data;
			
			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
			  Buffer->In = Buffer->Buffer;
 2e4:	d0 93 1f 02 	sts	0x021F, r29	; 0x80021f <USBtoUSART_Buffer+0x81>
 2e8:	c0 93 1e 02 	sts	0x021E, r28	; 0x80021e <USBtoUSART_Buffer+0x80>
 2ec:	9a cf       	rjmp	.-204    	; 0x222 <main+0x80>
		 *
		 *  \return Next data element stored in the buffer
		 */
		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
		{
			RingBuff_Data_t Data = *Buffer->Out;
 2ee:	e0 91 9b 01 	lds	r30, 0x019B	; 0x80019b <USARTtoUSB_Buffer+0x82>
 2f2:	f0 91 9c 01 	lds	r31, 0x019C	; 0x80019c <USARTtoUSB_Buffer+0x83>
 2f6:	61 91       	ld	r22, Z+
			
			if (++Buffer->Out == &Buffer->Buffer[BUFFER_SIZE])
 2f8:	21 e0       	ldi	r18, 0x01	; 1
 2fa:	e9 39       	cpi	r30, 0x99	; 153
 2fc:	f2 07       	cpc	r31, r18
 2fe:	81 f0       	breq	.+32     	; 0x320 <__stack+0x21>
 300:	f0 93 9c 01 	sts	0x019C, r31	; 0x80019c <USARTtoUSB_Buffer+0x83>
 304:	e0 93 9b 01 	sts	0x019B, r30	; 0x80019b <USARTtoUSB_Buffer+0x82>
			  Buffer->Out = Buffer->Buffer;

			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 308:	9f b7       	in	r25, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 30a:	f8 94       	cli
			{
				Buffer->Count--;
 30c:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <USARTtoUSB_Buffer+0x84>
 310:	81 50       	subi	r24, 0x01	; 1
 312:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <USARTtoUSB_Buffer+0x84>
				PulseMSRemaining.TxLEDPulse = TX_RX_LED_PULSE_MS;
			}

			/* Read bytes from the USART receive buffer into the USB IN endpoint */
			while (BufferCount--)
			  CDC_Device_SendByte(&VirtualSerial_CDC_Interface, RingBuffer_Remove(&USARTtoUSB_Buffer));
 316:	9f bf       	out	0x3f, r25	; 63
 318:	80 e0       	ldi	r24, 0x00	; 0
 31a:	91 e0       	ldi	r25, 0x01	; 1
 31c:	6f d5       	rcall	.+2782   	; 0xdfc <CDC_Device_SendByte>
 31e:	9b cf       	rjmp	.-202    	; 0x256 <main+0xb4>
		static inline RingBuff_Data_t RingBuffer_Remove(RingBuff_t* const Buffer)
		{
			RingBuff_Data_t Data = *Buffer->Out;
			
			if (++Buffer->Out == &Buffer->Buffer[BUFFER_SIZE])
			  Buffer->Out = Buffer->Buffer;
 320:	10 93 9c 01 	sts	0x019C, r17	; 0x80019c <USARTtoUSB_Buffer+0x83>
 324:	00 93 9b 01 	sts	0x019B, r16	; 0x80019b <USARTtoUSB_Buffer+0x82>
 328:	ef cf       	rjmp	.-34     	; 0x308 <__stack+0x9>
 32a:	d0 93 21 02 	sts	0x0221, r29	; 0x800221 <USBtoUSART_Buffer+0x83>
 32e:	c0 93 20 02 	sts	0x0220, r28	; 0x800220 <USBtoUSART_Buffer+0x82>
 332:	c2 cf       	rjmp	.-124    	; 0x2b8 <main+0x116>

00000334 <EVENT_USB_Device_ConfigurationChanged>:
}

/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	CDC_Device_ConfigureEndpoints(&VirtualSerial_CDC_Interface);
 334:	80 e0       	ldi	r24, 0x00	; 0
 336:	91 e0       	ldi	r25, 0x01	; 1
 338:	1d c5       	rjmp	.+2618   	; 0xd74 <CDC_Device_ConfigureEndpoints>

0000033a <EVENT_USB_Device_UnhandledControlRequest>:
}

/** Event handler for the library USB Unhandled Control Request event. */
void EVENT_USB_Device_UnhandledControlRequest(void)
{
	CDC_Device_ProcessControlRequest(&VirtualSerial_CDC_Interface);
 33a:	80 e0       	ldi	r24, 0x00	; 0
 33c:	91 e0       	ldi	r25, 0x01	; 1
 33e:	b4 c4       	rjmp	.+2408   	; 0xca8 <CDC_Device_ProcessControlRequest>

00000340 <EVENT_CDC_Device_LineEncodingChanged>:
/** Event handler for the CDC Class driver Line Encoding Changed event.
 *
 *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being referenced
 */
void EVENT_CDC_Device_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
 340:	0f 93       	push	r16
 342:	1f 93       	push	r17
 344:	cf 93       	push	r28
 346:	8c 01       	movw	r16, r24
	uint8_t ConfigMask = 0;

	switch (CDCInterfaceInfo->State.LineEncoding.ParityType)
 348:	fc 01       	movw	r30, r24
 34a:	84 89       	ldd	r24, Z+20	; 0x14
	{
		case CDC_PARITY_Odd:
			ConfigMask = ((1 << UPM11) | (1 << UPM10));		
 34c:	c0 e3       	ldi	r28, 0x30	; 48
 */
void EVENT_CDC_Device_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t ConfigMask = 0;

	switch (CDCInterfaceInfo->State.LineEncoding.ParityType)
 34e:	81 30       	cpi	r24, 0x01	; 1
 350:	21 f0       	breq	.+8      	; 0x35a <EVENT_CDC_Device_LineEncodingChanged+0x1a>
	{
		case CDC_PARITY_Odd:
			ConfigMask = ((1 << UPM11) | (1 << UPM10));		
			break;
		case CDC_PARITY_Even:
			ConfigMask = (1 << UPM11);		
 352:	c0 e2       	ldi	r28, 0x20	; 32
 */
void EVENT_CDC_Device_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t ConfigMask = 0;

	switch (CDCInterfaceInfo->State.LineEncoding.ParityType)
 354:	82 30       	cpi	r24, 0x02	; 2
 356:	09 f0       	breq	.+2      	; 0x35a <EVENT_CDC_Device_LineEncodingChanged+0x1a>
 *
 *  \param[in] CDCInterfaceInfo  Pointer to the CDC class interface configuration structure being referenced
 */
void EVENT_CDC_Device_LineEncodingChanged(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	uint8_t ConfigMask = 0;
 358:	c0 e0       	ldi	r28, 0x00	; 0
		case CDC_PARITY_Even:
			ConfigMask = (1 << UPM11);		
			break;
	}

	if (CDCInterfaceInfo->State.LineEncoding.CharFormat == CDC_LINEENCODING_TwoStopBits)
 35a:	f8 01       	movw	r30, r16
 35c:	83 89       	ldd	r24, Z+19	; 0x13
 35e:	82 30       	cpi	r24, 0x02	; 2
 360:	09 f4       	brne	.+2      	; 0x364 <EVENT_CDC_Device_LineEncodingChanged+0x24>
	  ConfigMask |= (1 << USBS1);
 362:	c8 60       	ori	r28, 0x08	; 8

	switch (CDCInterfaceInfo->State.LineEncoding.DataBits)
 364:	f8 01       	movw	r30, r16
 366:	85 89       	ldd	r24, Z+21	; 0x15
 368:	87 30       	cpi	r24, 0x07	; 7
 36a:	e9 f1       	breq	.+122    	; 0x3e6 <EVENT_CDC_Device_LineEncodingChanged+0xa6>
 36c:	88 30       	cpi	r24, 0x08	; 8
 36e:	e9 f1       	breq	.+122    	; 0x3ea <EVENT_CDC_Device_LineEncodingChanged+0xaa>
 370:	86 30       	cpi	r24, 0x06	; 6
 372:	09 f4       	brne	.+2      	; 0x376 <EVENT_CDC_Device_LineEncodingChanged+0x36>
	{
		case 6:
			ConfigMask |= (1 << UCSZ10);
 374:	c2 60       	ori	r28, 0x02	; 2
			ConfigMask |= ((1 << UCSZ11) | (1 << UCSZ10));
			break;
	}

	/* Must turn off USART before reconfiguring it, otherwise incorrect operation may occur */
	UCSR1B = 0;
 376:	10 92 c9 00 	sts	0x00C9, r1	; 0x8000c9 <__EEPROM_REGION_LENGTH__+0x7f00c9>
	UCSR1A = 0;
 37a:	10 92 c8 00 	sts	0x00C8, r1	; 0x8000c8 <__EEPROM_REGION_LENGTH__+0x7f00c8>
	UCSR1C = 0;
 37e:	10 92 ca 00 	sts	0x00CA, r1	; 0x8000ca <__EEPROM_REGION_LENGTH__+0x7f00ca>

	/* Special case 57600 baud for compatibility with the ATmega328 bootloader. */	
	UBRR1  = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600)
 382:	f8 01       	movw	r30, r16
 384:	27 85       	ldd	r18, Z+15	; 0x0f
 386:	30 89       	ldd	r19, Z+16	; 0x10
 388:	41 89       	ldd	r20, Z+17	; 0x11
 38a:	52 89       	ldd	r21, Z+18	; 0x12
 38c:	21 15       	cp	r18, r1
 38e:	f1 ee       	ldi	r31, 0xE1	; 225
 390:	3f 07       	cpc	r19, r31
 392:	41 05       	cpc	r20, r1
 394:	51 05       	cpc	r21, r1
 396:	59 f1       	breq	.+86     	; 0x3ee <EVENT_CDC_Device_LineEncodingChanged+0xae>
			 ? SERIAL_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS)
			 : SERIAL_2X_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);	
 398:	ca 01       	movw	r24, r20
 39a:	b9 01       	movw	r22, r18
 39c:	96 95       	lsr	r25
 39e:	87 95       	ror	r24
 3a0:	77 95       	ror	r23
 3a2:	67 95       	ror	r22
 3a4:	60 58       	subi	r22, 0x80	; 128
 3a6:	7b 47       	sbci	r23, 0x7B	; 123
 3a8:	81 4e       	sbci	r24, 0xE1	; 225
 3aa:	9f 4f       	sbci	r25, 0xFF	; 255
 3ac:	b1 d5       	rcall	.+2914   	; 0xf10 <__udivmodsi4>
	UCSR1B = 0;
	UCSR1A = 0;
	UCSR1C = 0;

	/* Special case 57600 baud for compatibility with the ATmega328 bootloader. */	
	UBRR1  = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600)
 3ae:	21 50       	subi	r18, 0x01	; 1
 3b0:	31 09       	sbc	r19, r1
 3b2:	30 93 cd 00 	sts	0x00CD, r19	; 0x8000cd <__EEPROM_REGION_LENGTH__+0x7f00cd>
 3b6:	20 93 cc 00 	sts	0x00CC, r18	; 0x8000cc <__EEPROM_REGION_LENGTH__+0x7f00cc>
			 ? SERIAL_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS)
			 : SERIAL_2X_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);	

	UCSR1C = ConfigMask;
 3ba:	c0 93 ca 00 	sts	0x00CA, r28	; 0x8000ca <__EEPROM_REGION_LENGTH__+0x7f00ca>
	UCSR1A = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600) ? 0 : (1 << U2X1);
 3be:	f8 01       	movw	r30, r16
 3c0:	87 85       	ldd	r24, Z+15	; 0x0f
 3c2:	90 89       	ldd	r25, Z+16	; 0x10
 3c4:	a1 89       	ldd	r26, Z+17	; 0x11
 3c6:	b2 89       	ldd	r27, Z+18	; 0x12
 3c8:	81 15       	cp	r24, r1
 3ca:	91 4e       	sbci	r25, 0xE1	; 225
 3cc:	a1 05       	cpc	r26, r1
 3ce:	b1 05       	cpc	r27, r1
 3d0:	89 f0       	breq	.+34     	; 0x3f4 <EVENT_CDC_Device_LineEncodingChanged+0xb4>
 3d2:	82 e0       	ldi	r24, 0x02	; 2
 3d4:	80 93 c8 00 	sts	0x00C8, r24	; 0x8000c8 <__EEPROM_REGION_LENGTH__+0x7f00c8>
	UCSR1B = ((1 << RXCIE1) | (1 << TXEN1) | (1 << RXEN1));
 3d8:	88 e9       	ldi	r24, 0x98	; 152
 3da:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__EEPROM_REGION_LENGTH__+0x7f00c9>
}
 3de:	cf 91       	pop	r28
 3e0:	1f 91       	pop	r17
 3e2:	0f 91       	pop	r16
 3e4:	08 95       	ret
	{
		case 6:
			ConfigMask |= (1 << UCSZ10);
			break;
		case 7:
			ConfigMask |= (1 << UCSZ11);
 3e6:	c4 60       	ori	r28, 0x04	; 4
			break;
 3e8:	c6 cf       	rjmp	.-116    	; 0x376 <EVENT_CDC_Device_LineEncodingChanged+0x36>
		case 8:
			ConfigMask |= ((1 << UCSZ11) | (1 << UCSZ10));
 3ea:	c6 60       	ori	r28, 0x06	; 6
			break;
 3ec:	c4 cf       	rjmp	.-120    	; 0x376 <EVENT_CDC_Device_LineEncodingChanged+0x36>
	UCSR1B = 0;
	UCSR1A = 0;
	UCSR1C = 0;

	/* Special case 57600 baud for compatibility with the ATmega328 bootloader. */	
	UBRR1  = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600)
 3ee:	20 e1       	ldi	r18, 0x10	; 16
 3f0:	30 e0       	ldi	r19, 0x00	; 0
 3f2:	df cf       	rjmp	.-66     	; 0x3b2 <EVENT_CDC_Device_LineEncodingChanged+0x72>
			 ? SERIAL_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS)
			 : SERIAL_2X_UBBRVAL(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS);	

	UCSR1C = ConfigMask;
	UCSR1A = (CDCInterfaceInfo->State.LineEncoding.BaudRateBPS == 57600) ? 0 : (1 << U2X1);
 3f4:	80 e0       	ldi	r24, 0x00	; 0
 3f6:	ee cf       	rjmp	.-36     	; 0x3d4 <EVENT_CDC_Device_LineEncodingChanged+0x94>

000003f8 <__vector_23>:

/** ISR to manage the reception of data from the serial port, placing received bytes into a circular buffer
 *  for later transmission to the host.
 */
ISR(USART1_RX_vect, ISR_BLOCK)
{
 3f8:	1f 92       	push	r1
 3fa:	0f 92       	push	r0
 3fc:	0f b6       	in	r0, 0x3f	; 63
 3fe:	0f 92       	push	r0
 400:	11 24       	eor	r1, r1
 402:	2f 93       	push	r18
 404:	8f 93       	push	r24
 406:	9f 93       	push	r25
 408:	ef 93       	push	r30
 40a:	ff 93       	push	r31
	uint8_t ReceivedByte = UDR1;
 40c:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__EEPROM_REGION_LENGTH__+0x7f00ce>

	if (USB_DeviceState == DEVICE_STATE_Configured)
 410:	9e b3       	in	r25, 0x1e	; 30
 412:	94 30       	cpi	r25, 0x04	; 4
 414:	d9 f4       	brne	.+54     	; 0x44c <__LOCK_REGION_LENGTH__+0x4c>
		 *  \param[in]     Data    Data element to insert into the buffer
		 */
		static inline void RingBuffer_Insert(RingBuff_t* const Buffer,
		                                     const RingBuff_Data_t Data)
		{
			*Buffer->In = Data;
 416:	e0 91 99 01 	lds	r30, 0x0199	; 0x800199 <USARTtoUSB_Buffer+0x80>
 41a:	f0 91 9a 01 	lds	r31, 0x019A	; 0x80019a <USARTtoUSB_Buffer+0x81>
 41e:	80 83       	st	Z, r24
			
			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
 420:	e0 91 99 01 	lds	r30, 0x0199	; 0x800199 <USARTtoUSB_Buffer+0x80>
 424:	f0 91 9a 01 	lds	r31, 0x019A	; 0x80019a <USARTtoUSB_Buffer+0x81>
 428:	cf 01       	movw	r24, r30
 42a:	01 96       	adiw	r24, 0x01	; 1
 42c:	21 e0       	ldi	r18, 0x01	; 1
 42e:	89 39       	cpi	r24, 0x99	; 153
 430:	92 07       	cpc	r25, r18
 432:	b1 f0       	breq	.+44     	; 0x460 <__LOCK_REGION_LENGTH__+0x60>
 434:	90 93 9a 01 	sts	0x019A, r25	; 0x80019a <USARTtoUSB_Buffer+0x81>
 438:	80 93 99 01 	sts	0x0199, r24	; 0x800199 <USARTtoUSB_Buffer+0x80>
			  Buffer->In = Buffer->Buffer;

			ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 43c:	9f b7       	in	r25, 0x3f	; 63
 43e:	f8 94       	cli
			{
				Buffer->Count++;
 440:	80 91 9d 01 	lds	r24, 0x019D	; 0x80019d <USARTtoUSB_Buffer+0x84>
 444:	8f 5f       	subi	r24, 0xFF	; 255
 446:	80 93 9d 01 	sts	0x019D, r24	; 0x80019d <USARTtoUSB_Buffer+0x84>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 44a:	9f bf       	out	0x3f, r25	; 63
	  RingBuffer_Insert(&USARTtoUSB_Buffer, ReceivedByte);
}
 44c:	ff 91       	pop	r31
 44e:	ef 91       	pop	r30
 450:	9f 91       	pop	r25
 452:	8f 91       	pop	r24
 454:	2f 91       	pop	r18
 456:	0f 90       	pop	r0
 458:	0f be       	out	0x3f, r0	; 63
 45a:	0f 90       	pop	r0
 45c:	1f 90       	pop	r1
 45e:	18 95       	reti
		                                     const RingBuff_Data_t Data)
		{
			*Buffer->In = Data;
			
			if (++Buffer->In == &Buffer->Buffer[BUFFER_SIZE])
			  Buffer->In = Buffer->Buffer;
 460:	89 e1       	ldi	r24, 0x19	; 25
 462:	91 e0       	ldi	r25, 0x01	; 1
 464:	92 83       	std	Z+2, r25	; 0x02
 466:	81 83       	std	Z+1, r24	; 0x01
 468:	e9 cf       	rjmp	.-46     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>

0000046a <EVENT_CDC_Device_ControLineStateChanged>:
 */
void EVENT_CDC_Device_ControLineStateChanged(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	bool CurrentDTRState = (CDCInterfaceInfo->State.ControlLineStates.HostToDevice & CDC_CONTROL_LINE_OUT_DTR);

	if (CurrentDTRState)
 46a:	fc 01       	movw	r30, r24
 46c:	85 85       	ldd	r24, Z+13	; 0x0d
 46e:	80 ff       	sbrs	r24, 0
 470:	02 c0       	rjmp	.+4      	; 0x476 <EVENT_CDC_Device_ControLineStateChanged+0xc>
	  AVR_RESET_LINE_PORT &= ~AVR_RESET_LINE_MASK;
 472:	5f 98       	cbi	0x0b, 7	; 11
 474:	08 95       	ret
	else
	  AVR_RESET_LINE_PORT |= AVR_RESET_LINE_MASK;
 476:	5f 9a       	sbi	0x0b, 7	; 11
}
 478:	08 95       	ret

0000047a <CALLBACK_USB_GetDescriptor>:
 */
uint16_t CALLBACK_USB_GetDescriptor(const uint16_t wValue,
                                    const uint8_t wIndex,
                                    void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
 47a:	29 2f       	mov	r18, r25
 47c:	33 27       	eor	r19, r19
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	void*    Address = NULL;
	uint16_t Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
 47e:	22 30       	cpi	r18, 0x02	; 2
 480:	31 05       	cpc	r19, r1
 482:	71 f0       	breq	.+28     	; 0x4a0 <CALLBACK_USB_GetDescriptor+0x26>
 484:	23 30       	cpi	r18, 0x03	; 3
 486:	31 05       	cpc	r19, r1
 488:	81 f0       	breq	.+32     	; 0x4aa <CALLBACK_USB_GetDescriptor+0x30>
 48a:	21 30       	cpi	r18, 0x01	; 1
 48c:	31 05       	cpc	r19, r1
 48e:	a1 f4       	brne	.+40     	; 0x4b8 <CALLBACK_USB_GetDescriptor+0x3e>
	{
		case DTYPE_Device: 
			Address = (void*)&DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
 490:	82 e1       	ldi	r24, 0x12	; 18
 492:	90 e0       	ldi	r25, 0x00	; 0
	uint16_t Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device: 
			Address = (void*)&DeviceDescriptor;
 494:	24 e0       	ldi	r18, 0x04	; 4
 496:	31 e0       	ldi	r19, 0x01	; 1
			}
			
			break;
	}
	
	*DescriptorAddress = Address;
 498:	fa 01       	movw	r30, r20
 49a:	31 83       	std	Z+1, r19	; 0x01
 49c:	20 83       	st	Z, r18
	return Size;
}
 49e:	08 95       	ret
			Address = (void*)&DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration: 
			Address = (void*)&ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
 4a0:	8e e3       	ldi	r24, 0x3E	; 62
 4a2:	90 e0       	ldi	r25, 0x00	; 0
		case DTYPE_Device: 
			Address = (void*)&DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration: 
			Address = (void*)&ConfigurationDescriptor;
 4a4:	26 ec       	ldi	r18, 0xC6	; 198
 4a6:	30 e0       	ldi	r19, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
 4a8:	f7 cf       	rjmp	.-18     	; 0x498 <CALLBACK_USB_GetDescriptor+0x1e>
		case DTYPE_String: 
			switch (DescriptorNumber)
 4aa:	99 27       	eor	r25, r25
 4ac:	81 30       	cpi	r24, 0x01	; 1
 4ae:	91 05       	cpc	r25, r1
 4b0:	71 f0       	breq	.+28     	; 0x4ce <CALLBACK_USB_GetDescriptor+0x54>
 4b2:	38 f0       	brcs	.+14     	; 0x4c2 <CALLBACK_USB_GetDescriptor+0x48>
 4b4:	02 97       	sbiw	r24, 0x02	; 2
 4b6:	71 f0       	breq	.+28     	; 0x4d4 <CALLBACK_USB_GetDescriptor+0x5a>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	void*    Address = NULL;
	uint16_t Size    = NO_DESCRIPTOR;
 4b8:	90 e0       	ldi	r25, 0x00	; 0
 4ba:	80 e0       	ldi	r24, 0x00	; 0
                                    void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	void*    Address = NULL;
 4bc:	30 e0       	ldi	r19, 0x00	; 0
 4be:	20 e0       	ldi	r18, 0x00	; 0
 4c0:	eb cf       	rjmp	.-42     	; 0x498 <CALLBACK_USB_GetDescriptor+0x1e>
		case DTYPE_String: 
			switch (DescriptorNumber)
			{
				case 0x00: 
					Address = (void*)&LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
 4c2:	e2 ec       	ldi	r30, 0xC2	; 194
 4c4:	f0 e0       	ldi	r31, 0x00	; 0
					Address = (void*)&ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02: 
					Address = (void*)&ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
 4c6:	84 91       	lpm	r24, Z
 4c8:	90 e0       	ldi	r25, 0x00	; 0
				case 0x01: 
					Address = (void*)&ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
					break;
				case 0x02: 
					Address = (void*)&ProductString;
 4ca:	9f 01       	movw	r18, r30
					Size    = pgm_read_byte(&ProductString.Header.Size);
					break;
 4cc:	e5 cf       	rjmp	.-54     	; 0x498 <CALLBACK_USB_GetDescriptor+0x1e>
					Address = (void*)&LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
					break;
				case 0x01: 
					Address = (void*)&ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
 4ce:	ee e8       	ldi	r30, 0x8E	; 142
 4d0:	f0 e0       	ldi	r31, 0x00	; 0
 4d2:	f9 cf       	rjmp	.-14     	; 0x4c6 <CALLBACK_USB_GetDescriptor+0x4c>
					break;
				case 0x02: 
					Address = (void*)&ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
 4d4:	e4 e7       	ldi	r30, 0x74	; 116
 4d6:	f0 e0       	ldi	r31, 0x00	; 0
 4d8:	f6 cf       	rjmp	.-20     	; 0x4c6 <CALLBACK_USB_GetDescriptor+0x4c>

000004da <Endpoint_BytesToEPSizeMaskDynamic>:

		if (Endpoint_IsOUTReceived())
		  break;
		
		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
 4da:	ac 01       	movw	r20, r24
 4dc:	28 e0       	ldi	r18, 0x08	; 8
 4de:	30 e0       	ldi	r19, 0x00	; 0
 4e0:	80 e0       	ldi	r24, 0x00	; 0
 4e2:	24 17       	cp	r18, r20
 4e4:	35 07       	cpc	r19, r21
 4e6:	18 f0       	brcs	.+6      	; 0x4ee <Endpoint_BytesToEPSizeMaskDynamic+0x14>
 4e8:	82 95       	swap	r24
 4ea:	80 7f       	andi	r24, 0xF0	; 240
 4ec:	08 95       	ret
 4ee:	8f 5f       	subi	r24, 0xFF	; 255
 4f0:	22 0f       	add	r18, r18
 4f2:	33 1f       	adc	r19, r19
 4f4:	f6 cf       	rjmp	.-20     	; 0x4e2 <Endpoint_BytesToEPSizeMaskDynamic+0x8>

000004f6 <Endpoint_ConfigureEndpoint_Prv>:
 4f6:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 4fa:	eb ee       	ldi	r30, 0xEB	; 235
 4fc:	f0 e0       	ldi	r31, 0x00	; 0
 4fe:	80 81       	ld	r24, Z
 500:	81 60       	ori	r24, 0x01	; 1
 502:	80 83       	st	Z, r24
 504:	ed ee       	ldi	r30, 0xED	; 237
 506:	f0 e0       	ldi	r31, 0x00	; 0
 508:	10 82       	st	Z, r1
 50a:	60 93 ec 00 	sts	0x00EC, r22	; 0x8000ec <__EEPROM_REGION_LENGTH__+0x7f00ec>
 50e:	40 83       	st	Z, r20
 510:	80 91 ee 00 	lds	r24, 0x00EE	; 0x8000ee <__EEPROM_REGION_LENGTH__+0x7f00ee>
 514:	88 1f       	adc	r24, r24
 516:	88 27       	eor	r24, r24
 518:	88 1f       	adc	r24, r24
 51a:	08 95       	ret

0000051c <Endpoint_ClearEndpoints>:
 51c:	10 92 f4 00 	sts	0x00F4, r1	; 0x8000f4 <__EEPROM_REGION_LENGTH__+0x7f00f4>
 520:	80 e0       	ldi	r24, 0x00	; 0
 522:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 526:	10 92 f0 00 	sts	0x00F0, r1	; 0x8000f0 <__EEPROM_REGION_LENGTH__+0x7f00f0>
 52a:	10 92 e8 00 	sts	0x00E8, r1	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 52e:	10 92 ed 00 	sts	0x00ED, r1	; 0x8000ed <__EEPROM_REGION_LENGTH__+0x7f00ed>
 532:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 536:	9e 7f       	andi	r25, 0xFE	; 254
 538:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 53c:	8f 5f       	subi	r24, 0xFF	; 255
 53e:	85 30       	cpi	r24, 0x05	; 5
 540:	81 f7       	brne	.-32     	; 0x522 <Endpoint_ClearEndpoints+0x6>
 542:	08 95       	ret

00000544 <Endpoint_ClearStatusStage>:
 544:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <USB_ControlRequest>
 548:	87 ff       	sbrs	r24, 7
 54a:	11 c0       	rjmp	.+34     	; 0x56e <Endpoint_ClearStatusStage+0x2a>
 54c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 550:	82 ff       	sbrs	r24, 2
 552:	06 c0       	rjmp	.+12     	; 0x560 <Endpoint_ClearStatusStage+0x1c>
 554:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 558:	8b 77       	andi	r24, 0x7B	; 123
 55a:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 55e:	03 c0       	rjmp	.+6      	; 0x566 <Endpoint_ClearStatusStage+0x22>
 560:	8e b3       	in	r24, 0x1e	; 30
 562:	81 11       	cpse	r24, r1
 564:	f3 cf       	rjmp	.-26     	; 0x54c <Endpoint_ClearStatusStage+0x8>
 566:	08 95       	ret
 568:	8e b3       	in	r24, 0x1e	; 30
 56a:	88 23       	and	r24, r24
 56c:	e1 f3       	breq	.-8      	; 0x566 <Endpoint_ClearStatusStage+0x22>
 56e:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 572:	80 ff       	sbrs	r24, 0
 574:	f9 cf       	rjmp	.-14     	; 0x568 <Endpoint_ClearStatusStage+0x24>
 576:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 57a:	8e 77       	andi	r24, 0x7E	; 126
 57c:	ee cf       	rjmp	.-36     	; 0x55a <Endpoint_ClearStatusStage+0x16>

0000057e <Endpoint_WaitUntilReady>:
 57e:	85 e6       	ldi	r24, 0x65	; 101
 580:	90 91 ec 00 	lds	r25, 0x00EC	; 0x8000ec <__EEPROM_REGION_LENGTH__+0x7f00ec>
 584:	90 ff       	sbrs	r25, 0
 586:	06 c0       	rjmp	.+12     	; 0x594 <Endpoint_WaitUntilReady+0x16>
 588:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 58c:	90 ff       	sbrs	r25, 0
 58e:	06 c0       	rjmp	.+12     	; 0x59c <Endpoint_WaitUntilReady+0x1e>
 590:	80 e0       	ldi	r24, 0x00	; 0
 592:	08 95       	ret
 594:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 598:	92 fd       	sbrc	r25, 2
 59a:	fa cf       	rjmp	.-12     	; 0x590 <Endpoint_WaitUntilReady+0x12>
 59c:	9e b3       	in	r25, 0x1e	; 30
 59e:	99 23       	and	r25, r25
 5a0:	a1 f0       	breq	.+40     	; 0x5ca <Endpoint_WaitUntilReady+0x4c>
 5a2:	9e b3       	in	r25, 0x1e	; 30
 5a4:	95 30       	cpi	r25, 0x05	; 5
 5a6:	99 f0       	breq	.+38     	; 0x5ce <Endpoint_WaitUntilReady+0x50>
 5a8:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 5ac:	95 fd       	sbrc	r25, 5
 5ae:	11 c0       	rjmp	.+34     	; 0x5d2 <Endpoint_WaitUntilReady+0x54>
 5b0:	90 91 e1 00 	lds	r25, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 5b4:	92 ff       	sbrs	r25, 2
 5b6:	e4 cf       	rjmp	.-56     	; 0x580 <Endpoint_WaitUntilReady+0x2>
 5b8:	90 91 e1 00 	lds	r25, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 5bc:	9b 7f       	andi	r25, 0xFB	; 251
 5be:	90 93 e1 00 	sts	0x00E1, r25	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 5c2:	81 50       	subi	r24, 0x01	; 1
 5c4:	e9 f6       	brne	.-70     	; 0x580 <Endpoint_WaitUntilReady+0x2>
 5c6:	84 e0       	ldi	r24, 0x04	; 4
 5c8:	08 95       	ret
 5ca:	82 e0       	ldi	r24, 0x02	; 2
 5cc:	08 95       	ret
 5ce:	83 e0       	ldi	r24, 0x03	; 3
 5d0:	08 95       	ret
 5d2:	81 e0       	ldi	r24, 0x01	; 1
 5d4:	08 95       	ret

000005d6 <Endpoint_Write_Control_Stream_LE>:
 5d6:	20 91 2d 02 	lds	r18, 0x022D	; 0x80022d <USB_ControlRequest+0x6>
 5da:	30 91 2e 02 	lds	r19, 0x022E	; 0x80022e <USB_ControlRequest+0x7>
 5de:	26 17       	cp	r18, r22
 5e0:	37 07       	cpc	r19, r23
 5e2:	a0 f0       	brcs	.+40     	; 0x60c <Endpoint_Write_Control_Stream_LE+0x36>
 5e4:	61 15       	cp	r22, r1
 5e6:	71 05       	cpc	r23, r1
 5e8:	29 f4       	brne	.+10     	; 0x5f4 <Endpoint_Write_Control_Stream_LE+0x1e>
 5ea:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 5ee:	2e 77       	andi	r18, 0x7E	; 126
 5f0:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 5f4:	30 e0       	ldi	r19, 0x00	; 0
 5f6:	61 15       	cp	r22, r1
 5f8:	71 05       	cpc	r23, r1
 5fa:	51 f4       	brne	.+20     	; 0x610 <Endpoint_Write_Control_Stream_LE+0x3a>
 5fc:	31 11       	cpse	r19, r1
 5fe:	08 c0       	rjmp	.+16     	; 0x610 <Endpoint_Write_Control_Stream_LE+0x3a>
 600:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 604:	82 ff       	sbrs	r24, 2
 606:	30 c0       	rjmp	.+96     	; 0x668 <Endpoint_Write_Control_Stream_LE+0x92>
 608:	80 e0       	ldi	r24, 0x00	; 0
 60a:	08 95       	ret
 60c:	b9 01       	movw	r22, r18
 60e:	f2 cf       	rjmp	.-28     	; 0x5f4 <Endpoint_Write_Control_Stream_LE+0x1e>
 610:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 614:	23 fd       	sbrc	r18, 3
 616:	30 c0       	rjmp	.+96     	; 0x678 <Endpoint_Write_Control_Stream_LE+0xa2>
 618:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 61c:	22 fd       	sbrc	r18, 2
 61e:	f0 cf       	rjmp	.-32     	; 0x600 <Endpoint_Write_Control_Stream_LE+0x2a>
 620:	2e b3       	in	r18, 0x1e	; 30
 622:	22 23       	and	r18, r18
 624:	59 f1       	breq	.+86     	; 0x67c <Endpoint_Write_Control_Stream_LE+0xa6>
 626:	2e b3       	in	r18, 0x1e	; 30
 628:	25 30       	cpi	r18, 0x05	; 5
 62a:	21 f1       	breq	.+72     	; 0x674 <Endpoint_Write_Control_Stream_LE+0x9e>
 62c:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 630:	20 ff       	sbrs	r18, 0
 632:	e1 cf       	rjmp	.-62     	; 0x5f6 <Endpoint_Write_Control_Stream_LE+0x20>
 634:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
 638:	fc 01       	movw	r30, r24
 63a:	cf 01       	movw	r24, r30
 63c:	61 15       	cp	r22, r1
 63e:	71 05       	cpc	r23, r1
 640:	11 f0       	breq	.+4      	; 0x646 <Endpoint_Write_Control_Stream_LE+0x70>
 642:	28 30       	cpi	r18, 0x08	; 8
 644:	50 f0       	brcs	.+20     	; 0x65a <Endpoint_Write_Control_Stream_LE+0x84>
 646:	31 e0       	ldi	r19, 0x01	; 1
 648:	28 30       	cpi	r18, 0x08	; 8
 64a:	09 f0       	breq	.+2      	; 0x64e <Endpoint_Write_Control_Stream_LE+0x78>
 64c:	30 e0       	ldi	r19, 0x00	; 0
 64e:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 652:	2e 77       	andi	r18, 0x7E	; 126
 654:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 658:	ce cf       	rjmp	.-100    	; 0x5f6 <Endpoint_Write_Control_Stream_LE+0x20>
 65a:	81 91       	ld	r24, Z+
 65c:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 660:	61 50       	subi	r22, 0x01	; 1
 662:	71 09       	sbc	r23, r1
 664:	2f 5f       	subi	r18, 0xFF	; 255
 666:	e9 cf       	rjmp	.-46     	; 0x63a <Endpoint_Write_Control_Stream_LE+0x64>
 668:	8e b3       	in	r24, 0x1e	; 30
 66a:	88 23       	and	r24, r24
 66c:	39 f0       	breq	.+14     	; 0x67c <Endpoint_Write_Control_Stream_LE+0xa6>
 66e:	8e b3       	in	r24, 0x1e	; 30
 670:	85 30       	cpi	r24, 0x05	; 5
 672:	31 f6       	brne	.-116    	; 0x600 <Endpoint_Write_Control_Stream_LE+0x2a>
 674:	83 e0       	ldi	r24, 0x03	; 3
 676:	08 95       	ret
 678:	81 e0       	ldi	r24, 0x01	; 1
 67a:	08 95       	ret
 67c:	82 e0       	ldi	r24, 0x02	; 2
 67e:	08 95       	ret

00000680 <Endpoint_Write_Control_PStream_LE>:
 680:	20 91 2d 02 	lds	r18, 0x022D	; 0x80022d <USB_ControlRequest+0x6>
 684:	30 91 2e 02 	lds	r19, 0x022E	; 0x80022e <USB_ControlRequest+0x7>
 688:	26 17       	cp	r18, r22
 68a:	37 07       	cpc	r19, r23
 68c:	a0 f0       	brcs	.+40     	; 0x6b6 <Endpoint_Write_Control_PStream_LE+0x36>
 68e:	61 15       	cp	r22, r1
 690:	71 05       	cpc	r23, r1
 692:	29 f4       	brne	.+10     	; 0x69e <Endpoint_Write_Control_PStream_LE+0x1e>
 694:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 698:	2e 77       	andi	r18, 0x7E	; 126
 69a:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 69e:	30 e0       	ldi	r19, 0x00	; 0
 6a0:	61 15       	cp	r22, r1
 6a2:	71 05       	cpc	r23, r1
 6a4:	51 f4       	brne	.+20     	; 0x6ba <Endpoint_Write_Control_PStream_LE+0x3a>
 6a6:	31 11       	cpse	r19, r1
 6a8:	08 c0       	rjmp	.+16     	; 0x6ba <Endpoint_Write_Control_PStream_LE+0x3a>
 6aa:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 6ae:	82 ff       	sbrs	r24, 2
 6b0:	31 c0       	rjmp	.+98     	; 0x714 <Endpoint_Write_Control_PStream_LE+0x94>
 6b2:	80 e0       	ldi	r24, 0x00	; 0
 6b4:	08 95       	ret
 6b6:	b9 01       	movw	r22, r18
 6b8:	f2 cf       	rjmp	.-28     	; 0x69e <Endpoint_Write_Control_PStream_LE+0x1e>
 6ba:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 6be:	23 fd       	sbrc	r18, 3
 6c0:	31 c0       	rjmp	.+98     	; 0x724 <Endpoint_Write_Control_PStream_LE+0xa4>
 6c2:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 6c6:	22 fd       	sbrc	r18, 2
 6c8:	f0 cf       	rjmp	.-32     	; 0x6aa <Endpoint_Write_Control_PStream_LE+0x2a>
 6ca:	2e b3       	in	r18, 0x1e	; 30
 6cc:	22 23       	and	r18, r18
 6ce:	61 f1       	breq	.+88     	; 0x728 <Endpoint_Write_Control_PStream_LE+0xa8>
 6d0:	2e b3       	in	r18, 0x1e	; 30
 6d2:	25 30       	cpi	r18, 0x05	; 5
 6d4:	29 f1       	breq	.+74     	; 0x720 <Endpoint_Write_Control_PStream_LE+0xa0>
 6d6:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 6da:	20 ff       	sbrs	r18, 0
 6dc:	e1 cf       	rjmp	.-62     	; 0x6a0 <Endpoint_Write_Control_PStream_LE+0x20>
 6de:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
 6e2:	fc 01       	movw	r30, r24
 6e4:	cf 01       	movw	r24, r30
 6e6:	61 15       	cp	r22, r1
 6e8:	71 05       	cpc	r23, r1
 6ea:	11 f0       	breq	.+4      	; 0x6f0 <Endpoint_Write_Control_PStream_LE+0x70>
 6ec:	28 30       	cpi	r18, 0x08	; 8
 6ee:	50 f0       	brcs	.+20     	; 0x704 <Endpoint_Write_Control_PStream_LE+0x84>
 6f0:	31 e0       	ldi	r19, 0x01	; 1
 6f2:	28 30       	cpi	r18, 0x08	; 8
 6f4:	09 f0       	breq	.+2      	; 0x6f8 <Endpoint_Write_Control_PStream_LE+0x78>
 6f6:	30 e0       	ldi	r19, 0x00	; 0
 6f8:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 6fc:	2e 77       	andi	r18, 0x7E	; 126
 6fe:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 702:	ce cf       	rjmp	.-100    	; 0x6a0 <Endpoint_Write_Control_PStream_LE+0x20>
 704:	84 91       	lpm	r24, Z
 706:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 70a:	61 50       	subi	r22, 0x01	; 1
 70c:	71 09       	sbc	r23, r1
 70e:	2f 5f       	subi	r18, 0xFF	; 255
 710:	31 96       	adiw	r30, 0x01	; 1
 712:	e8 cf       	rjmp	.-48     	; 0x6e4 <Endpoint_Write_Control_PStream_LE+0x64>
 714:	8e b3       	in	r24, 0x1e	; 30
 716:	88 23       	and	r24, r24
 718:	39 f0       	breq	.+14     	; 0x728 <Endpoint_Write_Control_PStream_LE+0xa8>
 71a:	8e b3       	in	r24, 0x1e	; 30
 71c:	85 30       	cpi	r24, 0x05	; 5
 71e:	29 f6       	brne	.-118    	; 0x6aa <Endpoint_Write_Control_PStream_LE+0x2a>
 720:	83 e0       	ldi	r24, 0x03	; 3
 722:	08 95       	ret
 724:	81 e0       	ldi	r24, 0x01	; 1
 726:	08 95       	ret
 728:	82 e0       	ldi	r24, 0x02	; 2
 72a:	08 95       	ret

0000072c <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	
	if (!(Length))
 72c:	61 15       	cp	r22, r1
 72e:	71 05       	cpc	r23, r1
 730:	29 f4       	brne	.+10     	; 0x73c <Endpoint_Read_Control_Stream_LE+0x10>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 732:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 736:	2b 77       	andi	r18, 0x7B	; 123
 738:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	  Endpoint_ClearOUT();
	
	while (Length)
 73c:	61 15       	cp	r22, r1
 73e:	71 05       	cpc	r23, r1
 740:	31 f4       	brne	.+12     	; 0x74e <Endpoint_Read_Control_Stream_LE+0x22>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
 742:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			
			Endpoint_ClearOUT();
		}		  
	}
	
	while (!(Endpoint_IsINReady()))
 746:	80 ff       	sbrs	r24, 0
 748:	20 c0       	rjmp	.+64     	; 0x78a <Endpoint_Read_Control_Stream_LE+0x5e>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}
	
	return ENDPOINT_RWCSTREAM_NoError;
 74a:	80 e0       	ldi	r24, 0x00	; 0
 74c:	08 95       	ret
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 74e:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	if (!(Length))
	  Endpoint_ClearOUT();
	
	while (Length)
	{
		if (Endpoint_IsSETUPReceived())
 752:	23 fd       	sbrc	r18, 3
 754:	22 c0       	rjmp	.+68     	; 0x79a <Endpoint_Read_Control_Stream_LE+0x6e>
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (USB_DeviceState == DEVICE_STATE_Unattached)
 756:	2e b3       	in	r18, 0x1e	; 30
 758:	22 23       	and	r18, r18
 75a:	09 f1       	breq	.+66     	; 0x79e <Endpoint_Read_Control_Stream_LE+0x72>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
 75c:	2e b3       	in	r18, 0x1e	; 30
 75e:	25 30       	cpi	r18, 0x05	; 5
 760:	d1 f0       	breq	.+52     	; 0x796 <Endpoint_Read_Control_Stream_LE+0x6a>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 762:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		  
		if (Endpoint_IsOUTReceived())
 766:	22 ff       	sbrs	r18, 2
 768:	e9 cf       	rjmp	.-46     	; 0x73c <Endpoint_Read_Control_Stream_LE+0x10>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
 76a:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
		{
			while (Length && Endpoint_BytesInEndpoint())
 76e:	22 23       	and	r18, r18
 770:	01 f3       	breq	.-64     	; 0x732 <Endpoint_Read_Control_Stream_LE+0x6>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
 772:	9c 01       	movw	r18, r24
 774:	2f 5f       	subi	r18, 0xFF	; 255
 776:	3f 4f       	sbci	r19, 0xFF	; 255
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 778:	40 91 f1 00 	lds	r20, 0x00F1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 77c:	fc 01       	movw	r30, r24
 77e:	40 83       	st	Z, r20
				Length--;
 780:	61 50       	subi	r22, 0x01	; 1
 782:	71 09       	sbc	r23, r1
		  
		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
 784:	c9 01       	movw	r24, r18
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		  
		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
 786:	89 f7       	brne	.-30     	; 0x76a <Endpoint_Read_Control_Stream_LE+0x3e>
 788:	d4 cf       	rjmp	.-88     	; 0x732 <Endpoint_Read_Control_Stream_LE+0x6>
		}		  
	}
	
	while (!(Endpoint_IsINReady()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
 78a:	8e b3       	in	r24, 0x1e	; 30
 78c:	88 23       	and	r24, r24
 78e:	39 f0       	breq	.+14     	; 0x79e <Endpoint_Read_Control_Stream_LE+0x72>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
 790:	8e b3       	in	r24, 0x1e	; 30
 792:	85 30       	cpi	r24, 0x05	; 5
 794:	b1 f6       	brne	.-84     	; 0x742 <Endpoint_Read_Control_Stream_LE+0x16>
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
 796:	83 e0       	ldi	r24, 0x03	; 3
		else if (USB_DeviceState == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}
	
	return ENDPOINT_RWCSTREAM_NoError;
}
 798:	08 95       	ret
	  Endpoint_ClearOUT();
	
	while (Length)
	{
		if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
 79a:	81 e0       	ldi	r24, 0x01	; 1
 79c:	08 95       	ret

		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
 79e:	82 e0       	ldi	r24, 0x02	; 2
 7a0:	08 95       	ret

000007a2 <USB_ResetInterface>:
	#endif
}

void USB_ResetInterface(void)
{
	USB_INT_DisableAllInterrupts();
 7a2:	42 d0       	rcall	.+132    	; 0x828 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
 7a4:	44 d0       	rcall	.+136    	; 0x82e <USB_INT_ClearAllInterrupts>
 7a6:	1e ba       	out	0x1e, r1	; 30
	#if defined(USB_CAN_BE_HOST)
	USB_HostState   = HOST_STATE_Unattached;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	USB_DeviceState = DEVICE_STATE_Unattached;
 7a8:	10 92 25 02 	sts	0x0225, r1	; 0x800225 <USB_ConfigurationNumber>
	USB_ConfigurationNumber  = 0;
 7ac:	10 92 24 02 	sts	0x0224, r1	; 0x800224 <USB_RemoteWakeupEnabled>

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_RemoteWakeupEnabled  = false;
 7b0:	10 92 23 02 	sts	0x0223, r1	; 0x800223 <USB_CurrentlySelfPowered>
	#endif
	
	#if !defined(NO_DEVICE_SELF_POWER)
	USB_CurrentlySelfPowered = false;
 7b4:	84 e0       	ldi	r24, 0x04	; 4
	#if !defined(__DOXYGEN__)
		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
 7b6:	89 bd       	out	0x29, r24	; 41
 7b8:	89 b5       	in	r24, 0x29	; 41
				PLLCSR |= (1 << PLLE);
 7ba:	82 60       	ori	r24, 0x02	; 2
 7bc:	89 bd       	out	0x29, r24	; 41
 7be:	09 b4       	in	r0, 0x29	; 41
		#if defined(USB_SERIES_4_AVR)
		PLLFRQ = ((1 << PLLUSB) | (1 << PDIV3) | (1 << PDIV1));
		#endif

		USB_PLL_On();
		while (!(USB_PLL_IsReady()));
 7c0:	00 fe       	sbrs	r0, 0
 7c2:	fd cf       	rjmp	.-6      	; 0x7be <USB_ResetInterface+0x1c>
 7c4:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				const uint8_t Temp = USBCON;
 7c8:	98 2f       	mov	r25, r24
				
				USBCON = (Temp & ~(1 << USBE));
 7ca:	9f 77       	andi	r25, 0x7F	; 127
 7cc:	90 93 d8 00 	sts	0x00D8, r25	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 7d0:	80 68       	ori	r24, 0x80	; 128
				USBCON = (Temp |  (1 << USBE));
 7d2:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 7d6:	80 91 63 00 	lds	r24, 0x0063	; 0x800063 <__EEPROM_REGION_LENGTH__+0x7f0063>
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON  |=  (1 << UVREGE);
			#else
				REGCR   &= ~(1 << REGDIS);
 7da:	8e 7f       	andi	r24, 0xFE	; 254
 7dc:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <__EEPROM_REGION_LENGTH__+0x7f0063>
 7e0:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
			}
			
			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
 7e4:	8f 7d       	andi	r24, 0xDF	; 223
 7e6:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 7ea:	80 91 e0 00 	lds	r24, 0x00E0	; 0x8000e0 <__EEPROM_REGION_LENGTH__+0x7f00e0>
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
 7ee:	8e 7f       	andi	r24, 0xFE	; 254
 7f0:	80 93 e0 00 	sts	0x00E0, r24	; 0x8000e0 <__EEPROM_REGION_LENGTH__+0x7f00e0>
 7f4:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
	#endif

	USB_Attach();
	
	#if defined(USB_DEVICE_ONLY)
	USB_INT_Clear(USB_INT_SUSPEND);
 7f8:	8e 7f       	andi	r24, 0xFE	; 254
 7fa:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 7fe:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
	USB_INT_Enable(USB_INT_SUSPEND);
 802:	81 60       	ori	r24, 0x01	; 1
 804:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 808:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
	USB_INT_Clear(USB_INT_EORSTI);
 80c:	87 7f       	andi	r24, 0xF7	; 247
 80e:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 812:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
	USB_INT_Enable(USB_INT_EORSTI);
 816:	88 60       	ori	r24, 0x08	; 8
 818:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 81c:	08 95       	ret

0000081e <USB_Init>:
		
		USB_INT_Enable(USB_INT_SRPI);
		USB_INT_Enable(USB_INT_BCERRI);
	}
	#endif
}
 81e:	c1 df       	rcall	.-126    	; 0x7a2 <USB_ResetInterface>

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_On();
	#endif

	USB_IsInitialized = true;
 820:	81 e0       	ldi	r24, 0x01	; 1
 822:	80 93 26 02 	sts	0x0226, r24	; 0x800226 <USB_IsInitialized>
}
 826:	08 95       	ret

00000828 <USB_INT_DisableAllInterrupts>:
	UHIEN   = 0;
	OTGIEN  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
 828:	10 92 e2 00 	sts	0x00E2, r1	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
	#endif
}
 82c:	08 95       	ret

0000082e <USB_INT_ClearAllInterrupts>:
	UHINT   = 0;
	OTGINT  = 0;
	#endif
	
	#if defined(USB_CAN_BE_DEVICE)
	UDINT   = 0;
 82e:	10 92 e1 00 	sts	0x00E1, r1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
	#endif
}
 832:	08 95       	ret

00000834 <__vector_11>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
 834:	1f 92       	push	r1
 836:	0f 92       	push	r0
 838:	0f b6       	in	r0, 0x3f	; 63
 83a:	0f 92       	push	r0
 83c:	11 24       	eor	r1, r1
 83e:	2f 93       	push	r18
 840:	3f 93       	push	r19
 842:	4f 93       	push	r20
 844:	5f 93       	push	r21
 846:	6f 93       	push	r22
 848:	7f 93       	push	r23
 84a:	8f 93       	push	r24
 84c:	9f 93       	push	r25
 84e:	af 93       	push	r26
 850:	bf 93       	push	r27
 852:	ef 93       	push	r30
 854:	ff 93       	push	r31
			EVENT_USB_Device_Disconnect();
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPEND) && USB_INT_IsEnabled(USB_INT_SUSPEND))
 856:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 85a:	80 ff       	sbrs	r24, 0
 85c:	1b c0       	rjmp	.+54     	; 0x894 <__vector_11+0x60>
 85e:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 862:	80 ff       	sbrs	r24, 0
 864:	17 c0       	rjmp	.+46     	; 0x894 <__vector_11+0x60>
	{
		USB_INT_Clear(USB_INT_SUSPEND);
 866:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 86a:	8e 7f       	andi	r24, 0xFE	; 254
 86c:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>

		USB_INT_Disable(USB_INT_SUSPEND);
 870:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 874:	8e 7f       	andi	r24, 0xFE	; 254
 876:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
		USB_INT_Enable(USB_INT_WAKEUP);
 87a:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 87e:	80 61       	ori	r24, 0x10	; 16
 880:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON  |=  (1 << FRZCLK);
 884:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 888:	80 62       	ori	r24, 0x20	; 32
 88a:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
			}
			
			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR  = 0;
 88e:	19 bc       	out	0x29, r1	; 41
		
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		  USB_PLL_Off();

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
 890:	1e ba       	out	0x1e, r1	; 30
		EVENT_USB_Device_Disconnect();
 892:	f7 d1       	rcall	.+1006   	; 0xc82 <USB_Event_Stub>
		USB_DeviceState = DEVICE_STATE_Suspended;
		EVENT_USB_Device_Suspend();
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUP) && USB_INT_IsEnabled(USB_INT_WAKEUP))
 894:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 898:	84 ff       	sbrs	r24, 4
 89a:	27 c0       	rjmp	.+78     	; 0x8ea <__vector_11+0xb6>
 89c:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 8a0:	84 ff       	sbrs	r24, 4
 8a2:	23 c0       	rjmp	.+70     	; 0x8ea <__vector_11+0xb6>
	#if !defined(__DOXYGEN__)
		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR  = USB_PLL_PSC;
 8a4:	84 e0       	ldi	r24, 0x04	; 4
 8a6:	89 bd       	out	0x29, r24	; 41
				PLLCSR |= (1 << PLLE);
 8a8:	89 b5       	in	r24, 0x29	; 41
 8aa:	82 60       	ori	r24, 0x02	; 2
 8ac:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
 8ae:	09 b4       	in	r0, 0x29	; 41
 8b0:	00 fe       	sbrs	r0, 0
 8b2:	fd cf       	rjmp	.-6      	; 0x8ae <__vector_11+0x7a>
			}
			
			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON  &= ~(1 << FRZCLK);
 8b4:	80 91 d8 00 	lds	r24, 0x00D8	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
 8b8:	8f 7d       	andi	r24, 0xDF	; 223
 8ba:	80 93 d8 00 	sts	0x00D8, r24	; 0x8000d8 <__EEPROM_REGION_LENGTH__+0x7f00d8>
		}

		USB_CLK_Unfreeze();

		USB_INT_Clear(USB_INT_WAKEUP);
 8be:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 8c2:	8f 7e       	andi	r24, 0xEF	; 239
 8c4:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>

		USB_INT_Disable(USB_INT_WAKEUP);
 8c8:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 8cc:	8f 7e       	andi	r24, 0xEF	; 239
 8ce:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
		USB_INT_Enable(USB_INT_SUSPEND);
 8d2:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 8d6:	81 60       	ori	r24, 0x01	; 1
 8d8:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
		
		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
 8dc:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <USB_ConfigurationNumber>
 8e0:	81 11       	cpse	r24, r1
 8e2:	4d c0       	rjmp	.+154    	; 0x97e <__vector_11+0x14a>
 8e4:	81 e0       	ldi	r24, 0x01	; 1
		EVENT_USB_Device_Connect();
 8e6:	8e bb       	out	0x1e, r24	; 30
 8e8:	cc d1       	rcall	.+920    	; 0xc82 <USB_Event_Stub>
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
		EVENT_USB_Device_WakeUp();		
		#endif
	}
   
	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
 8ea:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 8ee:	83 ff       	sbrs	r24, 3
 8f0:	27 c0       	rjmp	.+78     	; 0x940 <__vector_11+0x10c>
 8f2:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 8f6:	83 ff       	sbrs	r24, 3
 8f8:	23 c0       	rjmp	.+70     	; 0x940 <__vector_11+0x10c>
	{
		USB_INT_Clear(USB_INT_EORSTI);
 8fa:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 8fe:	87 7f       	andi	r24, 0xF7	; 247
 900:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>

		USB_DeviceState         = DEVICE_STATE_Default;
 904:	82 e0       	ldi	r24, 0x02	; 2
 906:	8e bb       	out	0x1e, r24	; 30
		USB_ConfigurationNumber = 0;
 908:	10 92 25 02 	sts	0x0225, r1	; 0x800225 <USB_ConfigurationNumber>

		USB_INT_Clear(USB_INT_SUSPEND);
 90c:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 910:	8e 7f       	andi	r24, 0xFE	; 254
 912:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
		USB_INT_Disable(USB_INT_SUSPEND);
 916:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 91a:	8e 7f       	andi	r24, 0xFE	; 254
 91c:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
		USB_INT_Enable(USB_INT_WAKEUP);
 920:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 924:	80 61       	ori	r24, 0x10	; 16
 926:	80 93 e2 00 	sts	0x00E2, r24	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>

		Endpoint_ClearEndpoints();
 92a:	f8 dd       	rcall	.-1040   	; 0x51c <Endpoint_ClearEndpoints>
			                                                    const uint8_t Type,
			                                                    const uint8_t Direction,
			                                                    const uint16_t Size,
			                                                    const uint8_t Banks)
			{
				return Endpoint_ConfigureEndpoint_Prv(Number, (((Type) << EPTYPE0) | (Direction)),
 92c:	42 e0       	ldi	r20, 0x02	; 2
 92e:	60 e0       	ldi	r22, 0x00	; 0
 930:	80 e0       	ldi	r24, 0x00	; 0
 932:	e1 dd       	rcall	.-1086   	; 0x4f6 <Endpoint_ConfigureEndpoint_Prv>
		Endpoint_ConfigureEndpoint(ENDPOINT_CONTROLEP, EP_TYPE_CONTROL,
		                           ENDPOINT_DIR_OUT, USB_ControlEndpointSize,
		                           ENDPOINT_BANK_SINGLE);

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
 934:	80 91 f0 00 	lds	r24, 0x00F0	; 0x8000f0 <__EEPROM_REGION_LENGTH__+0x7f00f0>
 938:	88 60       	ori	r24, 0x08	; 8
 93a:	80 93 f0 00 	sts	0x00F0, r24	; 0x8000f0 <__EEPROM_REGION_LENGTH__+0x7f00f0>
		#endif

		EVENT_USB_Device_Reset();
 93e:	a1 d1       	rcall	.+834    	; 0xc82 <USB_Event_Stub>
	}
	
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
 940:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 944:	82 ff       	sbrs	r24, 2
 946:	0a c0       	rjmp	.+20     	; 0x95c <__vector_11+0x128>
 948:	80 91 e2 00 	lds	r24, 0x00E2	; 0x8000e2 <__EEPROM_REGION_LENGTH__+0x7f00e2>
 94c:	82 ff       	sbrs	r24, 2
 94e:	06 c0       	rjmp	.+12     	; 0x95c <__vector_11+0x128>
	{
		USB_INT_Clear(USB_INT_SOFI);
 950:	80 91 e1 00 	lds	r24, 0x00E1	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
 954:	8b 7f       	andi	r24, 0xFB	; 251
 956:	80 93 e1 00 	sts	0x00E1, r24	; 0x8000e1 <__EEPROM_REGION_LENGTH__+0x7f00e1>
		
		EVENT_USB_Device_StartOfFrame();
 95a:	93 d1       	rcall	.+806    	; 0xc82 <USB_Event_Stub>
		EVENT_USB_UIDChange();

		USB_ResetInterface();
	}
	#endif
}
 95c:	ff 91       	pop	r31
 95e:	ef 91       	pop	r30
 960:	bf 91       	pop	r27
 962:	af 91       	pop	r26
 964:	9f 91       	pop	r25
 966:	8f 91       	pop	r24
 968:	7f 91       	pop	r23
 96a:	6f 91       	pop	r22
 96c:	5f 91       	pop	r21
 96e:	4f 91       	pop	r20
 970:	3f 91       	pop	r19
 972:	2f 91       	pop	r18
 974:	0f 90       	pop	r0
 976:	0f be       	out	0x3f, r0	; 63
 978:	0f 90       	pop	r0
 97a:	1f 90       	pop	r1
 97c:	18 95       	reti

		USB_INT_Disable(USB_INT_WAKEUP);
		USB_INT_Enable(USB_INT_SUSPEND);
		
		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
 97e:	84 e0       	ldi	r24, 0x04	; 4
 980:	b2 cf       	rjmp	.-156    	; 0x8e6 <__vector_11+0xb2>

00000982 <__vector_12>:
	#endif
}

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
 982:	1f 92       	push	r1
 984:	0f 92       	push	r0
 986:	0f b6       	in	r0, 0x3f	; 63
 988:	0f 92       	push	r0
 98a:	11 24       	eor	r1, r1
 98c:	ff 92       	push	r15
 98e:	0f 93       	push	r16
 990:	1f 93       	push	r17
 992:	2f 93       	push	r18
 994:	3f 93       	push	r19
 996:	4f 93       	push	r20
 998:	5f 93       	push	r21
 99a:	6f 93       	push	r22
 99c:	7f 93       	push	r23
 99e:	8f 93       	push	r24
 9a0:	9f 93       	push	r25
 9a2:	af 93       	push	r26
 9a4:	bf 93       	push	r27
 9a6:	cf 93       	push	r28
 9a8:	df 93       	push	r29
 9aa:	ef 93       	push	r30
 9ac:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
 9ae:	c9 ee       	ldi	r28, 0xE9	; 233
 9b0:	d0 e0       	ldi	r29, 0x00	; 0
 9b2:	88 81       	ld	r24, Y
 9b4:	87 70       	andi	r24, 0x07	; 7
 9b6:	f8 2e       	mov	r15, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 9b8:	18 82       	st	Y, r1
	uint8_t PrevSelectedEndpoint = Endpoint_GetCurrentEndpoint(); 

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);
 9ba:	00 ef       	ldi	r16, 0xF0	; 240
 9bc:	10 e0       	ldi	r17, 0x00	; 0
 9be:	f8 01       	movw	r30, r16
 9c0:	80 81       	ld	r24, Z
 9c2:	87 7f       	andi	r24, 0xF7	; 247
 9c4:	80 83       	st	Z, r24

#if !defined(__DOXYGEN__)
/* Internal helper functions. */
static __inline__ uint8_t __iSeiRetVal(void)
{
    sei();
 9c6:	78 94       	sei

	NONATOMIC_BLOCK(NONATOMIC_FORCEOFF)
	{
		USB_Device_ProcessControlRequest();
 9c8:	1d d0       	rcall	.+58     	; 0xa04 <USB_Device_ProcessControlRequest>
    (void)__s;
}

static __inline__ void __iCliParam(const uint8_t *__s)
{
    cli();
 9ca:	f8 94       	cli
 9cc:	18 82       	st	Y, r1
	}

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
 9ce:	f8 01       	movw	r30, r16
 9d0:	80 81       	ld	r24, Z
 9d2:	88 60       	ori	r24, 0x08	; 8
 9d4:	80 83       	st	Z, r24
 9d6:	f8 82       	st	Y, r15
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
 9d8:	ff 91       	pop	r31
 9da:	ef 91       	pop	r30
 9dc:	df 91       	pop	r29
 9de:	cf 91       	pop	r28
 9e0:	bf 91       	pop	r27
 9e2:	af 91       	pop	r26
 9e4:	9f 91       	pop	r25
 9e6:	8f 91       	pop	r24
 9e8:	7f 91       	pop	r23
 9ea:	6f 91       	pop	r22
 9ec:	5f 91       	pop	r21
 9ee:	4f 91       	pop	r20
 9f0:	3f 91       	pop	r19
 9f2:	2f 91       	pop	r18
 9f4:	1f 91       	pop	r17
 9f6:	0f 91       	pop	r16
 9f8:	ff 90       	pop	r15
 9fa:	0f 90       	pop	r0
 9fc:	0f be       	out	0x3f, r0	; 63
 9fe:	0f 90       	pop	r0
 a00:	1f 90       	pop	r1
 a02:	18 95       	reti

00000a04 <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
 a04:	1f 93       	push	r17
 a06:	cf 93       	push	r28
 a08:	df 93       	push	r29
 a0a:	cd b7       	in	r28, 0x3d	; 61
 a0c:	de b7       	in	r29, 0x3e	; 62
 a0e:	aa 97       	sbiw	r28, 0x2a	; 42
 a10:	0f b6       	in	r0, 0x3f	; 63
 a12:	f8 94       	cli
 a14:	de bf       	out	0x3e, r29	; 62
 a16:	0f be       	out	0x3f, r0	; 63
 a18:	cd bf       	out	0x3d, r28	; 61
 a1a:	e7 e2       	ldi	r30, 0x27	; 39
 a1c:	f2 e0       	ldi	r31, 0x02	; 2
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 a1e:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_Byte();
 a22:	81 93       	st	Z+, r24
void USB_Device_ProcessControlRequest(void)
{
	bool     RequestHandled = false;
	uint8_t* RequestHeader  = (uint8_t*)&USB_ControlRequest;
	
	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
 a24:	22 e0       	ldi	r18, 0x02	; 2
 a26:	ef 32       	cpi	r30, 0x2F	; 47
 a28:	f2 07       	cpc	r31, r18
 a2a:	c9 f7       	brne	.-14     	; 0xa1e <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_Byte();
	  
	uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
 a2c:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <USB_ControlRequest>
	
	switch (USB_ControlRequest.bRequest)
 a30:	90 91 28 02 	lds	r25, 0x0228	; 0x800228 <USB_ControlRequest+0x1>
 a34:	9a 30       	cpi	r25, 0x0A	; 10
 a36:	08 f0       	brcs	.+2      	; 0xa3a <USB_Device_ProcessControlRequest+0x36>
 a38:	22 c1       	rjmp	.+580    	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
 a3a:	e9 2f       	mov	r30, r25
 a3c:	f0 e0       	ldi	r31, 0x00	; 0
 a3e:	ee 5d       	subi	r30, 0xDE	; 222
 a40:	fa 4f       	sbci	r31, 0xFA	; 250
 a42:	88 c2       	rjmp	.+1296   	; 0xf54 <__tablejump2__>
 a44:	2c 05       	cpc	r18, r12
 a46:	51 05       	cpc	r21, r1
 a48:	3f 06       	cpc	r3, r31
 a4a:	51 05       	cpc	r21, r1
 a4c:	3f 06       	cpc	r3, r31
 a4e:	ac 05       	cpc	r26, r12
 a50:	c8 05       	cpc	r28, r8
 a52:	3f 06       	cpc	r3, r31
 a54:	1a 06       	cpc	r1, r26
 a56:	26 06       	cpc	r2, r22
	{
		case REQ_GetStatus:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 a58:	80 38       	cpi	r24, 0x80	; 128
 a5a:	81 f0       	breq	.+32     	; 0xa7c <USB_Device_ProcessControlRequest+0x78>
 a5c:	82 38       	cpi	r24, 0x82	; 130
 a5e:	09 f0       	breq	.+2      	; 0xa62 <USB_Device_ProcessControlRequest+0x5e>
 a60:	0e c1       	rjmp	.+540    	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
	#endif
			break;
#endif
#if !defined(CONTROL_ONLY_DEVICE)
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
 a62:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <USB_ControlRequest+0x4>
 a66:	87 70       	andi	r24, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 a68:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 *  \return Boolean true if the currently selected endpoint is stalled, false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
 a6c:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 a70:	85 fb       	bst	r24, 5
 a72:	88 27       	eor	r24, r24
 a74:	80 f9       	bld	r24, 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 a76:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 a7a:	06 c0       	rjmp	.+12     	; 0xa88 <USB_Device_ProcessControlRequest+0x84>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
 a7c:	80 91 23 02 	lds	r24, 0x0223	; 0x800223 <USB_CurrentlySelfPowered>
			if (USB_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
	#endif

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)			
			if (USB_RemoteWakeupEnabled)
 a80:	90 91 24 02 	lds	r25, 0x0224	; 0x800224 <USB_RemoteWakeupEnabled>
 a84:	91 11       	cpse	r25, r1
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
 a86:	82 60       	ori	r24, 0x02	; 2
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 a88:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 a8c:	97 7f       	andi	r25, 0xF7	; 247
 a8e:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
			 *  \param[in] Word  Next word to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Word_LE(const uint16_t Word) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Word_LE(const uint16_t Word)
			{
				UEDATX = (Word & 0xFF);
 a92:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
				UEDATX = (Word >> 8);
 a96:	10 92 f1 00 	sts	0x00F1, r1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 a9a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 a9e:	8e 77       	andi	r24, 0x7E	; 126
 aa0:	2e c0       	rjmp	.+92     	; 0xafe <USB_Device_ProcessControlRequest+0xfa>
			}

			break;
		case REQ_ClearFeature:
		case REQ_SetFeature:
			if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 aa2:	28 2f       	mov	r18, r24
 aa4:	2d 7f       	andi	r18, 0xFD	; 253
 aa6:	09 f0       	breq	.+2      	; 0xaaa <USB_Device_ProcessControlRequest+0xa6>
 aa8:	ea c0       	rjmp	.+468    	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
 aaa:	88 23       	and	r24, r24
 aac:	d1 f0       	breq	.+52     	; 0xae2 <USB_Device_ProcessControlRequest+0xde>
 aae:	82 30       	cpi	r24, 0x02	; 2
 ab0:	51 f1       	breq	.+84     	; 0xb06 <USB_Device_ProcessControlRequest+0x102>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 ab2:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	}

	if (!(RequestHandled))
	  EVENT_USB_Device_UnhandledControlRequest();
	  
	if (Endpoint_IsSETUPReceived())
 ab6:	83 ff       	sbrs	r24, 3
 ab8:	0a c0       	rjmp	.+20     	; 0xace <USB_Device_ProcessControlRequest+0xca>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
 aba:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 abe:	80 62       	ori	r24, 0x20	; 32
 ac0:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 ac4:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 ac8:	87 7f       	andi	r24, 0xF7	; 247
 aca:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();		
	}
}
 ace:	aa 96       	adiw	r28, 0x2a	; 42
 ad0:	0f b6       	in	r0, 0x3f	; 63
 ad2:	f8 94       	cli
 ad4:	de bf       	out	0x3e, r29	; 62
 ad6:	0f be       	out	0x3f, r0	; 63
 ad8:	cd bf       	out	0x3d, r28	; 61
 ada:	df 91       	pop	r29
 adc:	cf 91       	pop	r28
 ade:	1f 91       	pop	r17
 ae0:	08 95       	ret
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
	{
#if !defined(NO_DEVICE_REMOTE_WAKEUP)			
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_REMOTE_WAKEUP)
 ae2:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
 ae6:	81 30       	cpi	r24, 0x01	; 1
 ae8:	21 f7       	brne	.-56     	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
			  USB_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
 aea:	93 30       	cpi	r25, 0x03	; 3
 aec:	09 f0       	breq	.+2      	; 0xaf0 <USB_Device_ProcessControlRequest+0xec>
 aee:	80 e0       	ldi	r24, 0x00	; 0
 af0:	80 93 24 02 	sts	0x0224, r24	; 0x800224 <USB_RemoteWakeupEnabled>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 af4:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 af8:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 afc:	87 7f       	andi	r24, 0xF7	; 247
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
 afe:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
 b02:	20 dd       	rcall	.-1472   	; 0x544 <Endpoint_ClearStatusStage>
 b04:	d6 cf       	rjmp	.-84     	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
			
			break;			
#endif
#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_ENDPOINT_HALT)
 b06:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
 b0a:	81 11       	cpse	r24, r1
 b0c:	f3 cf       	rjmp	.-26     	; 0xaf4 <USB_Device_ProcessControlRequest+0xf0>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
 b0e:	80 91 2b 02 	lds	r24, 0x022B	; 0x80022b <USB_ControlRequest+0x4>
 b12:	87 70       	andi	r24, 0x07	; 7
				
				if (EndpointIndex == ENDPOINT_CONTROLEP)
 b14:	71 f2       	breq	.-100    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 b16:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 * \return Boolean True if the currently selected endpoint is enabled, false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
 b1a:	20 91 eb 00 	lds	r18, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (!(Endpoint_IsEnabled()))
 b1e:	20 ff       	sbrs	r18, 0
 b20:	c8 cf       	rjmp	.-112    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
				  return;

				if (USB_ControlRequest.bRequest == REQ_SetFeature)
 b22:	93 30       	cpi	r25, 0x03	; 3
 b24:	31 f4       	brne	.+12     	; 0xb32 <USB_Device_ProcessControlRequest+0x12e>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
 b26:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 b2a:	80 62       	ori	r24, 0x20	; 32
			
			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
 b2c:	80 93 eb 00 	sts	0x00EB, r24	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 b30:	e1 cf       	rjmp	.-62     	; 0xaf4 <USB_Device_ProcessControlRequest+0xf0>
			 *  \ingroup Group_EndpointPacketManagement
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
 b32:	90 91 eb 00 	lds	r25, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 b36:	90 61       	ori	r25, 0x10	; 16
 b38:	90 93 eb 00 	sts	0x00EB, r25	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
			 *  \param[in] EndpointNumber Endpoint number whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetFIFO(const uint8_t EndpointNumber)
			{
				UERST = (1 << EndpointNumber);
 b3c:	21 e0       	ldi	r18, 0x01	; 1
 b3e:	30 e0       	ldi	r19, 0x00	; 0
 b40:	01 c0       	rjmp	.+2      	; 0xb44 <USB_Device_ProcessControlRequest+0x140>
 b42:	22 0f       	add	r18, r18
 b44:	8a 95       	dec	r24
 b46:	ea f7       	brpl	.-6      	; 0xb42 <USB_Device_ProcessControlRequest+0x13e>
 b48:	20 93 ea 00 	sts	0x00EA, r18	; 0x8000ea <__EEPROM_REGION_LENGTH__+0x7f00ea>
				UERST = 0;
 b4c:	10 92 ea 00 	sts	0x00EA, r1	; 0x8000ea <__EEPROM_REGION_LENGTH__+0x7f00ea>
			
			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
 b50:	80 91 eb 00 	lds	r24, 0x00EB	; 0x8000eb <__EEPROM_REGION_LENGTH__+0x7f00eb>
 b54:	88 60       	ori	r24, 0x08	; 8
 b56:	ea cf       	rjmp	.-44     	; 0xb2c <USB_Device_ProcessControlRequest+0x128>
				RequestHandled = true;
			}

			break;
		case REQ_SetAddress:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 b58:	81 11       	cpse	r24, r1
 b5a:	91 c0       	rjmp	.+290    	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
 b5c:	10 91 29 02 	lds	r17, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 b60:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 b64:	87 7f       	andi	r24, 0xF7	; 247
 b66:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

	Endpoint_ClearSETUP();
	
	Endpoint_ClearStatusStage();
 b6a:	ec dc       	rcall	.-1576   	; 0x544 <Endpoint_ClearStatusStage>
			 *  \return Boolean true if the current endpoint is ready for an IN packet, false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI))  ? true : false);
 b6c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	
	while (!(Endpoint_IsINReady()))
 b70:	80 ff       	sbrs	r24, 0
 b72:	0a c0       	rjmp	.+20     	; 0xb88 <USB_Device_ProcessControlRequest+0x184>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
 b74:	81 2f       	mov	r24, r17
 b76:	8f 77       	andi	r24, 0x7F	; 127
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
		  return;
	}

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
 b78:	92 e0       	ldi	r25, 0x02	; 2
 b7a:	09 f0       	breq	.+2      	; 0xb7e <USB_Device_ProcessControlRequest+0x17a>
 b7c:	93 e0       	ldi	r25, 0x03	; 3
 b7e:	9e bb       	out	0x1e, r25	; 30
			#endif
			
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = ((1 << ADDEN) | (Address & 0x7F));
 b80:	80 68       	ori	r24, 0x80	; 128
 b82:	80 93 e3 00 	sts	0x00E3, r24	; 0x8000e3 <__EEPROM_REGION_LENGTH__+0x7f00e3>
 b86:	95 cf       	rjmp	.-214    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
	
	Endpoint_ClearStatusStage();
	
	while (!(Endpoint_IsINReady()))
	{
		if (USB_DeviceState == DEVICE_STATE_Unattached)
 b88:	8e b3       	in	r24, 0x1e	; 30
 b8a:	81 11       	cpse	r24, r1
 b8c:	ef cf       	rjmp	.-34     	; 0xb6c <USB_Device_ProcessControlRequest+0x168>
 b8e:	91 cf       	rjmp	.-222    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
				RequestHandled = true;
			}

			break;
		case REQ_GetDescriptor:
			if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
 b90:	80 58       	subi	r24, 0x80	; 128
 b92:	82 30       	cpi	r24, 0x02	; 2
 b94:	08 f0       	brcs	.+2      	; 0xb98 <USB_Device_ProcessControlRequest+0x194>
 b96:	73 c0       	rjmp	.+230    	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
	#if !defined(USE_FLASH_DESCRIPTORS) && !defined(USE_EEPROM_DESCRIPTORS) && !defined(USE_RAM_DESCRIPTORS)
	uint8_t  DescriptorAddressSpace;
	#endif
	
	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
 b98:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
 b9c:	90 91 2a 02 	lds	r25, 0x022A	; 0x80022a <USB_ControlRequest+0x3>
 ba0:	8c 3d       	cpi	r24, 0xDC	; 220
 ba2:	23 e0       	ldi	r18, 0x03	; 3
 ba4:	92 07       	cpc	r25, r18
 ba6:	99 f5       	brne	.+102    	; 0xc0e <USB_Device_ProcessControlRequest+0x20a>
	{
		USB_Descriptor_Header_t Header;
		int16_t                 UnicodeString[20];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
 ba8:	83 e0       	ldi	r24, 0x03	; 3
 baa:	8a 83       	std	Y+2, r24	; 0x02
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);
 bac:	8a e2       	ldi	r24, 0x2A	; 42
 bae:	89 83       	std	Y+1, r24	; 0x01
	
	uint8_t SigReadAddress = 0x0E;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
 bb0:	4f b7       	in	r20, 0x3f	; 63
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
 bb2:	f8 94       	cli
 bb4:	de 01       	movw	r26, r28
 bb6:	13 96       	adiw	r26, 0x03	; 3
	{
		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
 bb8:	20 e0       	ldi	r18, 0x00	; 0
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
	SignatureDescriptor.Header.Size = sizeof(SignatureDescriptor);
	
	uint8_t SigReadAddress = 0x0E;
 bba:	3e e0       	ldi	r19, 0x0E	; 14

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
		{
			uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
 bbc:	51 e2       	ldi	r21, 0x21	; 33
 bbe:	e3 2f       	mov	r30, r19
 bc0:	f0 e0       	ldi	r31, 0x00	; 0
 bc2:	50 93 57 00 	sts	0x0057, r21	; 0x800057 <__EEPROM_REGION_LENGTH__+0x7f0057>
 bc6:	e4 91       	lpm	r30, Z
			
			if (SerialCharNum & 0x01)
 bc8:	20 ff       	sbrs	r18, 0
 bca:	03 c0       	rjmp	.+6      	; 0xbd2 <USB_Device_ProcessControlRequest+0x1ce>
			{
				SerialByte >>= 4;
 bcc:	e2 95       	swap	r30
 bce:	ef 70       	andi	r30, 0x0F	; 15
				SigReadAddress++;
 bd0:	3f 5f       	subi	r19, 0xFF	; 255
}

#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
static char USB_Device_NibbleToASCII(uint8_t Nibble)
{
	Nibble = ((Nibble & 0x0F) + '0');
 bd2:	ef 70       	andi	r30, 0x0F	; 15
 bd4:	80 e3       	ldi	r24, 0x30	; 48
 bd6:	8e 0f       	add	r24, r30
	return (Nibble > '9') ? (Nibble + ('A' - '9' - 1)) : Nibble;
 bd8:	8a 33       	cpi	r24, 0x3A	; 58
 bda:	10 f0       	brcs	.+4      	; 0xbe0 <USB_Device_ProcessControlRequest+0x1dc>
 bdc:	87 e3       	ldi	r24, 0x37	; 55
 bde:	8e 0f       	add	r24, r30
			{
				SerialByte >>= 4;
				SigReadAddress++;
			}
			
			SignatureDescriptor.UnicodeString[SerialCharNum] = USB_Device_NibbleToASCII(SerialByte);
 be0:	90 e0       	ldi	r25, 0x00	; 0
 be2:	8d 93       	st	X+, r24
 be4:	9d 93       	st	X+, r25
	
	uint8_t SigReadAddress = 0x0E;

	ATOMIC_BLOCK(ATOMIC_RESTORESTATE)
	{
		for (uint8_t SerialCharNum = 0; SerialCharNum < 20; SerialCharNum++)
 be6:	2f 5f       	subi	r18, 0xFF	; 255
 be8:	24 31       	cpi	r18, 0x14	; 20
 bea:	49 f7       	brne	.-46     	; 0xbbe <USB_Device_ProcessControlRequest+0x1ba>
    (void)__s;
}

static __inline__ void __iRestore(const  uint8_t *__s)
{
    SREG = *__s;
 bec:	4f bf       	out	0x3f, r20	; 63
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 bee:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 bf2:	87 7f       	andi	r24, 0xF7	; 247
 bf4:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
		}
	}
	
	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
 bf8:	6a e2       	ldi	r22, 0x2A	; 42
 bfa:	70 e0       	ldi	r23, 0x00	; 0
 bfc:	ce 01       	movw	r24, r28
 bfe:	01 96       	adiw	r24, 0x01	; 1
 c00:	ea dc       	rcall	.-1580   	; 0x5d6 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 c02:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c06:	8b 77       	andi	r24, 0x7B	; 123
 c08:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c0c:	52 cf       	rjmp	.-348    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif
	
	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
 c0e:	ae 01       	movw	r20, r28
 c10:	4f 5f       	subi	r20, 0xFF	; 255
 c12:	5f 4f       	sbci	r21, 0xFF	; 255
 c14:	60 91 2b 02 	lds	r22, 0x022B	; 0x80022b <USB_ControlRequest+0x4>
 c18:	30 dc       	rcall	.-1952   	; 0x47a <CALLBACK_USB_GetDescriptor>
 c1a:	bc 01       	movw	r22, r24
 c1c:	89 2b       	or	r24, r25
 c1e:	09 f4       	brne	.+2      	; 0xc22 <USB_Device_ProcessControlRequest+0x21e>
 c20:	48 cf       	rjmp	.-368    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 c22:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c26:	97 7f       	andi	r25, 0xF7	; 247
 c28:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	#if defined(USE_RAM_DESCRIPTORS)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);	
 c2c:	89 81       	ldd	r24, Y+1	; 0x01
 c2e:	9a 81       	ldd	r25, Y+2	; 0x02
 c30:	27 dd       	rcall	.-1458   	; 0x680 <Endpoint_Write_Control_PStream_LE>
 c32:	e7 cf       	rjmp	.-50     	; 0xc02 <USB_Device_ProcessControlRequest+0x1fe>
				RequestHandled = true;
			}
			
			break;
		case REQ_GetConfiguration:
			if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
 c34:	80 38       	cpi	r24, 0x80	; 128
 c36:	19 f5       	brne	.+70     	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
 c38:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c3c:	87 7f       	andi	r24, 0xF7	; 247
 c3e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>

void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_Byte(USB_ConfigurationNumber);
 c42:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <USB_ConfigurationNumber>
			 *  \param[in] Byte  Next byte to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_Byte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_Byte(const uint8_t Byte)
			{
				UEDATX = Byte;
 c46:	80 93 f1 00 	sts	0x00F1, r24	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 c4a:	27 cf       	rjmp	.-434    	; 0xa9a <USB_Device_ProcessControlRequest+0x96>
				RequestHandled = true;
			}

			break;
		case REQ_SetConfiguration:
			if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
 c4c:	81 11       	cpse	r24, r1
 c4e:	17 c0       	rjmp	.+46     	; 0xc7e <USB_Device_ProcessControlRequest+0x27a>
}

static void USB_Device_SetConfiguration(void)
{
#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
 c50:	90 91 29 02 	lds	r25, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
 c54:	92 30       	cpi	r25, 0x02	; 2
 c56:	08 f0       	brcs	.+2      	; 0xc5a <USB_Device_ProcessControlRequest+0x256>
 c58:	2c cf       	rjmp	.-424    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
			 *  \note This is not applicable for non CONTROL type endpoints. 
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
 c5a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 c5e:	87 7f       	andi	r24, 0xF7	; 247
 c60:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	}
#endif
	
	Endpoint_ClearSETUP();

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
 c64:	90 93 25 02 	sts	0x0225, r25	; 0x800225 <USB_ConfigurationNumber>

	Endpoint_ClearStatusStage();
 c68:	6d dc       	rcall	.-1830   	; 0x544 <Endpoint_ClearStatusStage>

	USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
 c6a:	80 91 25 02 	lds	r24, 0x0225	; 0x800225 <USB_ConfigurationNumber>
 c6e:	81 11       	cpse	r24, r1
 c70:	04 c0       	rjmp	.+8      	; 0xc7a <USB_Device_ProcessControlRequest+0x276>

	EVENT_USB_Device_ConfigurationChanged();
 c72:	83 e0       	ldi	r24, 0x03	; 3
 c74:	8e bb       	out	0x1e, r24	; 30
 c76:	5e db       	rcall	.-2372   	; 0x334 <EVENT_USB_Device_ConfigurationChanged>

	USB_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;

	Endpoint_ClearStatusStage();

	USB_DeviceState = (USB_ConfigurationNumber) ? DEVICE_STATE_Configured : DEVICE_STATE_Addressed;
 c78:	1c cf       	rjmp	.-456    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>
 c7a:	84 e0       	ldi	r24, 0x04	; 4

			break;
	}

	if (!(RequestHandled))
	  EVENT_USB_Device_UnhandledControlRequest();
 c7c:	fb cf       	rjmp	.-10     	; 0xc74 <USB_Device_ProcessControlRequest+0x270>
 c7e:	5d db       	rcall	.-2374   	; 0x33a <EVENT_USB_Device_UnhandledControlRequest>
 c80:	18 cf       	rjmp	.-464    	; 0xab2 <USB_Device_ProcessControlRequest+0xae>

00000c82 <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
 c82:	08 95       	ret

00000c84 <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
 c84:	cf 93       	push	r28
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState != DEVICE_STATE_Unattached)
 c86:	8e b3       	in	r24, 0x1e	; 30
 c88:	88 23       	and	r24, r24
 c8a:	59 f0       	breq	.+22     	; 0xca2 <USB_USBTask+0x1e>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return (UENUM & ENDPOINT_EPNUM_MASK);
 c8c:	c0 91 e9 00 	lds	r28, 0x00E9	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 c90:	c7 70       	andi	r28, 0x07	; 7
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 c92:	10 92 e9 00 	sts	0x00E9, r1	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 *  \return Boolean true if the selected endpoint has received a SETUP packet, false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
 c96:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	{
		uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();
	
		Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

		if (Endpoint_IsSETUPReceived())
 c9a:	83 fd       	sbrc	r24, 3
		  USB_Device_ProcessControlRequest();
 c9c:	b3 de       	rcall	.-666    	; 0xa04 <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 c9e:	c0 93 e9 00 	sts	0x00E9, r28	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
		if (USB_CurrentMode == USB_MODE_DEVICE)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_HOST)
		  USB_HostTask();
	#endif
}
 ca2:	cf 91       	pop	r28
 ca4:	08 95       	ret

00000ca6 <CDC_Device_Event_Stub>:
	}
	else
	{
		return 0;
	}
}
 ca6:	08 95       	ret

00000ca8 <CDC_Device_ProcessControlRequest>:
 ca8:	cf 93       	push	r28
 caa:	df 93       	push	r29
 cac:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 cb0:	23 ff       	sbrs	r18, 3
 cb2:	11 c0       	rjmp	.+34     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 cb4:	fc 01       	movw	r30, r24
 cb6:	40 81       	ld	r20, Z
 cb8:	20 91 2b 02 	lds	r18, 0x022B	; 0x80022b <USB_ControlRequest+0x4>
 cbc:	30 91 2c 02 	lds	r19, 0x022C	; 0x80022c <USB_ControlRequest+0x5>
 cc0:	42 17       	cp	r20, r18
 cc2:	13 06       	cpc	r1, r19
 cc4:	41 f4       	brne	.+16     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 cc6:	ec 01       	movw	r28, r24
 cc8:	80 91 28 02 	lds	r24, 0x0228	; 0x800228 <USB_ControlRequest+0x1>
 ccc:	81 32       	cpi	r24, 0x21	; 33
 cce:	c1 f0       	breq	.+48     	; 0xd00 <CDC_Device_ProcessControlRequest+0x58>
 cd0:	28 f4       	brcc	.+10     	; 0xcdc <CDC_Device_ProcessControlRequest+0x34>
 cd2:	80 32       	cpi	r24, 0x20	; 32
 cd4:	49 f1       	breq	.+82     	; 0xd28 <CDC_Device_ProcessControlRequest+0x80>
 cd6:	df 91       	pop	r29
 cd8:	cf 91       	pop	r28
 cda:	08 95       	ret
 cdc:	82 32       	cpi	r24, 0x22	; 34
 cde:	c1 f1       	breq	.+112    	; 0xd50 <CDC_Device_ProcessControlRequest+0xa8>
 ce0:	83 32       	cpi	r24, 0x23	; 35
 ce2:	c9 f7       	brne	.-14     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 ce4:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <USB_ControlRequest>
 ce8:	81 32       	cpi	r24, 0x21	; 33
 cea:	a9 f7       	brne	.-22     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 cec:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 cf0:	87 7f       	andi	r24, 0xF7	; 247
 cf2:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 cf6:	60 91 29 02 	lds	r22, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
 cfa:	cf 01       	movw	r24, r30
 cfc:	d4 df       	rcall	.-88     	; 0xca6 <CDC_Device_Event_Stub>
 cfe:	37 c0       	rjmp	.+110    	; 0xd6e <CDC_Device_ProcessControlRequest+0xc6>
 d00:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <USB_ControlRequest>
 d04:	81 3a       	cpi	r24, 0xA1	; 161
 d06:	39 f7       	brne	.-50     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 d08:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d0c:	87 7f       	andi	r24, 0xF7	; 247
 d0e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d12:	67 e0       	ldi	r22, 0x07	; 7
 d14:	70 e0       	ldi	r23, 0x00	; 0
 d16:	cf 01       	movw	r24, r30
 d18:	0f 96       	adiw	r24, 0x0f	; 15
 d1a:	5d dc       	rcall	.-1862   	; 0x5d6 <Endpoint_Write_Control_Stream_LE>
 d1c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d20:	8b 77       	andi	r24, 0x7B	; 123
 d22:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d26:	d7 cf       	rjmp	.-82     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 d28:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <USB_ControlRequest>
 d2c:	81 32       	cpi	r24, 0x21	; 33
 d2e:	99 f6       	brne	.-90     	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 d30:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d34:	87 7f       	andi	r24, 0xF7	; 247
 d36:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d3a:	67 e0       	ldi	r22, 0x07	; 7
 d3c:	70 e0       	ldi	r23, 0x00	; 0
 d3e:	cf 01       	movw	r24, r30
 d40:	0f 96       	adiw	r24, 0x0f	; 15
 d42:	f4 dc       	rcall	.-1560   	; 0x72c <Endpoint_Read_Control_Stream_LE>
 d44:	ce 01       	movw	r24, r28
 d46:	fc da       	rcall	.-2568   	; 0x340 <EVENT_CDC_Device_LineEncodingChanged>
 d48:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d4c:	8e 77       	andi	r24, 0x7E	; 126
 d4e:	e9 cf       	rjmp	.-46     	; 0xd22 <CDC_Device_ProcessControlRequest+0x7a>
 d50:	80 91 27 02 	lds	r24, 0x0227	; 0x800227 <USB_ControlRequest>
 d54:	81 32       	cpi	r24, 0x21	; 33
 d56:	09 f0       	breq	.+2      	; 0xd5a <CDC_Device_ProcessControlRequest+0xb2>
 d58:	be cf       	rjmp	.-132    	; 0xcd6 <CDC_Device_ProcessControlRequest+0x2e>
 d5a:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d5e:	87 7f       	andi	r24, 0xF7	; 247
 d60:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 d64:	80 91 29 02 	lds	r24, 0x0229	; 0x800229 <USB_ControlRequest+0x2>
 d68:	85 87       	std	Z+13, r24	; 0x0d
 d6a:	cf 01       	movw	r24, r30
 d6c:	7e db       	rcall	.-2308   	; 0x46a <EVENT_CDC_Device_ControLineStateChanged>
 d6e:	df 91       	pop	r29
 d70:	cf 91       	pop	r28
 d72:	e8 cb       	rjmp	.-2096   	; 0x544 <Endpoint_ClearStatusStage>

00000d74 <CDC_Device_ConfigureEndpoints>:
 d74:	0f 93       	push	r16
 d76:	1f 93       	push	r17
 d78:	cf 93       	push	r28
 d7a:	df 93       	push	r29
 d7c:	ec 01       	movw	r28, r24
 d7e:	fc 01       	movw	r30, r24
 d80:	3d 96       	adiw	r30, 0x0d	; 13
 d82:	89 e0       	ldi	r24, 0x09	; 9
 d84:	df 01       	movw	r26, r30
 d86:	1d 92       	st	X+, r1
 d88:	8a 95       	dec	r24
 d8a:	e9 f7       	brne	.-6      	; 0xd86 <CDC_Device_ConfigureEndpoints+0x12>
 d8c:	8a 81       	ldd	r24, Y+2	; 0x02
 d8e:	9b 81       	ldd	r25, Y+3	; 0x03
 d90:	2c 81       	ldd	r18, Y+4	; 0x04
 d92:	10 e0       	ldi	r17, 0x00	; 0
 d94:	21 11       	cpse	r18, r1
 d96:	14 e0       	ldi	r17, 0x04	; 4
 d98:	09 81       	ldd	r16, Y+1	; 0x01
 d9a:	9f db       	rcall	.-2242   	; 0x4da <Endpoint_BytesToEPSizeMaskDynamic>
 d9c:	81 2b       	or	r24, r17
 d9e:	48 2f       	mov	r20, r24
 da0:	42 60       	ori	r20, 0x02	; 2
 da2:	61 e8       	ldi	r22, 0x81	; 129
 da4:	80 2f       	mov	r24, r16
 da6:	a7 db       	rcall	.-2226   	; 0x4f6 <Endpoint_ConfigureEndpoint_Prv>
 da8:	88 23       	and	r24, r24
 daa:	11 f1       	breq	.+68     	; 0xdf0 <CDC_Device_ConfigureEndpoints+0x7c>
 dac:	8e 81       	ldd	r24, Y+6	; 0x06
 dae:	9f 81       	ldd	r25, Y+7	; 0x07
 db0:	28 85       	ldd	r18, Y+8	; 0x08
 db2:	10 e0       	ldi	r17, 0x00	; 0
 db4:	21 11       	cpse	r18, r1
 db6:	14 e0       	ldi	r17, 0x04	; 4
 db8:	0d 81       	ldd	r16, Y+5	; 0x05
 dba:	8f db       	rcall	.-2274   	; 0x4da <Endpoint_BytesToEPSizeMaskDynamic>
 dbc:	81 2b       	or	r24, r17
 dbe:	48 2f       	mov	r20, r24
 dc0:	42 60       	ori	r20, 0x02	; 2
 dc2:	60 e8       	ldi	r22, 0x80	; 128
 dc4:	80 2f       	mov	r24, r16
 dc6:	97 db       	rcall	.-2258   	; 0x4f6 <Endpoint_ConfigureEndpoint_Prv>
 dc8:	88 23       	and	r24, r24
 dca:	91 f0       	breq	.+36     	; 0xdf0 <CDC_Device_ConfigureEndpoints+0x7c>
 dcc:	8a 85       	ldd	r24, Y+10	; 0x0a
 dce:	9b 85       	ldd	r25, Y+11	; 0x0b
 dd0:	2c 85       	ldd	r18, Y+12	; 0x0c
 dd2:	10 e0       	ldi	r17, 0x00	; 0
 dd4:	21 11       	cpse	r18, r1
 dd6:	14 e0       	ldi	r17, 0x04	; 4
 dd8:	c9 85       	ldd	r28, Y+9	; 0x09
 dda:	7f db       	rcall	.-2306   	; 0x4da <Endpoint_BytesToEPSizeMaskDynamic>
 ddc:	81 2b       	or	r24, r17
 dde:	48 2f       	mov	r20, r24
 de0:	42 60       	ori	r20, 0x02	; 2
 de2:	61 ec       	ldi	r22, 0xC1	; 193
 de4:	8c 2f       	mov	r24, r28
 de6:	df 91       	pop	r29
 de8:	cf 91       	pop	r28
 dea:	1f 91       	pop	r17
 dec:	0f 91       	pop	r16
 dee:	83 cb       	rjmp	.-2298   	; 0x4f6 <Endpoint_ConfigureEndpoint_Prv>
 df0:	80 e0       	ldi	r24, 0x00	; 0
 df2:	df 91       	pop	r29
 df4:	cf 91       	pop	r28
 df6:	1f 91       	pop	r17
 df8:	0f 91       	pop	r16
 dfa:	08 95       	ret

00000dfc <CDC_Device_SendByte>:
 dfc:	0f 93       	push	r16
 dfe:	1f 93       	push	r17
 e00:	cf 93       	push	r28
 e02:	2e b3       	in	r18, 0x1e	; 30
 e04:	24 30       	cpi	r18, 0x04	; 4
 e06:	09 f5       	brne	.+66     	; 0xe4a <CDC_Device_SendByte+0x4e>
 e08:	fc 01       	movw	r30, r24
 e0a:	07 85       	ldd	r16, Z+15	; 0x0f
 e0c:	10 89       	ldd	r17, Z+16	; 0x10
 e0e:	21 89       	ldd	r18, Z+17	; 0x11
 e10:	32 89       	ldd	r19, Z+18	; 0x12
 e12:	01 2b       	or	r16, r17
 e14:	02 2b       	or	r16, r18
 e16:	03 2b       	or	r16, r19
 e18:	c1 f0       	breq	.+48     	; 0xe4a <CDC_Device_SendByte+0x4e>
 e1a:	c6 2f       	mov	r28, r22
 e1c:	81 81       	ldd	r24, Z+1	; 0x01
 e1e:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 e22:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e26:	85 ff       	sbrs	r24, 5
 e28:	07 c0       	rjmp	.+14     	; 0xe38 <CDC_Device_SendByte+0x3c>
 e2a:	c0 93 f1 00 	sts	0x00F1, r28	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
 e2e:	80 e0       	ldi	r24, 0x00	; 0
 e30:	cf 91       	pop	r28
 e32:	1f 91       	pop	r17
 e34:	0f 91       	pop	r16
 e36:	08 95       	ret
 e38:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e3c:	8e 77       	andi	r24, 0x7E	; 126
 e3e:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e42:	9d db       	rcall	.-2246   	; 0x57e <Endpoint_WaitUntilReady>
 e44:	88 23       	and	r24, r24
 e46:	89 f3       	breq	.-30     	; 0xe2a <CDC_Device_SendByte+0x2e>
 e48:	f3 cf       	rjmp	.-26     	; 0xe30 <CDC_Device_SendByte+0x34>
 e4a:	82 e0       	ldi	r24, 0x02	; 2
 e4c:	f1 cf       	rjmp	.-30     	; 0xe30 <CDC_Device_SendByte+0x34>

00000e4e <CDC_Device_Flush>:
 e4e:	2e b3       	in	r18, 0x1e	; 30
 e50:	24 30       	cpi	r18, 0x04	; 4
 e52:	21 f5       	brne	.+72     	; 0xe9c <CDC_Device_Flush+0x4e>
 e54:	fc 01       	movw	r30, r24
 e56:	47 85       	ldd	r20, Z+15	; 0x0f
 e58:	50 89       	ldd	r21, Z+16	; 0x10
 e5a:	61 89       	ldd	r22, Z+17	; 0x11
 e5c:	72 89       	ldd	r23, Z+18	; 0x12
 e5e:	45 2b       	or	r20, r21
 e60:	46 2b       	or	r20, r22
 e62:	47 2b       	or	r20, r23
 e64:	d9 f0       	breq	.+54     	; 0xe9c <CDC_Device_Flush+0x4e>
 e66:	81 81       	ldd	r24, Z+1	; 0x01
 e68:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
 e6c:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
 e70:	81 11       	cpse	r24, r1
 e72:	02 c0       	rjmp	.+4      	; 0xe78 <CDC_Device_Flush+0x2a>
 e74:	80 e0       	ldi	r24, 0x00	; 0
 e76:	08 95       	ret
 e78:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e7c:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e80:	8e 77       	andi	r24, 0x7E	; 126
 e82:	80 93 e8 00 	sts	0x00E8, r24	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e86:	95 fd       	sbrc	r25, 5
 e88:	f5 cf       	rjmp	.-22     	; 0xe74 <CDC_Device_Flush+0x26>
 e8a:	79 db       	rcall	.-2318   	; 0x57e <Endpoint_WaitUntilReady>
 e8c:	81 11       	cpse	r24, r1
 e8e:	07 c0       	rjmp	.+14     	; 0xe9e <CDC_Device_Flush+0x50>
 e90:	90 91 e8 00 	lds	r25, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e94:	9e 77       	andi	r25, 0x7E	; 126
 e96:	90 93 e8 00 	sts	0x00E8, r25	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 e9a:	08 95       	ret
 e9c:	82 e0       	ldi	r24, 0x02	; 2
 e9e:	08 95       	ret

00000ea0 <CDC_Device_USBTask>:
 ea0:	2e b3       	in	r18, 0x1e	; 30
 ea2:	24 30       	cpi	r18, 0x04	; 4
 ea4:	51 f4       	brne	.+20     	; 0xeba <CDC_Device_USBTask+0x1a>
 ea6:	fc 01       	movw	r30, r24
 ea8:	47 85       	ldd	r20, Z+15	; 0x0f
 eaa:	50 89       	ldd	r21, Z+16	; 0x10
 eac:	61 89       	ldd	r22, Z+17	; 0x11
 eae:	72 89       	ldd	r23, Z+18	; 0x12
 eb0:	45 2b       	or	r20, r21
 eb2:	46 2b       	or	r20, r22
 eb4:	47 2b       	or	r20, r23
 eb6:	09 f0       	breq	.+2      	; 0xeba <CDC_Device_USBTask+0x1a>
 eb8:	ca cf       	rjmp	.-108    	; 0xe4e <CDC_Device_Flush>
 eba:	08 95       	ret

00000ebc <CDC_Device_ReceiveByte>:

int16_t CDC_Device_ReceiveByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
 ebc:	2e b3       	in	r18, 0x1e	; 30
 ebe:	24 30       	cpi	r18, 0x04	; 4
 ec0:	19 f0       	breq	.+6      	; 0xec8 <CDC_Device_ReceiveByte+0xc>
	  return -1;
 ec2:	8f ef       	ldi	r24, 0xFF	; 255
 ec4:	9f ef       	ldi	r25, 0xFF	; 255
 ec6:	08 95       	ret
	}
}

int16_t CDC_Device_ReceiveByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
 ec8:	fc 01       	movw	r30, r24
 eca:	47 85       	ldd	r20, Z+15	; 0x0f
 ecc:	50 89       	ldd	r21, Z+16	; 0x10
 ece:	61 89       	ldd	r22, Z+17	; 0x11
 ed0:	72 89       	ldd	r23, Z+18	; 0x12
 ed2:	45 2b       	or	r20, r21
 ed4:	46 2b       	or	r20, r22
 ed6:	47 2b       	or	r20, r23
 ed8:	a1 f3       	breq	.-24     	; 0xec2 <CDC_Device_ReceiveByte+0x6>
	  return -1;

	int16_t ReceivedByte = -1;

	Endpoint_SelectEndpoint(CDCInterfaceInfo->Config.DataOUTEndpointNumber);
 eda:	85 81       	ldd	r24, Z+5	; 0x05
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t EndpointNumber)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = EndpointNumber;
 edc:	80 93 e9 00 	sts	0x00E9, r24	; 0x8000e9 <__EEPROM_REGION_LENGTH__+0x7f00e9>
			 *  \return Boolean true if current endpoint is has received an OUT packet, false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
 ee0:	80 91 e8 00 	lds	r24, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
	
	if (Endpoint_IsOUTReceived())
 ee4:	82 ff       	sbrs	r24, 2
 ee6:	ed cf       	rjmp	.-38     	; 0xec2 <CDC_Device_ReceiveByte+0x6>
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
 ee8:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
	{
		if (Endpoint_BytesInEndpoint())
 eec:	88 23       	and	r24, r24
 eee:	69 f0       	breq	.+26     	; 0xf0a <CDC_Device_ReceiveByte+0x4e>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_Byte(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_Byte(void)
			{
				return UEDATX;
 ef0:	80 91 f1 00 	lds	r24, 0x00F1	; 0x8000f1 <__EEPROM_REGION_LENGTH__+0x7f00f1>
		  ReceivedByte = Endpoint_Read_Byte();
 ef4:	90 e0       	ldi	r25, 0x00	; 0
				#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
					return UEBCX;
				#elif defined(USB_SERIES_4_AVR)
					return (((uint16_t)UEBCHX << 8) | UEBCLX);
				#elif defined(USB_SERIES_2_AVR)
					return UEBCLX;
 ef6:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__EEPROM_REGION_LENGTH__+0x7f00f2>
	
		if (!(Endpoint_BytesInEndpoint()))
 efa:	21 11       	cpse	r18, r1
 efc:	05 c0       	rjmp	.+10     	; 0xf08 <CDC_Device_ReceiveByte+0x4c>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
 efe:	20 91 e8 00 	lds	r18, 0x00E8	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
 f02:	2b 77       	andi	r18, 0x7B	; 123
 f04:	20 93 e8 00 	sts	0x00E8, r18	; 0x8000e8 <__EEPROM_REGION_LENGTH__+0x7f00e8>
		  Endpoint_ClearOUT();
	}
	
	return ReceivedByte;
}
 f08:	08 95       	ret
int16_t CDC_Device_ReceiveByte(USB_ClassInfo_CDC_Device_t* const CDCInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) || !(CDCInterfaceInfo->State.LineEncoding.BaudRateBPS))
	  return -1;

	int16_t ReceivedByte = -1;
 f0a:	8f ef       	ldi	r24, 0xFF	; 255
 f0c:	9f ef       	ldi	r25, 0xFF	; 255
 f0e:	f3 cf       	rjmp	.-26     	; 0xef6 <CDC_Device_ReceiveByte+0x3a>

00000f10 <__udivmodsi4>:
 f10:	a1 e2       	ldi	r26, 0x21	; 33
 f12:	1a 2e       	mov	r1, r26
 f14:	aa 1b       	sub	r26, r26
 f16:	bb 1b       	sub	r27, r27
 f18:	fd 01       	movw	r30, r26
 f1a:	0d c0       	rjmp	.+26     	; 0xf36 <__udivmodsi4_ep>

00000f1c <__udivmodsi4_loop>:
 f1c:	aa 1f       	adc	r26, r26
 f1e:	bb 1f       	adc	r27, r27
 f20:	ee 1f       	adc	r30, r30
 f22:	ff 1f       	adc	r31, r31
 f24:	a2 17       	cp	r26, r18
 f26:	b3 07       	cpc	r27, r19
 f28:	e4 07       	cpc	r30, r20
 f2a:	f5 07       	cpc	r31, r21
 f2c:	20 f0       	brcs	.+8      	; 0xf36 <__udivmodsi4_ep>
 f2e:	a2 1b       	sub	r26, r18
 f30:	b3 0b       	sbc	r27, r19
 f32:	e4 0b       	sbc	r30, r20
 f34:	f5 0b       	sbc	r31, r21

00000f36 <__udivmodsi4_ep>:
 f36:	66 1f       	adc	r22, r22
 f38:	77 1f       	adc	r23, r23
 f3a:	88 1f       	adc	r24, r24
 f3c:	99 1f       	adc	r25, r25
 f3e:	1a 94       	dec	r1
 f40:	69 f7       	brne	.-38     	; 0xf1c <__udivmodsi4_loop>
 f42:	60 95       	com	r22
 f44:	70 95       	com	r23
 f46:	80 95       	com	r24
 f48:	90 95       	com	r25
 f4a:	9b 01       	movw	r18, r22
 f4c:	ac 01       	movw	r20, r24
 f4e:	bd 01       	movw	r22, r26
 f50:	cf 01       	movw	r24, r30
 f52:	08 95       	ret

00000f54 <__tablejump2__>:
 f54:	ee 0f       	add	r30, r30
 f56:	ff 1f       	adc	r31, r31
 f58:	05 90       	lpm	r0, Z+
 f5a:	f4 91       	lpm	r31, Z
 f5c:	e0 2d       	mov	r30, r0
 f5e:	09 94       	ijmp

00000f60 <_exit>:
 f60:	f8 94       	cli

00000f62 <__stop_program>:
 f62:	ff cf       	rjmp	.-2      	; 0xf62 <__stop_program>
